=============================================================
배송 실시간 관제 시스템 - 요구사항 및 상세 동작 명세서 (합본)
=============================================================
본 문서는 아래 두 파일의 원본 내용을 모두 합본한 것입니다.
누락된 항목이 전혀 없도록 주의 깊게 작성하였으며,
복사/참조가 용이하도록 일관된 문서 형식(txt)으로 제공합니다.

-------------------------------------------------------------
목차
-------------------------------------------------------------
1. PART I. 요구사항 개요서 (요구사항 개요서.txt)
2. PART II. 상세 동작 명세서 (상세 동작 명세서.txt)

=============================================================
PART I. 요구사항 개요서
=============================================================
배송 실시간 관제 시스템 요구사항 및 기능 설명서

1. 프로젝트 개요
본 프로젝트는 배송 실시간 관제 및 데이터 시각화 시스템으로, 기업 내부에서 사용할 배송 및 반품 주문을 효율적으로 관리하기 위한 웹 애플리케이션입니다. 이 시스템은 React 기반의 프론트엔드와 FastAPI 기반의 백엔드로 구성되어 있으며, 실시간 데이터 관리, 시각화, 사용자 권한 기반 기능 제공이 주요 특징입니다.

2. 핵심 기능 및 사용자 요구사항
2.1 인증 및 권한 관리 시스템
주요 기능
- JWT 기반 사용자 인증: 액세스 토큰(60분)과 리프레시 토큰(7일) 체계 구현
- 권한 기반 접근 제어: 일반 사용자(USER)와 관리자(ADMIN) 권한 구분
- 자동 토큰 갱신: 액세스 토큰 만료 시 리프레시 토큰을 통한 자동 갱신
- 세션 상태 관리: LocalStorage를 통한 인증 정보 저장 및 브라우저 탭 간 공유

사용자 시나리오
- 사용자는 로그인 화면에서 ID와 비밀번호 입력
- 성공적인 인증 시 권한에 따른 대시보드 화면으로 리디렉션
- 일정 시간 활동 없이 토큰 만료 시 자동으로 토큰 갱신 시도
- 로그아웃 시 모든 인증 정보 삭제 및 로그인 화면으로 리디렉션

2.2 대시보드 및 배차 관리
주요 기능
- ETA 기반 주문 목록 조회: 예상 도착 시간(ETA)을 기준으로 배송/반품 주문 조회
- 필터링 및 검색: 부서, 타입, 출발 허브, 주문번호 등 다양한 조건으로 필터링
- 상태별 시각적 구분: 대기, 진행, 완료, 이슈, 취소 등 상태별 색상 구분
- 배차 처리: 선택한 주문에 배송 담당자 및 연락처 배정
- 권한별 차별화된 UI: 관리자/일반 사용자 권한에 따라 UI 및 기능 제약

사용자 시나리오
- 사용자는 날짜 범위를 선택하여 배송 주문 목록 조회
- 필요에 따라 필터링 및 검색으로 원하는 주문 식별
- 일반 사용자는 대기 상태 주문만 선택하여 배차 처리 가능
- 관리자는 모든 상태의 주문을 선택하여 배차 처리 가능
- 주문 행 클릭 시 상세 정보 모달 표시 및 수정/상태 변경 가능

2.3 주문 상태 관리 및 데이터 편집
주요 기능
- 상태 변경 워크플로우: 배송 상태에 따른 단계별 변경 가능 (권한별 제약 적용)
- 상세 정보 조회 및 편집: 주문 정보, 배송 정보, 수령인 정보 등 관리
- 메모 기능: 배송 관련 메모 추가 및 관리
- 낙관적 락(Optimistic Lock): 버전 관리를 통한 동시 수정 충돌 방지
- 비관적 락(Pessimistic Lock): 편집, 상태 변경 등 작업 시 타임아웃 기반 락 적용

사용자 시나리오
- 사용자가 주문 정보 클릭 시 상세 정보 모달 표시
- 일반 사용자는 순차적 상태 변경만 가능 (WAITING → IN_PROGRESS → COMPLETE/ISSUE/CANCEL)
- 관리자는 모든 상태 간 자유로운 변경 가능
- 다른 사용자가 이미 편집 중인 경우 락 충돌 메시지 표시
- 동시 수정 시 낙관적 락 충돌 감지 및 최신 데이터로 갱신 유도

2.4 데이터 시각화 및 통계
주요 기능
- 배송 현황 시각화: 파이 차트를 통한 상태별 배송 현황 표시
- 시간대별 접수량 분석: 시간대별 주문 접수 패턴 막대 그래프로 시각화
- 부서별 데이터 분석: CS, HES, LENOVO 등 부서별 데이터 집계 및 표시
- 기간 선택 및 필터링: 사용자 지정 날짜 범위로 데이터 분석
- 조회 가능 날짜 범위: 시스템에 존재하는 데이터 기준 최소/최대 날짜 표시

사용자 시나리오
- 사용자는 분석하고자 하는 날짜 범위 선택
- 배송 현황/시간대별 접수량 중 원하는 시각화 유형 선택
- 차트를 통해 부서별, 상태별, 시간대별 데이터 패턴 파악
- 데이터에 기반한 의사결정 및 자원 배치 최적화

3. 기술적 아키텍처
3.1 프론트엔드 아키텍처
핵심 기술 스택
- React 18: 컴포넌트 기반 UI 구현
- Context API: 전역 상태 관리 (인증, 대시보드 데이터)
- Ant Design 5: UI 컴포넌트 라이브러리
- Axios: HTTP 클라이언트 및 인터셉터 시스템

구조적 설계
- 계층화된 컴포넌트 구조: 페이지, 기능 컴포넌트, 공통 컴포넌트 계층
- 컨텍스트 기반 상태 관리: AuthContext, DashboardContext를 통한 전역 상태 관리
- 서비스 레이어 패턴: API 호출 로직을 서비스 클래스로 분리
- 커스텀 훅: 날짜 범위 관리, 필터링 등 재사용 가능한 로직 분리

3.2 백엔드 아키텍처
핵심 기술 스택
- FastAPI: 고성능 Python 웹 프레임워크
- SQLAlchemy: ORM을 통한 데이터베이스 액세스
- JWT: 인증 및 권한 부여 시스템
- MySQL: 주요 데이터 저장소

구조적 설계
- 계층형 아키텍처: API 라우터, 서비스 레이어, 레포지토리 레이어 구분
- 스키마 기반 검증: Pydantic 모델을 통한 요청/응답 데이터 검증
- 의존성 주입 패턴: FastAPI의 Depends를 활용한 의존성 관리
- 예외 처리 체계: 구조화된 에러 응답 시스템

3.3 데이터 모델
주요 엔티티
- Dashboard: 배송/반품 주문 정보 (주문번호, 타입, 상태, ETA 등)
- DashboardRemark: 주문 관련 메모 정보
- DashboardLock: 비관적 락 정보 (사용자 ID, 락 타입, 만료 시간 등)
- User: 사용자 정보 (ID, 비밀번호 해시, 부서, 권한)
- RefreshToken: 리프레시 토큰 정보 (사용자 ID, 토큰, 만료 시간)

관계 모델링
- Dashboard ↔ DashboardRemark: 1:N 관계
- Dashboard ↔ DashboardLock: 1:1 관계
- User ↔ RefreshToken: 1:N 관계

4. 동시성 제어 및 데이터 무결성
4.1 낙관적 락(Optimistic Lock) 시스템
작동 원리
- 각 대시보드 레코드에 버전 필드 추가
- 데이터 수정 시 버전 함께 전송 및 서버에서 비교
- 버전 불일치 시 409 Conflict 응답 반환

사용자 경험
- 충돌 발생 시 안내 메시지 표시 및 최신 데이터로 갱신 유도
- 새 버전 정보를 포함한 안내로 재시도 지원
- 실시간 충돌 감지로 데이터 일관성 유지

4.2 비관적 락(Pessimistic Lock) 시스템
작동 원리
- 편집, 상태 변경, 배차, 메모 각각 독립적인 락 타입 정의
- 작업 시작 시 락 획득 시도 및 타임아웃 설정 (기본 5분)
- 작업 완료/실패 시 자동 락 해제

사용자 경험
- 다른 사용자의 락 감지 시 "현재 {사용자명}이 편집 중입니다" 메시지 표시
- 락 충돌 시 읽기 전용 모드 제공
- 락 해제 시 자동 알림 없이 새로고침 필요

5. 사용자 권한별 제약 및 기능 차별화
5.1 일반 사용자(USER) 기능
제약 사항
- 상태 변경 제약: WAITING → IN_PROGRESS → COMPLETE/ISSUE/CANCEL만 가능
- 배차 처리 제약: 대기(WAITING) 상태 주문만 배차 가능
- 주문 삭제 불가: 삭제 기능 UI 미표시

사용 가능 기능
- 대시보드 조회 및 필터링
- 신규 주문 등록
- 주문 정보 및 메모 편집
- 제한된 상태 흐름 내 상태 변경

5.2 관리자(ADMIN) 기능
확장 기능
- 상태 변경 자유도: 모든 상태 간 자유로운 변경 가능
- 배차 처리 자유도: 모든 상태의 주문 배차 가능
- 주문 삭제 권한: 선택한 주문 영구 삭제 가능

관리 도구
- 버전 정보 표시: 주문 상세 화면에 버전 정보 표시
- 관리자 전용 UI 요소: 삭제 버튼, 관리자 모드 표시 등
- 배치 작업: 다중 선택 주문 일괄 처리

6. 시스템 UX/UI 설계
6.1 레이아웃 및 내비게이션
구조적 설계
- 사이드바 내비게이션: 배차, 통계, 관리(관리자 전용)
- 메인 콘텐츠 영역: 테이블/차트 등 주요 콘텐츠 표시
- 모달 기반 상호작용: 주문 생성, 상세 정보, 배차 등 모달 방식 제공

접근성 고려사항
- 반응형 레이아웃: 다양한 화면 크기 대응
- 키보드 접근성: 주요 기능 키보드 단축키 지원
- 상태별 색상 시스템: 색상으로 상태 쉽게 구분

6.2 상태 피드백 및 알림
사용자 알림 시스템
- 토스트 메시지: 작업 성공/실패 시 자동 사라지는 알림
- 모달 알림: 중요 작업 확인/취소 여부 요청
- 인라인 피드백: 폼 유효성 검증 등 즉각적 피드백

로딩 상태 표시
- 데이터 조회 시 로딩 스피너
- 버튼 내 로딩 상태 표시
- 페이지 전환 시 스켈레톤 로딩

7. 성능 최적화 전략
7.1 프론트엔드 최적화
렌더링 최적화
- 메모이제이션: React.memo, useMemo, useCallback을 활용한 불필요한 리렌더링 방지
- 가상화: 대량의 데이터를 처리하는 테이블에 가상화 기법 적용
- 지연 로딩: 필요할 때만 컴포넌트와 데이터 로딩

데이터 관리 최적화
- 상태 정규화: 중복 데이터 최소화
- 페이지네이션: 대량 데이터의 페이지 단위 로딩
- 클라이언트 캐싱: 이미 로드된 데이터 재활용

7.2 백엔드 최적화
쿼리 최적화
- 인덱스 활용: ETA, status 등 주요 필드 인덱싱
- 조인 최적화: 필요한 관계만 선택적 조인
- 쿼리 캐싱: 자주 사용되는 쿼리 결과 캐싱

API 응답 최적화
- 필요한 필드만 선택: 클라이언트 요구에 맞는 최소 데이터 전송
- 압축: 응답 데이터 gzip 압축
- HTTP 캐싱: 적절한 캐시 헤더 설정

8. 배포 및 운영 고려사항
8.1 배포 아키텍처
환경 구성
- 개발 환경: 로컬 Docker 기반 개발 환경
- 스테이징 환경: 테스트 및 검증용 환경
- 운영 환경: Google App Engine(GAE) 기반 운영 환경

지속적 통합/배포
- 코드 변경 시 자동 빌드 및 테스트
- 스테이징 환경 자동 배포
- 운영 환경 수동 승인 후 배포

8.2 모니터링 및 유지보수
모니터링 전략
- 시스템 성능 및 가용성 모니터링
- 사용자 행동 분석 및 기능 사용률 추적
- 에러 로깅 및 알림 체계

데이터 관리
- 주기적인 데이터 백업
- 오래된 데이터 아카이빙
- 데이터 정합성 검증

9. 확장 가능성 및 미래 로드맵
9.1 기능 확장 가능성
단기 확장
- 대시보드 커스터마이징: 사용자별 대시보드 레이아웃 저장
- 알림 시스템: 상태 변경 및 중요 이벤트 알림
- 배치 프로세싱: 다중 주문 일괄 처리 기능 강화

장기 확장
- 모바일 앱 지원: React Native 기반 모바일 앱 개발
- 고급 분석: 머신러닝 기반 배송 패턴 분석 및 예측
- 외부 시스템 연동: CRM, ERP 등 기업 시스템 통합

9.2 기술적 로드맵
아키텍처 개선
- 마이크로서비스 아키텍처로 전환
- 서버리스 컴퓨팅 활용 확대

데이터 관리 고도화
- 데이터 웨어하우스 구축
- 실시간 데이터 분석 파이프라인
- 데이터 레이크 아키텍처 도입


=============================================================
PART II. 상세 동작 명세서
=============================================================
배송 실시간 관제 시스템 기능별 상세 동작 명세서

1. 인증 및 권한 관리 시스템
1.1 로그인 프로세스
프론트엔드 동작
- 초기 렌더링: LoginPage 컴포넌트가 마운트되며 로그인 폼 렌더링
- 입력 검증: 사용자 ID와 비밀번호 필드에 대한 유효성 검증 수행
  - 필수 입력값 확인
  - 비밀번호 최소 길이 검증
  - 공백 문자 필터링
- 제출 처리: 폼 제출 시 AuthService.login() 메소드 호출
- 로딩 상태 관리: 로그인 진행 중 로딩 스피너 표시 및 폼 비활성화
- 응답 처리:
  - 성공 시: localStorage에 인증 정보 저장 및 권한에 따른 페이지 리디렉션
  - 실패 시: 오류 메시지 표시 및 폼 초기화

백엔드 동작
- 요청 수신: /auth/login 엔드포인트에서 POST 요청 수신
- 입력 검증: Pydantic 스키마를 통한 요청 데이터 유효성 검증
- 사용자 인증:
  - DB에서 사용자 ID 조회
  - 비밀번호 해시 비교 (bcrypt 활용)
- 토큰 생성:
  - 액세스 토큰(60분) 생성 - user_id, department, role 정보 포함
  - 리프레시 토큰(7일) 생성
- 토큰 저장: 리프레시 토큰을 refresh_token 테이블에 저장
- 응답 반환: 토큰 정보와 사용자 정보를 함께 반환

1.2 토큰 갱신 메커니즘
프론트엔드 동작
- 토큰 만료 감지: axios 인터셉터에서 401 응답 감지
- 갱신 프로세스 시작: AuthService.refreshToken() 메소드 호출
- 갱신 요청 전송: 저장된 리프레시 토큰을 사용하여 갱신 요청
- 갱신 응답 처리:
  - 성공 시: 새 토큰 저장 및 원래 요청 재시도
  - 실패 시: 로그아웃 처리 및 로그인 페이지로 리디렉션
- 현재 페이지 저장: 리디렉션 전 현재 URL을 localStorage에 저장

백엔드 동작
- 요청 수신: /auth/refresh 엔드포인트에서 POST 요청 수신
- 토큰 검증:
  - 리프레시 토큰 유효성 확인
  - DB에서 토큰 존재 및 만료 여부 확인
- 사용자 정보 조회: 토큰과 연결된 사용자 정보 조회
- 새 토큰 생성:
  - 새 액세스 토큰 생성
  - 새 리프레시 토큰 생성 (선택적으로 갱신)
- 토큰 업데이트: DB에 새 리프레시 토큰 저장
- 응답 반환: 새 토큰 정보 반환

1.3 보안 세션 확인
프론트엔드 동작
- 초기 로드 검증: AuthContext 초기화 시 저장된 토큰 확인
- 세션 검증 요청: AuthService.checkSession() 메소드를 통한 토큰 유효성 확인
- 응답 처리:
  - 유효한 세션: 사용자 정보 설정 및 애플리케이션 접근 허용
  - 유효하지 않은 세션: 토큰 갱신 시도 또는 로그인 페이지로 리디렉션
- 전역 상태 관리: 인증 상태를 Context API를 통해 전역 상태로 관리

백엔드 동작
- 요청 수신: /auth/check-session 엔드포인트에서 GET 요청 수신
- 토큰 추출: Authorization 헤더에서 Bearer 토큰 추출
- 토큰 검증:
  - JWT 서명 확인
  - 만료 시간 검증
- 페이로드 파싱: 토큰에서 사용자 정보(sub, department, role) 추출
- 응답 반환: 세션 유효성 및 사용자 정보 포함하여 응답

1.4 로그아웃 프로세스
프론트엔드 동작
- 로그아웃 요청: 사용자가 로그아웃 버튼 클릭 시 AuthService.logout() 호출
- 로컬 스토리지 정리: 저장된 토큰 및 사용자 정보 삭제
- 상태 초기화: AuthContext의 사용자 상태 null로 설정
- 페이지 리디렉션: 로그인 페이지로 강제 리디렉션
- 이벤트 발송: 다른 탭에 로그아웃 알림을 위한 이벤트 발송

백엔드 동작
- 요청 수신: /auth/logout 엔드포인트에서 POST 요청 수신
- 리프레시 토큰 확인: 요청에 포함된 리프레시 토큰 유효성 확인
- 토큰 삭제: DB에서 리프레시 토큰 레코드 삭제
- 응답 반환: 로그아웃 성공 메시지 반환

2. 대시보드 및 주문 관리
2.1 대시보드 목록 조회
프론트엔드 동작
- 날짜 범위 선택: DateRangePicker를 통한 조회 기간 설정
- 데이터 요청: DashboardService.getDashboardList() 호출
- 로딩 상태 관리: 데이터 로딩 중 스피너 표시
- 데이터 정규화: 응답 데이터 검증 및 필요 시 기본값 설정
- 필터링 및 정렬:
  - 타입, 부서, 허브 등 다양한 조건으로 클라이언트 측 필터링
  - 상태 그룹화 및 ETA 기준 정렬
- UI 렌더링:
  - 상태별 색상 코딩 적용
  - 페이지네이션 처리
  - 권한에 따른 선택 가능 항목 제한

백엔드 동작
- 요청 수신: /dashboard/list 엔드포인트에서 GET 요청 수신
- 파라미터 파싱:
  - 단일 날짜(date) 또는 날짜 범위(start_date, end_date) 파싱
  - 날짜 형식 검증 및 시간 범위 계산
- 권한 확인: 현재 사용자의 인증 및 권한 확인
- 데이터 조회:
  - ETA 기준으로 지정된 날짜 범위 내 주문 데이터 조회
  - 상태별 정렬 및 그룹화
- 응답 데이터 구성:
  - 주문 목록
  - 날짜 범위 정보
  - 사용자 권한 정보

2.2 주문 상세 정보 조회
프론트엔드 동작
- 주문 행 클릭: 테이블에서 주문 행 클릭 시 상세 정보 요청
- 데이터 요청: DashboardService.getDashboardDetail() 호출
- 모달 표시: DashboardDetailModal 컴포넌트를 통해 상세 정보 표시
- 섹션별 정보 구성:
  - 기본 정보: 부서, 종류, 출발 허브, SLA
  - 배송 시간: 접수, 출발, 완료, ETA
  - 배송 담당자: 담당 기사, 연락처
  - 배송 세부사항: 주소, 예상 거리, 예상 소요시간
  - 수령인 정보: 수령인, 연락처
  - 메모: 주문 관련 메모 목록
- 권한별 UI 조정: 관리자/일반 사용자에 따른 기능 버튼 가시성 제어

백엔드 동작
- 요청 수신: /dashboard/{dashboard_id} 엔드포인트에서 GET 요청 수신
- ID 검증: URL 경로에서 dashboard_id 추출 및 유효성 확인
- 데이터 조회:
  - 주문 기본 정보 조회
  - 연관된 메모 정보 함께 조회
- 응답 구성: 주문 상세 정보와 메모 목록을 포함한 응답 반환

2.3 새 주문 생성
프론트엔드 동작
- 생성 모달 표시: "신규 등록" 버튼 클릭 시 CreateDashboardModal 표시
- 폼 데이터 관리:
  - 입력 필드 유효성 검증 (우편번호, 연락처, ETA 등)
  - 현재 시간 이후로만 ETA 설정 가능하도록 제한
- 제출 처리:
  - DashboardService.createDashboard() 호출
  - 로딩 상태 관리 및 버튼 비활성화
- 응답 처리:
  - 성공 시: 성공 메시지 표시 및 모달 닫기, 목록 새로고침
  - 실패 시: 오류 메시지 표시 및 폼 유지

백엔드 동작
- 요청 수신: /dashboard 엔드포인트에서 POST 요청 수신
- 데이터 검증:
  - Pydantic 스키마를 통한 기본 필드 검증
  - 우편번호 형식 검증 (5자리 숫자)
  - 연락처 형식 검증 (xxx-xxxx-xxxx)
  - ETA 미래 시간 검증
- 부가 정보 설정:
  - 현재 사용자의 부서 정보 설정
  - 현재 KST 시간을 create_time으로 설정
  - 초기 status를 'WAITING'으로 설정
  - 초기 version을 1로 설정
- 데이터 저장:
  - dashboard 테이블에 주문 정보 저장
  - 메모 내용이 있는 경우 dashboard_remark 테이블에 저장
- 응답 반환: 생성된 주문의 상세 정보 반환

2.4 주문 상태 변경
프론트엔드 동작
- 상태 변경 UI: 상세 정보 모달에서 "상태 변경" 버튼 클릭 시 상태 선택 UI 표시
- 권한별 옵션 제한:
  - 일반 사용자: 현재 상태에서 허용된 다음 상태만 선택 가능
  - 관리자: 모든 상태로 변경 가능
- 상태 변경 확인: 상태 변경 시 확인 모달 표시 (특히 관리자의 경우)
- 변경 요청: DashboardService.updateStatus() 호출
- 락 충돌 처리:
  - 비관적 락 충돌 시 사용자 알림 및 재시도 옵션 제공
- 시각적 피드백: 상태 변경 성공 시 태그 색상 및 배경색 즉시 업데이트

백엔드 동작
- 요청 수신: /dashboard/{dashboard_id}/status 엔드포인트에서 PATCH 요청 수신
- 비관적 락 획득:
  - dashboard_lock 테이블에 'STATUS' 타입 락 생성 시도
  - 이미 락이 있는 경우 423 Locked 응답 반환
- 권한 및 상태 검증:
  - 관리자 여부 확인 (is_admin 플래그)
  - 일반 사용자의 경우 상태 전이 규칙 검증
  - 배차 정보 유무 확인 (일반 사용자)
- 상태 업데이트:
  - 상태 변경 및 버전 증가
  - 상태에 따른 시간 필드 업데이트:
    - IN_PROGRESS로 변경 시 depart_time 설정
    - COMPLETE/ISSUE로 변경 시 complete_time 설정
    - WAITING/CANCEL로 변경 시 시간 필드 초기화
- 락 해제: 작업 완료 후 락 해제
- 응답 반환: 업데이트된 주문 정보 반환

2.5 주문 정보 편집
프론트엔드 동작
- 편집 모드 진입: 상세 정보 모달에서 "정보 수정" 버튼 클릭
- 편집 폼 표시: 읽기 모드에서 편집 모드로 전환, 현재 값으로 폼 초기화
- 필드 검증:
  - ETA가 현재 시간 이후인지 확인
  - 우편번호 5자리 숫자 형식 검증
  - 연락처 형식 검증
- 저장 요청: DashboardService.updateFields() 호출
- 락 및 버전 관리:
  - 비관적 락 충돌 처리 (423 응답)
  - 낙관적 락 충돌 처리 (409 응답)
- 결과 피드백:
  - 성공 시 읽기 모드로 전환 및 갱신된 데이터 표시
  - 실패 시 오류 메시지 표시 및 편집 모드 유지

백엔드 동작
- 요청 수신: /dashboard/{dashboard_id}/fields 엔드포인트에서 PATCH 요청 수신
- 비관적 락 획득:
  - dashboard_lock 테이블에 'EDIT' 타입 락 생성 시도
  - 이미 락이 있는 경우 423 Locked 응답 반환
- 데이터 검증:
  - 필드별 유효성 검증 (우편번호, 연락처, ETA 등)
  - ETA 미래 시간 검증
- 필드 업데이트:
  - 요청된 필드만 선택적으로 업데이트
  - 버전 필드 증가
- 락 해제: 작업 완료 후 락 해제
- 응답 반환: 업데이트된 주문 정보 반환

2.6 메모 관리
프론트엔드 동작
- 메모 표시: 상세 정보 모달에서 메모 섹션에 기존 메모 표시
- 메모 편집 모드: "메모 수정" 버튼 클릭 시 편집 모드 전환
- 메모 저장: DashboardService.updateRemark() 호출
- 락 충돌 처리: 비관적 락 충돌 시 사용자 알림 제공
- 사용자 식별: 저장된 메모에 작성자 ID 표시 (user_id: 메모 내용)
- 메모 히스토리: 각 메모의 생성 시간 및 작성자 정보 표시

백엔드 동작
- 메모 조회: /dashboard/{dashboard_id}/remarks 엔드포인트에서 GET 요청 처리
- 메모 생성:
  - /dashboard/{dashboard_id}/remarks 엔드포인트에서 POST 요청 처리
  - 비관적 락 'REMARK' 타입 적용
- 메모 포맷팅: "{user_id}: {content}" 형식으로 메모 내용 구성
- 메모 저장:
  - dashboard_remark 테이블에 저장
  - 기존 메모 수정 시 새 레코드 생성 (히스토리 유지)
- 락 해제: 작업 완료 후 락 해제
- 응답 반환: 생성/수정된 메모 정보 반환

2.7 배차 처리
프론트엔드 동작
- 주문 선택: 대시보드 테이블에서 배차할 주문 체크박스 선택
- 권한별 제약:
  - 일반 사용자: 대기(WAITING) 상태 주문만 선택 가능
  - 관리자: 모든 상태의 주문 선택 가능
- 배차 모달 표시: "배차" 버튼 클릭 시 AssignDriverModal 표시
- 배차 정보 입력:
  - 배송 담당자 이름
  - 배송 담당자 연락처 (xxx-xxxx-xxxx 형식)
- 배차 요청: DashboardService.assignDriver() 호출
- 락 충돌 처리: 일부라도 락 충돌 시 전체 작업 취소 및 알림
- 결과 처리:
  - 성공 시 목록 새로고침 및 선택 해제
  - 실패 시 오류 메시지 표시

백엔드 동작
- 요청 수신: /dashboard/assign 엔드포인트에서 POST 요청 수신
- 데이터 검증:
  - 배송 담당자 이름 필수 확인
  - 연락처 형식 검증
- 다중 락 획득:
  - 모든 대상 주문에 대해 'ASSIGN' 타입 락 획득 시도
  - 일부라도 실패 시 이미 획득한 락 모두 해제 후 423 응답
- 배차 정보 업데이트:
  - 모든 주문의 driver_name, driver_contact 업데이트
  - 각 주문의 버전 증가
- 락 해제: 작업 완료 후 모든 락 해제
- 응답 반환: 업데이트된 주문 목록 반환


2.8 주문 삭제 (관리자 전용)
-------------------------------------------------------------
프론트엔드 동작
- 주문 선택: 관리자가 대시보드 테이블에서 삭제할 주문 체크박스 선택
- 삭제 버튼 표시: 관리자 권한일 때만 삭제 버튼을 활성화하거나 노출
- 삭제 확인: 삭제 버튼 클릭 시 "정말 삭제하시겠습니까?" 등 확인 팝업 표시
- 삭제 요청: 사용자가 확인 팝업에서 승인하면, DashboardService.deleteDashboards() 호출
- 결과 처리:
  - 성공 시: 목록에서 해당 항목 제거 및 체크박스 선택 해제
  - 실패 시: 오류 메시지(토스트, 얼럿 등) 표시

백엔드 동작
- 요청 수신: /dashboard 엔드포인트로 DELETE 메서드 요청
- 관리자 권한 검증: 현재 사용자의 역할(role)이 'ADMIN'인지 확인
  - 권한 부족 시 403 Forbidden 응답
- 데이터 삭제:
  - 전달된 dashboard_ids 목록에 해당하는 주문 레코드 삭제
  - 외래 키 제약조건(CASCADE)으로 연관된 메모 및 락 정보 자동 제거
- 응답 반환: 
  - 삭제된 항목 수(deleted_count) 포함
  - {"success": true, "deleted_count": N}

2.9 주문번호 검색
-------------------------------------------------------------
프론트엔드 동작
- 검색 입력: 대시보드 화면에서 주문번호를 입력할 수 있는 검색 필드 제공
- 검색 요청: DashboardService.searchDashboardsByOrderNo(orderNo) 등 API 호출
- 검색 상태 관리:
  - 검색 모드 활성화 (searchMode = true)
  - 기존 날짜 기반 조회와 구분하여, 검색 결과만 따로 관리
- 결과 표시:
  - 검색 결과 목록만 테이블에 표시
  - 결과가 없을 경우 빈 테이블 및 "검색 결과가 없습니다" 안내문 표시
- 검색 초기화:
  - "필터 초기화" 버튼 혹은 검색어 제거 시, 다시 날짜 기반 목록 조회로 복귀

백엔드 동작
- 요청 수신: /dashboard/search 엔드포인트에서 GET 요청
  - 쿼리 파라미터: ?order_no=xxx
- 데이터 검색:
  - DB에서 해당 주문번호와 정확히 일치하는 레코드 조회
  - 상태별 정렬 혹은 필요에 따라 필터링
- 응답 반환:
  - 검색 결과 목록
  - 사용자 권한 정보(접근 제한, 상태 변경 제한 등)
  - {"success": true, "data": [...], ...}

=============================================================
3. 시각화 및 통계 기능
=============================================================
3.1 배송 현황 시각화
-------------------------------------------------------------
프론트엔드 동작
- 차트 타입 선택: "배송 현황" 차트 선택(파이 차트)
- 날짜 범위 지정: DateRangePicker로 통계 기간 설정
- 데이터 요청: VisualizationService.getDeliveryStatus(startDate, endDate)
- 데이터 처리:
  - 부서별(CS, HES, LENOVO 등) 상태별 건수 집계
  - 상태별 비율 계산
- 차트 렌더링:
  - 파이 차트(상태별 비율)
  - 각 상태(대기, 진행, 완료, 이슈, 취소)를 다른 섹터로 표시
- 통계 카드:
  - 상태별 건수 및 비율
  - 부서별 합계

백엔드 동작
- 요청 수신: /visualization/delivery_status (GET)
- 쿼리 파라미터: start_date, end_date
- 데이터 집계:
  - 해당 기간 내의 주문(dashboard) 레코드를 상태별, 부서별로 그룹핑
  - COUNT(*)로 건수 집계
  - 비율 계산 = (상태별 건수 / 전체 건수) × 100
- 응답 구성:
  - {"success": true, "data": {...}} 형태
  - 기간, 상태별 수치, 부서별 분포 정보

3.2 시간대별 접수량 분석
-------------------------------------------------------------
프론트엔드 동작
- 차트 타입 선택: "시간대별 접수량" (막대 그래프)
- 날짜 범위 지정: DateRangePicker로 분석 기간 설정
- 데이터 요청: VisualizationService.getHourlyOrders(startDate, endDate)
- 데이터 가공:
  - 주간(09~19시)과 야간(19~09시) 구분
  - 시간대별로 주문 접수 건수 집계
  - 부서별 스택 or 병합
- 차트 렌더링:
  - x축: 시간(단위: 1시간 또는 야간 통합)
  - y축: 해당 시간대의 주문 건수
  - 시리즈: 부서별 구분(스택 차트)
- 통계 카드:
  - 총 접수량
  - 주간 대비 야간 비중
  - 일평균 접수량

백엔드 동작
- 요청 수신: /visualization/hourly_orders (GET)
- 쿼리 파라미터: start_date, end_date
- 데이터 집계:
  - create_time 기준으로 주문을 시간대별로 분류
  - 09~19시는 1시간 단위
  - 19~09시는 야간으로 통합(또는 필요 시 세분화)
  - 부서별 건수 합산
- 응답 구성:
  - 시간대별/부서별 통계
  - {"success": true, "data": [...], "summary": {...}}

3.3 날짜 범위 정보 조회 (추가)
-------------------------------------------------------------
프론트엔드 동작
- 대시보드/시각화 화면 진입 시 최소/최대 날짜 정보를 미리 조회
- DateRangePicker의 최소/최대 선택 가능 범위를 해당 값으로 설정

백엔드 동작
- 요청 수신: /visualization/date-range (GET)
- 데이터베이스 조회:
  - Dashboard 테이블에서 MIN(create_time), MAX(create_time)
- 캐싱 전략:
  - 캐시 TTL 예: 1시간(3600초)
  - 조회 데이터 없으면 현재일 기준 30일 정도로 기본값 제공
- 응답 예시:
  - {"success": true, "data": {"min_date": "2025-03-01", "max_date": "2025-03-31"}}

=============================================================
4. 락 메커니즘 구현
=============================================================
4.1 비관적 락(Pessimistic Lock)
-------------------------------------------------------------
프론트엔드 동작
- 편집, 배차, 상태 변경, 메모 수정 등 작업 시작 시 LockService.acquireLock() 요청
- 이미 락이 있을 경우 423 Locked 응답 → 사용자 알림 표시
- 작업 완료 후 LockService.releaseLock() 호출
- 작업 실패/취소 시에도 finally 블록에서 releaseLock() 수행

백엔드 동작
- dashboard_lock 테이블에 레코드 삽입(또는 갱신)하여 락 획득
- lock_type, locked_by, locked_at, expires_at 등 기록
- 만료 시간(기본 5분)이 지난 락은 배치 프로세스로 정리
- 락 해제 시 해당 레코드 삭제

4.2 낙관적 락(Optimistic Lock)
-------------------------------------------------------------
프론트엔드 동작
- 데이터 가져올 때 version 필드도 함께 수신
- 수정 요청 시 version 필드를 포함해 전송
- 서버 응답에서 409 Conflict 발생 시 버전 충돌 안내

백엔드 동작
- dashboard.version 필드 비교
- 다르면 충돌(409)
- 충돌 시 서버는 최신 version 반환, 클라이언트가 재시도하도록 안내

=============================================================
5. 보안 및 권한 관리
=============================================================
5.1 사용자 권한 체계
-------------------------------------------------------------
- USER, ADMIN 두 가지 권한(Role) 존재
- 일반 사용자(USER):
  - 제한된 상태 변경(순차적)
  - 배차 가능 범위 제한
  - 주문 삭제 불가
- 관리자(ADMIN):
  - 모든 상태 변경 가능
  - 주문 삭제 권한
  - 전체 부서/모든 주문 관리

5.2 프론트엔드 보안 구현
-------------------------------------------------------------
- PrivateRoute 등 권한 기반 라우팅
- 관리자 전용 메뉴/기능은 role이 ADMIN일 때만 노출
- 액세스 토큰 만료 시 자동 갱신(리프레시 토큰 사용)

5.3 백엔드 보안 구현
-------------------------------------------------------------
- JWT 인증: Authorization 헤더 "Bearer <token>"
- 토큰 만료/무효 시 401 Unauthorized
- 관리자 전용 API 진입 전 role 확인(ADMIN 아니면 403 Forbidden)
- bcrypt로 비밀번호 해시 저장

=============================================================
6. 시스템 구성 요소
=============================================================
6.1 프론트엔드 아키텍처
-------------------------------------------------------------
- React 18, Ant Design 5, Axios, Context API
- components / contexts / pages / services / utils 구조
- 서비스 레이어에서 API 호출, Axios 인터셉터로 토큰 자동 갱신

6.2 백엔드 아키텍처
-------------------------------------------------------------
- FastAPI, SQLAlchemy, Pydantic
- app/api: 라우터
- app/services: 비즈니스 로직
- app/repositories: DB 접근
- app/models: ORM 모델 정의

6.3 데이터베이스 스키마
-------------------------------------------------------------
- user (사용자)
- refresh_token (리프레시 토큰)
- dashboard (주문 정보)
- dashboard_remark (주문 메모)
- dashboard_lock (비관적 락)
- 기타 postal_code, postal_code_detail 등



=============================================================
8. 오류 처리 및 로깅 전략
=============================================================
8.1 프론트엔드 오류 처리
-------------------------------------------------------------
- ErrorBoundary를 활용한 렌더링 오류 포착
- axios 인터셉터로 공통 API 오류 처리
- 사용자 친화적 메시지(토스트, 모달) 사용

8.2 백엔드 오류 처리
-------------------------------------------------------------
- HTTPException 사용해 세분화된 에러 코드 반환
- 400, 401, 403, 404, 409, 423, 500 등 상태 코드
- Pydantic 검증 오류 시 422 Unprocessable Entity
423 Locked (비관적 락 충돌)
사용자가 편집/배차/메모 수정하려 할 때 이미 다른 사용자가 락 보유 시 발생
프론트는 "현재 {locked_by} 님이 편집 중입니다. 잠시 후 다시 시도하세요." 같은 안내를 사용자에게 표시
409 Conflict (낙관적 락 충돌)
version 불일치로 동시 수정 충돌 시 발생
메시지 예: "데이터 충돌이 발생했습니다. 최신 상태를 확인한 뒤 다시 저장해주세요."
401 Unauthorized
토큰 만료 또는 없는 경우 → 자동 리프레시 시도 후 실패 시 로그인 페이지로 이동
메시지 예: "세션이 만료되었습니다. 다시 로그인해 주세요."
403 Forbidden
관리자 권한이 필요한 요청을 일반 사용자가 수행할 경우
메시지 예: "권한이 없어 요청을 수행할 수 없습니다."
기타
500 서버 오류: "서버에서 오류가 발생했습니다. 잠시 후 다시 시도해주세요."
400/404 등: "요청이 유효하지 않거나 리소스를 찾을 수 없습니다."

=============================================================
10. 사용자 인터페이스 설계
=============================================================
10.1 디자인 시스템
-------------------------------------------------------------
- Ant Design 기반 + 커스텀 테마
- 공통 컴포넌트(헤더, 사이드바, 버튼) 재사용
- 상태별 색상 체계

10.2 사용자 경험 최적화
-------------------------------------------------------------
- 로딩 상태(스켈레톤, 스피너) 시각적 제공
- 키보드 네비게이션/단축키
- 접근성(ARIA 속성, 명도 대비)

10.3 특화된 UI 요소
-------------------------------------------------------------
- 대시보드 테이블: 상태별 행 색상, 인라인 배차 버튼
- 모달 다이얼로그: 주문 상세/수정/메모
- 시각화 컴포넌트: 파이 차트, 막대 차트, 통계 카드

=============================================================
결론
=============================================================
위 내용은 "배송 실시간 관제 시스템"의 요구사항 및 상세 동작 방식에 대한
종합적인 명세서입니다. 프론트엔드와 백엔드 양 측면의 주요 기능, API 구조,
데이터 처리, 권한 관리, 락 메커니즘, 시각화 및 성능 최적화 방법론 등을
포괄적으로 설명하였습니다.

이 명세서를 토대로 실제 개발을 진행하면, 일관된 아키텍처와 코드 품질을
유지하면서 프로젝트 요구사항에 부합하는 기능을 구현할 수 있습니다.
향후 확장과 유지보수 시에도 본 문서를 기준으로 작업 내용을 조정, 개선해
나가는 것이 바람직합니다.

=============================================================
(문서 끝)
=============================================================

