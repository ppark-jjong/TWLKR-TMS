# 배송 실시간 관제 시스템 백엔드 명세서

## 1. 시스템 개요

이 문서는 배송 실시간 관제 시스템의 백엔드 API에 대한 상세 명세와 프로세스 요구사항을 제공합니다. 이 시스템은 기업 내부에서 사용할 배송 주문 관리, 배차 처리, 상태 관리 및 데이터 시각화 기능을 제공합니다.

### 1.1. 핵심 기능

- **실시간 배송 주문 관리**: ETA(도착 예정 시간) 기준으로 주문 조회 및 상태 관리
- **효율적인 배차 관리**: 배송 담당자 할당 및 상태 변경
- **데이터 시각화**: 배송 현황 및 시간대별 주문량 분석
- **권한 관리**: 일반 사용자와 관리자 권한 구분
- **동시성 제어**: 비관적 락(Pessimistic Lock)을 통한 데이터 무결성 보장

### 1.2. 기술 스택

- **프레임워크**: FastAPI 0.95.x 이상 (Python)
- **ORM**: SQLAlchemy 2.0.x
- **인증**: JWT 기반 인증
- **데이터베이스**: MySQL 8.0

## 2. 아키텍처 및 데이터 흐름

### 2.1. 레이어 구조

시스템은 다음과 같은 계층 구조로 설계되어 있습니다:

1. **API 라우터 레이어**: 요청/응답 처리, 엔드포인트 정의
2. **서비스 레이어**: 비즈니스 로직 구현, 트랜잭션 관리
3. **레포지토리 레이어**: 데이터 접근 로직, 쿼리 실행
4. **모델/스키마 레이어**:
   - 모델: 데이터베이스 테이블 구조 정의
   - 스키마: 요청/응답 데이터 검증 및 직렬화

### 2.2. 데이터 흐름

1. 클라이언트 요청 → API 엔드포인트(라우터)
2. 라우터 → 서비스 레이어 메서드 호출
3. 서비스 레이어 → 레포지토리 레이어 메서드 호출
4. 레포지토리 레이어 → 데이터베이스 상호작용
5. 응답은 역순으로 전달: 데이터베이스 → 레포지토리 → 서비스 → API → 클라이언트

### 2.3. 동시성 제어 메커니즘

시스템은 비관적 락(Pessimistic Lock)을 사용하여 동시성 문제를 해결합니다:

1. **락 획득 프로세스**:
   - 리소스(대시보드, 메모 등) 수정 시 락 획득 시도
   - 락 획득은 두 단계로 진행:
     1. 애플리케이션 레벨 락: `dashboard_lock` 테이블에 레코드 생성
     2. 데이터베이스 레벨 락: `SELECT ... FOR UPDATE NOWAIT` 구문으로 로우 락 획득
   - 다른 사용자가 이미 락을 보유 중인 경우 HTTP 423 (Locked) 응답 반환

2. **락 해제 프로세스**:
   - 작업 완료 시 자동 해제 (서비스 레이어의 `finally` 블록에서 처리)
   - 타임아웃(기본 300초) 이후 자동 해제
   - 클라이언트에서 명시적 해제 요청 가능

3. **락 타입**:
   - EDIT: 대시보드 필드 수정
   - STATUS: 상태 변경
   - ASSIGN: 배차 처리
   - REMARK: 메모 수정

## 3. API 명세

### 3.1. 인증 API

#### 3.1.1. 로그인 (POST /auth/login)

**요청 형식**:
```json
{
  "user_id": "사용자ID",
  "password": "비밀번호"
}
```

**응답 형식**:
```json
{
  "token": {
    "access_token": "JWT_액세스_토큰_문자열",
    "refresh_token": "JWT_리프레시_토큰_문자열"
  },
  "user": {
    "user_id": "사용자ID",
    "user_department": "부서명(CS/HES/LENOVO)",
    "user_role": "권한(ADMIN/USER)"
  }
}
```

**서비스 로직**:
- 사용자 ID로 사용자 정보 조회
- 비밀번호 검증 (bcrypt 해시 비교)
- 검증 성공 시 JWT 토큰 2종 발급 (access_token, refresh_token)
- 리프레시 토큰은 DB에 저장하여 추후 갱신 시 검증

#### 3.1.2. 세션 체크 (GET /auth/check-session)

**요청 헤더**:
```
Authorization: Bearer {JWT_액세스_토큰}
```

**응답 형식**:
```json
{
  "success": true,
  "user": {
    "user_id": "사용자ID",
    "user_department": "부서명",
    "user_role": "권한"
  }
}
```

**서비스 로직**:
- 헤더에서 JWT 토큰 추출 및 검증
- 토큰 만료 여부 확인
- 유효한 경우 사용자 정보 반환

#### 3.1.3. 토큰 갱신 (POST /auth/refresh)

**요청 형식**:
```json
{
  "refresh_token": "JWT_리프레시_토큰_문자열"
}
```

**응답 형식**:
```json
{
  "success": true,
  "message": "토큰이 갱신되었습니다",
  "token": {
    "access_token": "신규_JWT_액세스_토큰",
    "refresh_token": "신규_JWT_리프레시_토큰"
  }
}
```

**서비스 로직**:
- 리프레시 토큰의 유효성 검증 (DB에 저장된 값 비교)
- 유효한 경우, 새 액세스 토큰과 리프레시 토큰 생성
- 새 리프레시 토큰으로 DB 갱신

#### 3.1.4. 로그아웃 (POST /auth/logout)

**요청 형식**:
```json
{
  "refresh_token": "JWT_리프레시_토큰_문자열"
}
```

**응답 형식**:
```json
{
  "success": true,
  "message": "로그아웃이 완료되었습니다"
}
```

**서비스 로직**:
- DB에서 리프레시 토큰 삭제
- 로그아웃 성공 여부 반환

### 3.2. 대시보드 API

#### 3.2.1. 대시보드 목록 조회 (GET /dashboard/list)

**요청 파라미터**:
```
date: "YYYY-MM-DD" (단일 날짜)
```
또는
```
start_date: "YYYY-MM-DD"
end_date: "YYYY-MM-DD" (날짜 범위)
```

**응답 형식**:
```json
{
  "success": true,
  "message": "데이터를 조회했습니다",
  "data": {
    "date_range": {
      "oldest_date": "YYYY-MM-DD",
      "latest_date": "YYYY-MM-DD"
    },
    "items": [
      {
        "dashboard_id": 1,
        "order_no": "ORDER-12345",
        "type": "DELIVERY",
        "status": "WAITING",
        "department": "CS",
        "warehouse": "SEOUL",
        "sla": "당일배송",
        "eta": "2023-01-01T14:00:00+09:00",
        "create_time": "2023-01-01T09:00:00+09:00",
        "depart_time": null,
        "driver_name": null,
        "customer": "고객명",
        "region": "서울 강남구 역삼동",
        "version": 1
      }
      // ... 더 많은 항목들
    ],
    "user_role": "ADMIN",
    "is_admin": true
  }
}
```

**서비스 로직**:
- 날짜 파라미터 검증 및 변환
- ETA 기준으로 해당 날짜 범위의 대시보드 목록 조회
- 상태별 정렬: WAITING → IN_PROGRESS → COMPLETE → ISSUE → CANCEL
- 사용자 권한 정보 포함하여 응답

#### 3.2.2. 대시보드 상세 조회 (GET /dashboard/{dashboard_id})

**요청 파라미터**:
```
dashboard_id: 대시보드 ID (정수)
```

**응답 형식**:
```json
{
  "success": true,
  "message": "상세 정보를 조회했습니다",
  "data": {
    "dashboard_id": 1,
    "order_no": "ORDER-12345",
    "type": "DELIVERY",
    "status": "WAITING",
    "department": "CS",
    "warehouse": "SEOUL",
    "sla": "당일배송",
    "eta": "2023-01-01T14:00:00+09:00",
    "create_time": "2023-01-01T09:00:00+09:00",
    "depart_time": null,
    "complete_time": null,
    "driver_name": null,
    "driver_contact": null,
    "address": "서울시 강남구 역삼동 123-456",
    "postal_code": "12345",
    "distance": 15,
    "duration_time": 30,
    "customer": "고객명",
    "contact": "010-1234-5678",
    "version": 1,
    "city": "서울시",
    "county": "강남구",
    "district": "역삼동",
    "remarks": [
      {
        "remark_id": 1,
        "dashboard_id": 1,
        "content": null,  // 초기에는 null, 업데이트 후 실제 내용
        "created_at": "2023-01-01T09:10:00+09:00",
        "created_by": "사용자ID",
        "formatted_content": null  // 초기에는 null, 업데이트 후 "사용자ID: 내용" 형식
      }
    ],
    "is_locked": false
  },
  "is_locked": false,
  "lock_info": null
}
```

**서비스 로직**:
- 대시보드 ID로 상세 정보 조회
- 연관된 메모 목록 조회 (최신순 정렬)
- 현재 락 상태 확인 및 정보 포함
- 대시보드 상세 정보, 메모 목록, 락 정보 종합하여 반환

#### 3.2.3. 대시보드 생성 (POST /dashboard)

**요청 형식**:
```json
{
  "type": "DELIVERY",
  "warehouse": "SEOUL",
  "order_no": "ORDER-12345",
  "eta": "2023-01-01T14:00:00+09:00",
  "sla": "당일배송",
  "postal_code": "12345",
  "address": "서울시 강남구 역삼동 123-456",
  "customer": "고객명",
  "contact": "010-1234-5678"
}
```

**응답 형식**:
```json
{
  "success": true,
  "message": "대시보드가 생성되었습니다",
  "data": {
    // 대시보드 상세 정보와 동일한 형식
    // remarks 배열에는 초기 빈 메모가 포함됨
  }
}
```

**서비스 로직**:
1. 필드 유효성 검증
2. 대시보드 기본 정보 설정:
   - 현재 사용자의 부서 정보 추가
   - 초기 상태는 "WAITING"으로 설정
   - 현재 시간으로 create_time 설정
3. 우편번호로 지역 정보(city, county, district) 자동 설정
4. 대시보드 생성 후 자동으로 빈 메모(내용 null) 생성
   - 이는 향후 메모 업데이트를 위한 기본 레코드
5. 생성된 대시보드의 상세 정보 반환 (메모 포함)

#### 3.2.4. 대시보드 필드 업데이트 (PATCH /dashboard/{dashboard_id}/fields)

**요청 파라미터**:
```
dashboard_id: 대시보드 ID (정수)
client_version: 클라이언트 버전 (정수, 선택적)
```

**요청 형식**:
```json
{
  "eta": "2023-01-01T15:00:00+09:00",
  "customer": "변경된 고객명",
  "contact": "010-9876-5432",
  "address": "변경된 주소",
  "postal_code": "54321"
}
```

**응답 형식**:
```json
{
  "success": true,
  "message": "필드가 업데이트되었습니다",
  "data": {
    // 업데이트된 대시보드 상세 정보
  }
}
```

**서비스 로직**:
1. 필드 값 유효성 검증 (우편번호, 연락처 등)
2. 비관적 락 획득 시도:
   - 애플리케이션 레벨 락 획득 (dashboard_lock 테이블)
   - 데이터베이스 레벨 락 획득 (SELECT FOR UPDATE NOWAIT)
3. 필드 업데이트 실행
4. 변경사항 커밋
5. 락 해제 (finally 블록에서 처리)
6. 업데이트된 대시보드 정보 반환

#### 3.2.5. 대시보드 상태 업데이트 (PATCH /dashboard/{dashboard_id}/status)

**요청 파라미터**:
```
dashboard_id: 대시보드 ID (정수)
client_version: 클라이언트 버전 (정수, 선택적)
```

**요청 형식**:
```json
{
  "status": "IN_PROGRESS",
  "is_admin": false
}
```

**응답 형식**:
```json
{
  "success": true,
  "message": "IN_PROGRESS 상태로 변경되었습니다",
  "data": {
    // 업데이트된 대시보드 상세 정보
  }
}
```

**서비스 로직**:
1. 상태 값 유효성 검증
2. 비관적 락 획득 시도
3. 상태 전이 규칙 검증 (관리자가 아닌 경우):
   - WAITING → IN_PROGRESS/CANCEL
   - IN_PROGRESS → COMPLETE/ISSUE/CANCEL
   - COMPLETE/ISSUE/CANCEL → (전이 불가)
4. 배차 정보 확인 (상태 변경 시 배차 정보 필요)
5. 시간 자동 업데이트:
   - IN_PROGRESS: depart_time 설정
   - COMPLETE/ISSUE: complete_time 설정
   - WAITING/CANCEL: 시간 정보 초기화
6. 변경사항 커밋 및 락 해제
7. 업데이트된 대시보드 정보 반환

#### 3.2.6. 배차 처리 (POST /dashboard/assign)

**요청 형식**:
```json
{
  "dashboard_ids": [1, 2, 3],
  "driver_name": "배송기사명",
  "driver_contact": "010-1234-5678"
}
```

**응답 형식**:
```json
{
  "success": true,
  "message": "배차가 완료되었습니다",
  "data": {
    "updated_dashboards": [
      // 업데이트된 대시보드 정보 배열
    ]
  }
}
```

**서비스 로직**:
1. 연락처 형식 검증
2. 여러 대시보드에 대한 비관적 락 획득 시도:
   - 애플리케이션 레벨 락 획득 (모든 대시보드)
   - 데이터베이스 레벨 락 획득 (FOR UPDATE)
3. 배차 정보(driver_name, driver_contact) 일괄 업데이트
4. 변경사항 커밋 및 모든 락 해제
5. 업데이트된 대시보드 목록 반환

#### 3.2.7. 대시보드 삭제 (DELETE /dashboard)

**요청 형식**:
```json
{
  "dashboard_ids": [1, 2, 3]
}
```

**응답 형식**:
```json
{
  "success": true,
  "message": "선택한 항목이 삭제되었습니다",
  "data": {
    "deleted_count": 3
  }
}
```

**서비스 로직**:
1. 관리자 권한 검증 (관리자만 삭제 가능)
2. 해당 ID의 대시보드 삭제
   - CASCADE 설정으로 연관된 메모, 락 등도 함께 삭제
3. 삭제된 항목 수 반환

#### 3.2.8. 주문번호로 대시보드 검색 (GET /dashboard/search)

**요청 파라미터**:
```
order_no: 검색할 주문번호 (문자열)
```

**응답 형식**:
```json
{
  "success": true,
  "message": "데이터를 조회했습니다",
  "data": {
    "date_range": {
      "oldest_date": "YYYY-MM-DD",
      "latest_date": "YYYY-MM-DD"
    },
    "items": [
      // 대시보드 목록
    ],
    "user_role": "ADMIN",
    "is_admin": true
  }
}
```

**서비스 로직**:
1. 주문번호 형식 검증
2. 주문번호로 대시보드 검색
3. 조회 가능한 날짜 범위 정보 포함
4. 사용자 권한 정보 추가
5. 검색 결과 및 메타데이터 반환

### 3.3. 대시보드 메모 API

#### 3.3.1. 메모 업데이트 (PATCH /dashboard/{dashboard_id}/remarks/{remark_id})

**요청 파라미터**:
```
dashboard_id: 대시보드 ID (정수)
remark_id: 메모 ID (정수)
dashboard_version: 대시보드 버전 (정수, 선택적)
```

**요청 형식**:
```json
{
  "content": "수정된 메모 내용"
}
```

**응답 형식**:
```json
{
  "remark_id": 1,
  "dashboard_id": 1,
  "content": "수정된 메모 내용",
  "created_at": "2023-01-01T09:15:00+09:00",
  "created_by": "사용자ID",
  "formatted_content": "사용자ID: 수정된 메모 내용"
}
```

**서비스 로직**:
1. 메모 존재 여부 확인
2. 비관적 락 획득 시도 (REMARK 유형)
3. 기존 메모 내용 직접 업데이트
   - content 필드 업데이트
   - formatted_content 필드 자동 구성 (사용자ID: 내용)
4. 락 해제 (finally 블록에서 처리)
5. 업데이트된 메모 정보 반환

#### 3.3.2. 메모 삭제 (DELETE /dashboard/{dashboard_id}/remarks/{remark_id})

**요청 파라미터**:
```
dashboard_id: 대시보드 ID (정수)
remark_id: 메모 ID (정수)
```

**응답 형식**:
```json
{
  "success": true,
  "message": "메모가 삭제되었습니다"
}
```

**서비스 로직**:
1. 메모 존재 여부 확인
2. 권한 검증 (작성자 본인 또는 관리자만 삭제 가능)
3. 비관적 락 획득 시도 (REMARK 유형)
4. 메모 삭제
5. 락 해제
6. 삭제 성공 여부 반환

### 3.4. 대시보드 락 API

#### 3.4.1. 락 획득 (POST /dashboard/{dashboard_id}/lock)

**요청 파라미터**:
```
dashboard_id: 대시보드 ID (정수)
```

**요청 형식**:
```json
{
  "lock_type": "EDIT"  // EDIT, STATUS, ASSIGN, REMARK 중 하나
}
```

**응답 형식**:
```json
{
  "success": true,
  "message": "락이 획득되었습니다",
  "data": {
    "dashboard_id": 1,
    "locked_by": "사용자ID",
    "lock_type": "EDIT"
  }
}
```

**서비스 로직**:
1. 데이터베이스 트랜잭션 락 획득 시도 (FOR UPDATE)
2. 기존 락 정보 확인:
   - 만료된 락인 경우 삭제
   - 현재 사용자의 락인 경우 갱신
   - 다른 사용자의 유효한 락이 있는 경우 충돌 발생
3. 새 락 생성 및 저장 (타임아웃: 300초)
4. 락 정보 반환

#### 3.4.2. 락 해제 (DELETE /dashboard/{dashboard_id}/lock)

**요청 파라미터**:
```
dashboard_id: 대시보드 ID (정수)
```

**응답 형식**:
```json
{
  "success": true,
  "message": "락이 해제되었습니다",
  "data": {
    "dashboard_id": 1
  }
}
```

**서비스 로직**:
1. 본인 소유의 락인지 확인
2. 락 레코드 삭제
3. 삭제 성공 여부 반환

#### 3.4.3. 락 상태 확인 (GET /dashboard/{dashboard_id}/lock/status)

**요청 파라미터**:
```
dashboard_id: 대시보드 ID (정수)
```

**응답 형식**:
```json
{
  "success": true,
  "message": "락 정보를 조회했습니다",
  "data": {
    "dashboard_id": 1,
    "is_locked": true,
    "locked_by": "사용자ID",
    "lock_type": "EDIT",
    "expires_at": "2023-01-01T09:15:00+09:00"
  }
}
```

**서비스 로직**:
1. 락 정보 조회
2. 락이 없는 경우 is_locked=false 반환
3. 락이 있는 경우 상세 정보 포함하여 반환

### 3.5. 시각화 API

#### 3.5.1. 배송 현황 데이터 조회 (GET /visualization/delivery_status)

**요청 파라미터**:
```
start_date: "YYYY-MM-DD"
end_date: "YYYY-MM-DD"
```

**응답 형식**:
```json
{
  "success": true,
  "message": "데이터를 조회했습니다",
  "data": {
    "type": "delivery_status",
    "total_count": 100,
    "department_breakdown": {
      "CS": {
        "total": 40,
        "status_breakdown": [
          {"status": "WAITING", "count": 10, "percentage": 25.0},
          {"status": "IN_PROGRESS", "count": 15, "percentage": 37.5},
          {"status": "COMPLETE", "count": 10, "percentage": 25.0},
          {"status": "ISSUE", "count": 3, "percentage": 7.5},
          {"status": "CANCEL", "count": 2, "percentage": 5.0}
        ]
      },
      "HES": {
        // 동일한 구조로 부서별 정보
      },
      "LENOVO": {
        // 동일한 구조로 부서별 정보
      }
    }
  },
  "date_range": {
    "oldest_date": "2023-01-01",
    "latest_date": "2023-01-31"
  }
}
```

**서비스 로직**:
1. 날짜 파라미터 검증 및 변환
2. create_time 기준으로 해당 날짜 범위의 데이터 조회
3. 시간대 분류 (주간: 09-19시 1시간 단위, 야간: 19-09시 통합)
4. pandas DataFrame을 활용해 부서별/시간대별 데이터 분석
5. 일평균 계산, 시간대별 접수 현황 및 통계 포함하여 응답

#### 3.5.3. 조회 가능한 날짜 범위 조회 (GET /visualization/date_range)

**요청 파라미터**: 없음

**응답 형식**:
```json
{
  "success": true,
  "message": "조회 가능 날짜 범위를 조회했습니다",
  "date_range": {
    "oldest_date": "2023-01-01",
    "latest_date": "2023-01-31"
  }
}
```

**서비스 로직**:
1. 데이터베이스에서 create_time 컬럼의 최소/최대 값 조회
2. 날짜 범위 정보 반환 (캐싱 적용)

## 4. 프로세스 요구사항

### 4.1. 메모 관리 프로세스

#### 4.1.1. 메모 자동 생성 과정
1. 대시보드 생성 API 호출 시 대시보드 정보 저장
2. 대시보드 저장 성공 후 자동으로 빈 메모 레코드 생성
   - content, formatted_content 필드는 null로 설정
   - created_by 필드에는 대시보드 생성자 ID 저장
3. 대시보드 상세 조회 시 메모 목록에 빈 메모 포함

#### 4.1.2. 메모 편집 프로세스
1. 메모 편집 시작: 
   - 프론트엔드에서 락 획득 API 호출 (`POST /dashboard/{dashboard_id}/lock`, lock_type="REMARK")
   - 락 획득 성공 시 편집 모드 활성화, 실패 시 에러 메시지 표시
2. 메모 내용 수정:
   - 사용자가 메모 내용 입력
   - 저장 버튼 클릭 시 메모 업데이트 API 호출
3. 메모 저장:
   - 백엔드에서 내부적으로 락 확인 후 메모 내용 업데이트
   - 업데이트 완료 후 자동으로 락 해제
4. 편집 취소:
   - 취소 버튼 클릭 또는 페이지 이탈 시 락 해제 API 호출

#### 4.1.3. 락 관리 메커니즘
1. 락 타임아웃: 
   - 기본값 300초(5분)
   - 만료된 락은 자동으로 해제됨
2. 락 해제 시점:
   - 메모 업데이트/삭제 작업 완료 시 서버에서 자동 해제
   - 사용자 취소 액션 시 명시적 락 해제 API 호출 필요
   - 페이지 이탈, 브라우저 종료 시 프론트엔드에서 락 해제 API 호출
3. 비정상 종료 처리:
   - 락 타임아웃으로 인한 자동 정리
   - 서버 측 주기적 만료 락 정리 (10분마다)

### 4.2. 배송 상태 관리 프로세스

#### 4.2.1. 배송 상태 흐름
```
WAITING → IN_PROGRESS → COMPLETE/ISSUE
     ↓           ↓
   CANCEL      CANCEL
```

#### 4.2.2. 상태별 자동 시간 관리
1. WAITING → IN_PROGRESS 변경 시:
   - depart_time 자동 설정 (현재 시간)
   - complete_time null로 설정
2. IN_PROGRESS → COMPLETE/ISSUE 변경 시:
   - complete_time 자동 설정 (현재 시간)
3. 상태가 CANCEL로 변경 시:
   - depart_time, complete_time null로 초기화

#### 4.2.3. 권한별 상태 변경 제약
1. 일반 사용자:
   - 배차 정보(driver_name, driver_contact)가 있어야 상태 변경 가능
   - 정해진 상태 전이 규칙만 따라 변경 가능
2. 관리자:
   - 모든 상태로 자유롭게 변경 가능
   - 배차 정보 없이도 상태 변경 가능

### 4.3. 배차 처리 프로세스

#### 4.3.1. 단일/다중 배차
1. 단일 대시보드 배차:
   - 대시보드 필드 업데이트 API를 통해 driver_name, driver_contact 설정
2. 다중 대시보드 배차:
   - 배차 API를 통해 여러 대시보드에 동일한 배차 정보 일괄 설정
   - 다중 락 획득 메커니즘 활용

#### 4.3.2. 배차 처리 시 비관적 락
1. 대시보드별 개별 락 획득 시도
2. 하나라도 락 획득 실패 시 전체 작업 취소
3. 배차 처리 후 모든 락 해제

### 4.4. 동시성 제어 세부 프로세스

#### 4.4.1. 비관적 락 구현 상세
1. 두 단계 락 획득:
   - 1단계: dashboard_lock 테이블에 레코드 생성 (애플리케이션 레벨)
   - 2단계: SELECT FOR UPDATE NOWAIT로 로우 락 (DB 레벨)
2. 락 충돌 시 응답:
   - HTTP 423 Locked 상태 코드
   - 상세 정보: locked_by(소유자), lock_type(락 유형)

#### 4.4.2. 트랜잭션 관리
1. 서비스 레이어에서 트랜잭션 경계 관리
2. 작업 성공 시 명시적 커밋
3. 예외 발생 시 자동 롤백
4. 락 해제는 성공/실패 여부와 관계없이 항상 수행

### 4.5. 프론트엔드 연동 가이드라인

#### 4.5.1. 락 관리 클라이언트 측 구현
1. 편집 시작 시 락 획득 요청
2. 423 응답 처리:
   - "다른 사용자가 수정 중입니다" 메시지 표시
   - locked_by 정보 활용하여 "사용자 {locked_by}가 편집 중입니다" 형태로 안내
3. 명시적 락 해제 시점:
   - 편집 취소 버튼 클릭 시
   - 페이지 이탈 시 (useEffect cleanup)
   - 브라우저 종료 전 (beforeunload 이벤트)

#### 4.5.2. 대시보드 상세 페이지 구성
1. 대시보드 정보 영역:
   - 주문 정보, 배송 정보 표시
   - 상태 변경 버튼, 필드 편집 버튼
2. 메모 영역:
   - 메모 내용 표시 (content가 null이면 "메모 없음" 표시)
   - 편집 버튼, 저장 버튼, 취소 버튼

## 5. 데이터 모델 간략 설명

### 5.1. 주요 테이블 구조

#### 5.1.1. Dashboard 테이블
- 주문 및 배송 정보 저장
- 상태 관리 (WAITING, IN_PROGRESS, COMPLETE, ISSUE, CANCEL)
- 시간 추적 (create_time, depart_time, complete_time)
- 지역 정보 (city, county, district, postal_code)

#### 5.1.2. DashboardRemark 테이블
- 대시보드별 메모 관리
- dashboard_id로 대시보드와 연결
- created_by로 작성자 추적
- content 필드는 NULL 허용 (빈 메모)

#### 5.1.3. DashboardLock 테이블
- 락 정보 관리
- locked_by: 락 소유자 ID
- lock_type: 락 유형 (EDIT, STATUS, ASSIGN, REMARK)
- expires_at: 락 만료 시간

### 5.2. 인증 관련 테이블

#### 5.2.1. User 테이블
- 사용자 정보 및 인증 정보 관리
- 부서, 권한 정보 포함

#### 5.2.2. RefreshToken 테이블
- 리프레시 토큰 관리
- 만료 시간 추적

## 6. 배포 및 운영 고려사항

### 6.1. 환경 설정
- 로컬 개발: Docker 컨테이너로 실행
- 운영 환경: Google App Engine 배포

### 6.2. 성능 최적화
- 대시보드 목록 조회 쿼리 최적화 (인덱싱)
- 시각화 데이터 캐싱 적용 (1시간 TTL)
- 락 만료 처리 자동화

### 6.3. 보안
- JWT 기반 인증 적용
- 관리자 전용 API 접근 제한
- 메모 삭제 권한 검증

## 7. 결론

이 백엔드 명세서는 배송 실시간 관제 시스템의 API 및 프로세스 요구사항을 상세히 설명합니다. 프론트엔드 개발자는 이 문서를 참고하여 각 API 엔드포인트를 호출하고 응답을 처리할 수 있습니다. 특히 비관적 락을 활용한 동시성 제어와 메모 관리 기능이 중요한 부분으로, 클라이언트 측에서 적절한 락 관리 구현이 필요합니다.날짜 범위 데이터 조회
3. pandas DataFrame으로 변환하여 데이터 분석
4. 부서별/상태별 주문 수 계산 및 백분율 산출
5. 조회 가능한 날짜 범위 정보 포함하여 응답

#### 3.5.2. 시간대별 접수량 데이터 조회 (GET /visualization/hourly_orders)

**요청 파라미터**:
```
start_date: "YYYY-MM-DD"
end_date: "YYYY-MM-DD"
```

**응답 형식**:
```json
{
  "success": true,
  "message": "데이터를 조회했습니다",
  "data": {
    "type": "hourly_orders",
    "total_count": 100,
    "average_count": 33.3,
    "department_breakdown": {
      "CS": {
        "total": 40,
        "hourly_counts": {
          "09-10": 5,
          "10-11": 8,
          "11-12": 6,
          // ... 다른 시간대
          "18-19": 3,
          "야간(19-09)": 2
        }
      },
      "HES": {
        // 동일한 구조로 부서별 정보
      },
      "LENOVO": {
        // 동일한 구조로 부서별 정보
      }
    },
    "time_slots": [
      {"label": "09-10", "start": 9, "end": 10},
      {"label": "10-11", "start": 10, "end": 11},
      // ... 다른 시간대
      {"label": "18-19", "start": 18, "end": 19},
      {"label": "야간(19-09)", "start": 19, "end": 9}
    ]
  },
  "date_range": {
    "oldest_date": "2023-01-01",
    "latest_date": "2023-01-31"
  }
}
```

**서비스 로직**:
1. 날짜 파라미터 검증 및 변환
2. create_time 기준으로 해당