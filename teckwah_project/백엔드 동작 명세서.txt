백엔드 동작 명세서 (텍스트 파일 예시)
text
복사
편집
# 배송 실시간 관제 시스템 명세서

## I. 루트 명세서 (원본 유지)

현재 배송 실시간 관제 시스템의 핵심 구현 지침서는 프로젝트의 전체적인 목표, 아키텍처 원칙, 폴더 구조 및 핵심 기능에 대한 전반적인 설명을 담고 있으며 수정 없이 그대로 사용합니다.

---

## II. 백엔드 동작 명세서

### 1. 아키텍처 기본 원칙

#### 1.1 계층 구조

- **API 라우터 계층**: HTTP 요청 수신 및 응답 반환, 의존성 주입 관리
  - 주요 파일: auth_router.py, dashboard_router.py, visualization_router.py, dashboard_lock_router.py, download_router.py
  - 역할: 엔드포인트 정의, 요청 검증, 서비스 호출, 응답 구성

- **서비스 계층**: 핵심 비즈니스 로직 구현, 트랜잭션 관리
  - 주요 파일: auth_service.py, dashboard_service.py, visualization_service.py, download_service.py
  - 역할: 다중 레포지토리 조합, 복잡한 비즈니스 룰 적용, 트랜잭션 일관성 유지

- **레포지토리 계층**: 데이터 접근 로직 구현
  - 주요 파일: auth_repository.py, dashboard_repository.py, lock_repository.py, visualization_repository.py
  - 역할: SQL 쿼리 실행, DB 모델 조작, 기본 CRUD 작업 수행

- **모델/스키마 계층**: 데이터 구조 정의 및 유효성 검증
  - 주요 파일: dashboard_model.py, user_model.py, auth_schema.py, dashboard_schema.py
  - 역할: DB 테이블 구조 정의, API 요청/응답 스키마 정의

#### 1.2 설계 원칙

- **백엔드 검증 최소화**: 필수적인 보안 및 정합성 검증만 수행
- **명시적 액션 기반**: 모든 데이터 변경은 명시적 API 호출에 의해서만 발생
- **단순성 우선**: 복잡한 추상화 지양, 직관적 구현 추구
- **비관적 락 중심**: 동시성 제어는 명시적 락 획득/해제로 관리
- **트랜잭션 단위 최소화**: 서비스 작업 단위로 트랜잭션 관리

### 2. API 엔드포인트 및 데이터 흐름

#### 2.1 인증 관련 API

- **POST /auth/login**
  - 기능: 사용자 인증 및 토큰 발급
  - 요청: user_id, password
  - 응답: access_token, refresh_token, user 정보
  - 처리 흐름: 사용자 존재 확인 → 비밀번호 검증 → 토큰 생성 → 리프레시 토큰 저장 → 응답 반환

- **POST /auth/refresh**
  - 기능: 리프레시 토큰으로 액세스 토큰 갱신
  - 요청: refresh_token
  - 응답: 새 access_token, 새 refresh_token
  - 처리 흐름: 리프레시 토큰 유효성 검증 → 사용자 조회 → 새 토큰 발급 → 리프레시 토큰 갱신 → 응답 반환

- **POST /auth/logout**
  - 기능: 로그아웃 처리 (리프레시 토큰 무효화)
  - 요청: refresh_token
  - 응답: 성공 여부
  - 처리 흐름: 리프레시 토큰 삭제 → 응답 반환

- **GET /auth/check-session**
  - 기능: 세션 유효성 확인
  - 요청: Authorization 헤더 (Bearer token)
  - 응답: 인증 상태, 사용자 정보
  - 처리 흐름: 토큰 유효성 검증 → 만료 시간 확인 → 응답 반환

#### 2.2 대시보드 관련 API

- **POST /dashboard/list**
  - 기능: ETA 기준 날짜 범위 내 대시보드 목록 조회
  - 요청: start_date, end_date
  - 응답: 대시보드 항목 목록, 날짜 범위 정보
  - 처리 흐름: 날짜 검증 → 데이터 조회 → 결과 반환

- **GET /dashboard/{dashboard_id}**
  - 기능: 대시보드 상세 정보 조회 (메모, 락 상태 포함)
  - 요청: dashboard_id 경로 파라미터
  - 응답: 대시보드 상세 정보, 메모 목록, 락 상태
  - 처리 흐름: ID 검증 → 데이터 조회 → 메모 조회 → 락 상태 확인 → 결과 반환

- **POST /dashboard**
  - 기능: 새 대시보드 생성
  - 요청: 대시보드 기본 정보
  - 응답: 생성된 대시보드 정보
  - 처리 흐름: 데이터 검증 → 우편번호 확인 → 대시보드 생성 → 초기 메모 생성 → 결과 반환

- **PATCH /dashboard/{dashboard_id}/fields**
  - 기능: 대시보드 필드 업데이트
  - 요청: 변경할 필드 정보
  - 응답: 업데이트된 대시보드 정보
  - 처리 흐름: 락 획득 → 데이터 검증 → 필드 업데이트 → 락 해제 → 결과 반환

- **PATCH /dashboard/{dashboard_id}/status**
  - 기능: 대시보드 상태 변경
  - 요청: 새 상태, 관리자 여부
  - 응답: 업데이트된 대시보드 정보
  - 처리 흐름: 락 획득 → 상태 전이 검증 → 상태 변경 및 시간 자동 갱신 → 락 해제 → 결과 반환

- **POST /dashboard/assign**
  - 기능: 여러 대시보드에 기사 정보 할당
  - 요청: 대시보드 ID 목록, 기사명, 연락처
  - 응답: 처리 결과, 업데이트된 건수
  - 처리 흐름: 다중 락 획득 → 배차 처리 → 락 해제 → 결과 반환

- **GET /dashboard/search**
  - 기능: 주문번호로 대시보드 검색
  - 요청: order_no 쿼리 파라미터
  - 응답: 검색 결과 목록
  - 처리 흐름: 주문번호 검증 → 검색 수행 → 결과 반환

- **PATCH /dashboard/{dashboard_id}/remarks/{remark_id}**
  - 기능: 메모 업데이트
  - 요청: 새 메모 내용
  - 응답: 업데이트된 메모 정보
  - 처리 흐름: 락 획득 → 메모 소유권 확인 → 메모 업데이트 → 락 해제 → 결과 반환

- **DELETE /dashboard**
  - 기능: 대시보드 삭제 (관리자 전용)
  - 요청: dashboard_ids 배열
  - 응답: 삭제된 항목 수
  - 처리 흐름: 관리자 권한 확인 → 삭제 처리 → 결과 반환

#### 2.3 락 관련 API

- **POST /dashboard/{dashboard_id}/lock**
  - 기능: 대시보드에 비관적 락 획득
  - 요청: lock_type (EDIT, STATUS, ASSIGN, REMARK)
  - 응답: 락 정보
  - 처리 흐름: 기존 락 확인 → 충돌 검사 → 락 생성/갱신 → 결과 반환

- **DELETE /dashboard/{dashboard_id}/lock**
  - 기능: 획득한 락 해제
  - 요청: dashboard_id 경로 파라미터
  - 응답: 처리 결과
  - 처리 흐름: 락 존재 확인 → 소유권 확인 → 락 삭제 → 결과 반환

- **GET /dashboard/{dashboard_id}/lock/status**
  - 기능: 대시보드 락 상태 확인
  - 요청: dashboard_id 경로 파라미터
  - 응답: 락 상태 정보
  - 처리 흐름: 락 조회 → 만료 확인 → 결과 반환

#### 2.4 시각화 관련 API

- **POST /visualization/delivery_status**
  - 기능: 배송 현황 데이터 조회
  - 요청: 조회 날짜 범위
  - 응답: 부서별, 상태별 통계 데이터
  - 처리 흐름: 날짜 검증 → 원시 데이터 조회 → 통계 데이터 집계 → 결과 반환

- **POST /visualization/hourly_orders**
  - 기능: 시간대별 접수량 데이터 조회
  - 요청: 조회 날짜 범위
  - 응답: 부서별, 시간대별 접수량 데이터
  - 처리 흐름: 날짜 검증 → 원시 데이터 조회 → 시간대별 집계 → 결과 반환

- **GET /visualization/date_range**
  - 기능: 시각화 가능 날짜 범위 조회
  - 요청: 없음
  - 응답: 가장 오래된 날짜, 가장 최근 날짜
  - 처리 흐름: DB 조회 → 날짜 범위 계산 → 결과 반환

#### 2.5 다운로드 관련 API

- **POST /download/excel**
  - 기능: 대시보드 데이터 엑셀 다운로드
  - 요청: 조회 날짜 범위
  - 응답: 엑셀 파일 스트림
  - 처리 흐름: 권한 확인 → 날짜 검증 → 데이터 조회 → 엑셀 생성 → 파일 반환

- **GET /download/date-range**
  - 기능: 다운로드 가능 날짜 범위 조회
  - 요청: 없음
  - 응답: 가장 오래된 날짜, 가장 최근 날짜
  - 처리 흐름: DB 조회 → 날짜 범위 계산 → 결과 반환

### 3. 서비스 계층 동작

#### 3.1 인증 서비스 (AuthService)

- **authenticate_user**: 사용자 인증 및 토큰 발급
  - 과정: 사용자 조회 → 비밀번호 검증 → 토큰 생성 → 리프레시 토큰 저장
  
- **refresh_token**: 토큰 갱신
  - 과정: 리프레시 토큰 검증 → 사용자 조회 → 새 토큰 생성 → 리프레시 토큰 갱신
  
- **logout**: 로그아웃 처리
  - 과정: 리프레시 토큰 삭제

#### 3.2 대시보드 서비스 (DashboardService)

- **get_dashboard_list_by_date**: ETA 기준 날짜 범위 내 대시보드 조회
  - 과정: 레포지토리 호출 → 데이터 포맷팅
  
- **get_dashboard_with_status_check**: 대시보드 상세 조회 (락 포함)
  - 과정: 대시보드 조회 → 메모 조회 → 락 상태 확인 → 결과 통합
  
- **create_dashboard**: 대시보드 생성
  - 과정: 우편번호 검증 → 대시보드 생성 → 초기 메모 생성 → 결과 반환
  
- **update_dashboard_fields**: 대시보드 필드 업데이트
  - 과정: 락 획득 → 필드 검증 → 필드 업데이트 → 락 해제 → 결과 반환
  
- **update_status**: 대시보드 상태 업데이트
  - 과정: 락 획득 → 상태 전이 검증 → 상태 변경 → 자동 시간 갱신 → 락 해제 → 결과 반환
  
- **assign_driver**: 배차 처리
  - 과정: 다중 락 획득 → 배차 정보 업데이트 → 락 해제 → 결과 반환
  
- **update_remark**: 메모 업데이트
  - 과정: 락 획득 → 소유권 확인 → 메모 업데이트 → 락 해제 → 결과 반환
  
- **delete_dashboards**: 대시보드 삭제 (관리자 전용)
  - 과정: 관리자 확인 → 대시보드 삭제 → 결과 반환

#### 3.3 Lock Manager (LockManager)

- **acquire_lock**: 락 획득
  - 과정: 기존 락 확인 → 충돌 검사 → 락 생성 → 결과 반환
  
- **release_lock**: 락 해제
  - 과정: 락 조회 → 소유권 확인 → 락 삭제
  
- **acquire_multiple_locks**: 다중 락 획득
  - 과정: 각 ID별 락 획득 → 전체 성공 또는 전체 롤백
  
- **get_lock_status**: 락 상태 확인
  - 과정: 락 조회 → 만료 확인 → 상태 반환

#### 3.4 시각화 서비스 (VisualizationService)

- **get_delivery_status**: 배송 현황 데이터 조회
  - 과정: 원시 데이터 조회 → DataFrame 변환 → 부서별, 상태별 집계 → 결과 구성
  
- **get_hourly_orders**: 시간대별 접수량 데이터 조회
  - 과정: 원시 데이터 조회 → DataFrame 변환 → 시간대별 집계 → 결과 구성

#### 3.5 다운로드 서비스 (DownloadService)

- **get_dashboard_data_for_download**: 다운로드용 데이터 조회
  - 과정: 데이터 조회 → 엑셀 파일 생성 → 결과 반환
  
- **_generate_dashboard_xlsx**: 엑셀 파일 생성
  - 과정: 워크북 생성 → 헤더 설정 → 데이터 추가 → 스타일 적용 → 파일 저장

### 4. 보안 및 인증 매커니즘

#### 4.1 JWT 기반 인증

- **액세스 토큰**: 60분 유효, 요청 인증용
- **리프레시 토큰**: 7일 유효, 액세스 토큰 갱신용
- **토큰 저장**: 리프레시 토큰은 DB에 저장, 액세스 토큰은 클라이언트만 보유
- **암호화**: JWT 서명에 HS256 알고리즘 사용

#### 4.2 보안 고려사항

- **비밀번호 처리**: bcrypt 해싱 적용, 평문 저장 없음
- **토큰 만료 처리**: 명시적인 만료 시간 검증
- **CORS 설정**: 개발 환경은 모든 오리진 허용, 프로덕션은 제한 필요
- **인가**: 관리자 전용 API에 권한 검사 적용

### 5. 오류 처리 및 로깅

#### 5.1 일관된 오류 응답 구조

- **공통 형식**:
  - success: 성공 여부 (boolean)
  - message: 사용자 친화적 메시지
  - error_code: 오류 유형 식별자 (선택적)

#### 5.2 주요 오류 유형

- **ValidationException**: 데이터 유효성 검증 실패
- **NotFoundException**: 요청한 자원을 찾을 수 없음
- **PessimisticLockException**: 락 충돌 또는 획득 실패
- **UnauthorizedException**: 인증 실패
- **InvalidStatusTransitionException**: 허용되지 않는 상태 전이 시도
- **DashboardStatusLockedException**: 수정 불가 상태의 대시보드 수정 시도

#### 5.3 로깅 전략

- **구조화된 로깅**: JSON 형식, 추적 가능한 컨텍스트 포함
- **로그 수준**: INFO(정상 작업), ERROR(오류), WARNING(주의 필요), DEBUG(개발용)
- **로그 내용**: 타임스탬프, 요청 ID, 메시지, 컨텍스트 데이터
- **요청 로깅**: 중요 API 호출만 로깅 (인증 관련, 오류 발생, 긴 처리 시간)

### 6. 데이터베이스 접근 및 트랜잭션

#### 6.1 레포지토리 패턴

- **단일 책임**: 각 레포지토리는 특정 도메인 엔티티에 집중
- **추상화 최소화**: 직접적인 쿼리 작성, 과도한 인터페이스 없음
- **응집도 유지**: 비즈니스 로직은 서비스 계층으로 분리

#### 6.2 트랜잭션 관리

- **서비스 단위 트랜잭션**: @transactional 데코레이터 활용
- **명시적 커밋/롤백**: 예외 발생 시 자동 롤백
- **컨텍스트 관리자**: with transaction(db) 패턴 적용

#### 6.3 비관적 락 구현

- **락 타임아웃**: 기본 5분 (300초)
- **자동 만료**: expires_at 필드로 관리
- **충돌 처리**: 소유권 검증, 만료 자동 정리
- **다중 락**: All-or-Nothing 원칙 (부분 실패 시 전체 롤백)

---

## IV. 백엔드-프론트엔드 통합 인터페이스 명세서

### 1. API 인터페이스 정의

#### 1.1 인증 관련 API

- **POST /auth/login**
  - 요청 형식:
    ```json
    {
      "user_id": "사용자ID",
      "password": "비밀번호"
    }
    ```
  - 응답 형식:
    ```json
    {
      "success": true,
      "message": "로그인 성공",
      "token": {
        "access_token": "JWT토큰문자열",
        "refresh_token": "리프레시토큰문자열"
      },
      "user": {
        "user_id": "사용자ID",
        "user_department": "CS|HES|LENOVO",
        "user_role": "ADMIN|USER"
      }
    }
    ```

- **POST /auth/refresh**
  - 요청 형식:
    ```json
    {
      "refresh_token": "리프레시토큰문자열"
    }
    ```
  - 응답 형식:
    ```json
    {
      "success": true,
      "message": "토큰이 갱신되었습니다",
      "data": {
        "token": {
          "access_token": "새JWT토큰문자열",
          "refresh_token": "새리프레시토큰문자열"
        }
      }
    }
    ```

- **POST /auth/logout**
  - 요청 형식:
    ```json
    {
      "refresh_token": "리프레시토큰문자열"
    }
    ```
  - 응답 형식:
    ```json
    {
      "success": true,
      "message": "로그아웃이 완료되었습니다"
    }
    ```

#### 1.2 대시보드 관련 API

- **POST /dashboard/list**
  - 요청 형식:
    ```json
    {
      "start_date": "YYYY-MM-DD",
      "end_date": "YYYY-MM-DD"
    }
    ```
  - 응답 형식:
    ```json
    {
      "success": true,
      "message": "데이터를 조회했습니다",
      "data": {
        "items": [
          {
            "dashboard_id": 123,
            "order_no": "ORD12345",
            "type": "DELIVERY|RETURN",
            "status": "WAITING|IN_PROGRESS|COMPLETE|ISSUE|CANCEL",
            "department": "CS|HES|LENOVO",
            "warehouse": "SEOUL|BUSAN|GWANGJU|DAEJEON",
            "eta": "2023-03-15T14:30:00",
            "customer": "고객명",
            "region": "서울시 강남구 역삼동",
            "driver_name": "기사명"
          }
        ],
        "date_range": {
          "oldest_date": "2023-01-01",
          "latest_date": "2023-03-31"
        }
      }
    }
    ```

- **GET /dashboard/{dashboard_id}**
  - 응답 형식:
    ```json
    {
      "success": true,
      "message": "상세 정보를 조회했습니다",
      "data": {
        "dashboard_id": 123,
        "order_no": "ORD12345",
        "type": "DELIVERY|RETURN",
        "status": "WAITING|IN_PROGRESS|COMPLETE|ISSUE|CANCEL",
        "department": "CS|HES|LENOVO",
        "warehouse": "SEOUL|BUSAN|GWANGJU|DAEJEON",
        "eta": "2023-03-15T14:30:00",
        "create_time": "2023-03-14T10:30:00",
        "depart_time": "2023-03-15T09:30:00",
        "complete_time": "2023-03-15T14:45:00",
        "postal_code": "12345",
        "city": "서울시",
        "county": "강남구",
        "district": "역삼동",
        "address": "상세주소",
        "customer": "고객명",
        "contact": "연락처",
        "driver_name": "기사명",
        "driver_contact": "기사연락처",
        "remarks": [
          {
            "remark_id": 456,
            "content": "메모내용",
            "created_at": "2023-03-14T14:30:00",
            "created_by": "작성자ID"
          }
        ],
        "is_locked": false
      },
      "is_locked": false,
      "lock_info": null
    }
    ```

- **PATCH /dashboard/{dashboard_id}/status**
  - 요청 형식:
    ```json
    {
      "status": "WAITING|IN_PROGRESS|COMPLETE|ISSUE|CANCEL",
      "is_admin": false
    }
    ```
  - 응답 형식:
    ```json
    {
      "success": true,
      "message": "상태가 변경되었습니다",
      "data": {
        "dashboard_id": 123,
        "status": "IN_PROGRESS",
        "depart_time": "2023-03-15T09:30:00"
      }
    }
    ```

#### 1.3 락 관련 API

- **POST /dashboard/{dashboard_id}/lock**
  - 요청 형식:
    ```json
    {
      "lock_type": "EDIT|STATUS|ASSIGN|REMARK"
    }
    ```
  - 응답 형식:
    ```json
    {
      "success": true,
      "message": "락을 획득했습니다",
      "data": {
        "dashboard_id": 123,
        "locked_by": "사용자ID",
        "lock_type": "EDIT",
        "expires_at": "2023-03-15T15:30:00"
      }
    }
    ```

- **DELETE /dashboard/{dashboard_id}/lock**
  - 응답 형식:
    ```json
    {
      "success": true,
      "message": "락을 해제했습니다",
      "data": {
        "dashboard_id": 123
      }
    }
    ```

### 2. 공통 오류 코드 및 메시지

#### 2.1 HTTP 상태 코드

- **200 OK**: 요청 성공
- **400 Bad Request**: 클라이언트 요청 오류
- **401 Unauthorized**: 인증 실패 또는 토큰 만료
- **403 Forbidden**: 권한 부족
- **404 Not Found**: 리소스 없음
- **422 Unprocessable Entity**: 데이터 검증 실패
- **423 Locked**: 비관적 락 충돌
- **500 Internal Server Error**: 서버 오류

#### 2.2 오류 응답 형식

```json
{
  "success": false,
  "message": "사용자 친화적 오류 메시지",
  "error_code": "오류 코드",
  "timestamp": "2023-03-15T14:30:00"
}
2.3 주요 오류 코드
UNAUTHORIZED: 인증 필요 또는 실패

INVALID_TOKEN: 유효하지 않은 토큰

TOKEN_EXPIRED: 만료된 토큰

FORBIDDEN: 권한 부족

NOT_FOUND: 리소스 없음

VALIDATION_ERROR: 데이터 검증 실패

RESOURCE_LOCKED: 락 충돌

INTEGRITY_ERROR: 데이터 무결성 위반

SERVER_ERROR: 서버 내부 오류

3. 유저 시나리오별 통합 흐름
3.1 로그인 및 인증 흐름
프론트엔드: 로그인 폼 표시 → 사용자 입력 → 기본 검증

백엔드: 사용자 인증 → 토큰 생성 → 응답 반환

프론트엔드: 토큰 저장 → 사용자 정보 저장 → 대시보드 이동

3.2 대시보드 조회 흐름
프론트엔드: 날짜 범위 설정 → API 요청

백엔드: 날짜 검증 → 데이터 쿼리 → 응답 구성

프론트엔드: 데이터 수신 → 테이블 렌더링 → 필터 적용

3.3 상태 변경 흐름
프론트엔드: 상태 버튼 클릭 → 락 획득 요청

백엔드: 락 상태 확인 → 락 생성 → 응답 반환

프론트엔드: 락 획득 확인 → 상태 변경 요청

백엔드: 상태 전이 검증 → 상태 변경 → 자동 시간 갱신 → 응답 반환

프론트엔드: 락 해제 요청 → 결과 표시

백엔드: 락 해제 → 응답 반환

3.4 비관적 락 충돌 처리 흐름
프론트엔드: 락 획득 요청

백엔드: 기존 락 확인 → 충돌 감지 → 423 Locked 응답

프론트엔드: 충돌 감지 → 락 소유자 정보 표시 → 읽기 전용 모드 활성화

4. 공통 데이터 정의
4.1 대시보드 객체 구조
json
복사
편집
{
  "dashboard_id": "대시보드 ID (정수)",
  "order_no": "주문번호 (문자열)",
  "type": "종류 (DELIVERY|RETURN)",
  "status": "상태 (WAITING|IN_PROGRESS|COMPLETE|ISSUE|CANCEL)",
  "department": "부서 (CS|HES|LENOVO)",
  "warehouse": "창고 (SEOUL|BUSAN|GWANGJU|DAEJEON)",
  "sla": "SLA (문자열)",
  "eta": "예상도착시간 (ISO 8601 형식)",
  "create_time": "생성시간 (ISO 8601 형식)",
  "depart_time": "출발시간 (ISO 8601 형식, 선택적)",
  "complete_time": "완료시간 (ISO 8601 형식, 선택적)",
  "postal_code": "우편번호 (문자열)",
  "city": "도시 (문자열)",
  "county": "구/군 (문자열)",
  "district": "동/읍/면 (문자열)",
  "region": "지역 (city+county+district 조합)",
  "distance": "거리 (km, 정수)",
  "duration_time": "소요시간 (분, 정수)",
  "address": "상세주소 (문자열)",
  "customer": "고객명 (문자열)",
  "contact": "연락처 (문자열, 선택적)",
  "driver_name": "기사명 (문자열, 선택적)",
  "driver_contact": "기사연락처 (문자열, 선택적)",
  "created_by": "작성자 ID (문자열, 선택적)"
}
4.2 공통 응답 구조
json
복사
편집
{
  "success": "성공 여부 (boolean)",
  "message": "응답 메시지 (문자열)",
  "data": "응답 데이터 (객체, 배열, 또는 null)",
  "meta": "메타 정보 (선택적, 페이지네이션 등)"
}
4.3 필터링 옵션
날짜 범위: start_date, end_date (YYYY-MM-DD 형식)

종류: type (ALL, DELIVERY, RETURN)

부서: department (ALL, CS, HES, LENOVO)

창고: warehouse (ALL, SEOUL, BUSAN, GWANGJU, DAEJEON)

상태: status (ALL, WAITING, IN_PROGRESS, COMPLETE, ISSUE, CANCEL)

5. 공통 제약사항 및 고려사항
5.1 성능 고려사항
대량 데이터 처리: 최근 1개월 데이터 위주 처리, 과거 데이터는 제한적 접근

응답 시간: 일반 조회 1초 이내, 대용량 다운로드 5초 이내 목표

API 타임아웃: 기본 10초, 다운로드는 20초로 설정

5.2 보안 고려사항
토큰 관리: 서버는 리프레시 토큰만 저장, 액세스 토큰은 클라이언트만 보유

인증 헤더: 모든 요청에 Authorization: Bearer {token} 헤더 필요

관리자 접근 제어: 삭제, 다운로드 등 특정 기능은 관리자 권한 검증

5.3 확장성 고려사항
데이터 구조 변경: 향후 필드 추가는 기존 클라이언트 호환성 보장

API 버전 관리: 현재 버전 고정, 향후 /api/v2/ 등으로 버전 관리 도입 가능

캐싱 전략: 시각화 데이터 등 자주 변경되지 않는 데이터 캐싱 검토

6. 개발 협업 가이드
6.1 개발 환경 설정
로컬 개발 환경: .env.local 파일 통해 공통 설정 관리

API URL 및 타임아웃: 프론트엔드와 백엔드 간 일치 필요

CORS 설정: 개발 단계에서는 모든 오리진 허용, 프로덕션에서는 제한 필요

6.2 테스트 전략
통합 테스트 시나리오: 주요 사용자 흐름 기반 시나리오 테스트

비관적 락 테스트: 다중 세션 환경에서 락 획득/해제/충돌 테스트

에러 케이스 테스트: 각 오류 유형에 대한 프론트엔드 처리 검증

6.3 배포 고려사항
도커 환경: 단일 컨테이너에 FastAPI와 Dash 함께 배포

환경 변수: 환경별 설정 분리 (.env.local, .env.prod)

로깅 구성: 프로덕션 환경에서 중요 이벤트 중심 로깅 설정

6.4 유지보수 고려사항
API 변경 사항: 변경 시 상호 영향 평가 및 공유

성능 모니터링: 주요 API 응답 시간 지속 모니터링

사용자 피드백: UI/UX 개선을 위한 사용자 피드백 수집 및 반영

