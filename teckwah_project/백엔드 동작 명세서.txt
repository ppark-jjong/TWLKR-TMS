II. 백엔드 동작 명세서 (개선)
1. 아키텍처 기본 원칙
1.1 계층 구조

API 라우터 계층: HTTP 요청 수신 및 응답 반환
서비스 계층: 핵심 비즈니스 로직 구현
레포지토리 계층: 데이터 접근 로직 (단순화 및 통합)
모델/스키마 계층: 데이터 구조 정의

1.2 설계 원칙

백엔드 검증 최소화: 보안 및 데이터 정합성 관련 검증만 수행
자동화 기능 배제: 모든 작업은 명시적 API 호출에 의해서만 발생
단순성 추구: 불필요한 추상화 및 복잡성 제거

2. API 엔드포인트 및 데이터 흐름
2.1 인증 관련 API
2.1.1 로그인 API

엔드포인트: POST /auth/login
기능: 사용자 인증 및 토큰 발급
검증 책임: 보안 관련 검증만 수행 (존재하는 사용자인지, 비밀번호 일치 여부 등)
응답: 성공 시 액세스 토큰과 리프레시 토큰 반환

2.1.2 토큰 갱신 API

엔드포인트: POST /auth/refresh
기능: 리프레시 토큰을 사용하여 새 액세스 토큰 발급
검증 책임: 리프레시 토큰 유효성 검증(서명, 만료 여부 등)
주의사항: 자동 갱신 메커니즘 없음, 클라이언트 요청 시에만 갱신

2.1.3 로그아웃 API

엔드포인트: POST /auth/logout
기능: 리프레시 토큰 무효화
검증 책임: 토큰 존재 여부 확인

2.2 대시보드 관련 API
2.2.1 대시보드 목록 조회 API

엔드포인트: POST /dashboard/list
기능: ETA 기준 날짜 범위 내 대시보드 목록 조회
검증 책임: 날짜 형식 및 범위 기본 검증
최적화: 페이지네이션 지원, 필수 필드만 반환

2.2.2 대시보드 상세 조회 API

엔드포인트: GET /dashboard/{dashboard_id}
기능: 대시보드 상세 정보, 메모, 락 상태 조회
검증 책임: ID 유효성 기본 검증

2.2.3 대시보드 생성 API

엔드포인트: POST /dashboard
기능: 새 대시보드 레코드 생성 및 빈 메모 자동 생성
검증 책임: 최소한의 필수 필드 존재 여부 확인
참고: 상세 데이터 유효성은 프론트엔드에서 검증 완료 가정

2.2.4 대시보드 필드 업데이트 API

엔드포인트: PATCH /dashboard/{dashboard_id}/fields
기능: 대시보드 정보 수정
검증 책임: 락 상태 확인, 최소한의 데이터 형식 검증
특징: 비관적 락 적용 (명시적 락 획득/해제 필요)

2.2.5 대시보드 상태 업데이트 API

엔드포인트: PATCH /dashboard/{dashboard_id}/status
기능: 대시보드 상태 변경 및 관련 시간 필드 자동 업데이트
검증 책임: 락 상태 확인, 상태 전이 규칙 기본 검증
특징: 비관적 락 적용 (명시적 락 획득/해제 필요)

2.2.6 배차 처리 API

엔드포인트: POST /dashboard/assign
기능: 여러 대시보드에 기사 정보 일괄 할당
검증 책임: 락 상태 확인, 대시보드 ID 유효성 기본 검증
특징: 다중 비관적 락 적용

2.3 락 관련 API
2.3.1 락 획득 API

엔드포인트: POST /dashboard/{dashboard_id}/lock
기능: 대시보드에 대한 비관적 락 획득
검증 책임: 기존 락 상태 확인
특징: 5분 후 자동 만료 (연장 기능 없음)

2.3.2 락 해제 API

엔드포인트: DELETE /dashboard/{dashboard_id}/lock
기능: 획득한 락 명시적 해제
검증 책임: 락 소유권 확인 (본인 락만 해제 가능)

3. 서비스 계층 동작
3.1 인증 서비스

주요 책임: 사용자 인증, 토큰 관리
검증 최소화: ID/비밀번호 일치 여부 등 핵심 보안 검증만 수행
자동화 배제: 토큰 자동 갱신 없음, 명시적 요청 시에만 처리

3.2 대시보드 서비스

주요 책임: 대시보드 CRUD, 상태 관리, 배차 처리
검증 최소화: 기본적인 데이터 정합성 검증에 집중
비관적 락 활용: 동시성 제어는 명시적 락 획득/해제로 관리
간소화된 구현: 불필요한 추상화 없이 핵심 기능에 집중

3.3 락 서비스

주요 책임: 비관적 락 관리 (획득, 해제, 상태 확인)
단순화된 구현: 복잡한 재시도 로직 없이 기본 락 동작만 구현
자동화 배제: 자동 락 정리/연장 없음, 만료는 DB 타임아웃으로 처리

4. 오류 처리 및 응답 구조
4.1 일관된 오류 응답 구조
json복사{
  "success": false,
  "message": "사용자 친화적 오류 메시지",
  "error_code": "OPTIONAL_ERROR_CODE"
}
4.2 주요 HTTP 상태 코드

200 OK: 성공 응답
400 Bad Request: 클라이언트 요청 오류
401 Unauthorized: 인증 실패
403 Forbidden: 권한 없음
404 Not Found: 리소스 없음
423 Locked: 비관적 락 충돌
500 Internal Server Error: 서버 오류

4.3 오류 로깅

구조화된 로깅: JSON 형식 로그 사용
컨텍스트 포함: 발생 위치, 사용자 ID 등 컨텍스트 정보 포함
간소화된 로그 레벨: ERROR, INFO, DEBUG 세 가지 수준으로 단순화

5. 데이터베이스 접근 및 트랜잭션
5.1 레포지토리 패턴

단순화된 레포지토리: 관련 기능은 하나의 레포지토리로 통합
직접적 데이터 접근: 불필요한 추상화 제거

5.2 트랜잭션 관리

단순 트랜잭션: 기본 트랜잭션 관리만 구현
재시도 로직 제거: 복잡한 재시도 메커니즘 대신 명확한 오류 전달

5.3 비관적 락 구현

명시적 락 관리: 명확한 획득/해제 패턴 사용
타임아웃 기반: 5분 고정 타임아웃, 연장 없음
단순화된 충돌 처리: 423 Locked 상태 코드로 명확하게 전달