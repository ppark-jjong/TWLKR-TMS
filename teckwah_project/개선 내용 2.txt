# 배송 관제 시스템 코드 중복 및 구조적 문제 분석

현재 프로젝트 코드를 종합적으로 검토한 결과, 여러 영역에서 중복 코드와 구조적 비일관성이 발견되었습니다. 각 영역별로 주요 문제점과 개선 방향을 분석해 드리겠습니다.

## 1. 유틸리티 계층 중복

### 1-1. 유틸리티 함수 중복
```python
# common.py와 constants.py에 중복된 상수들
# common.py
class DeliveryType(str, Enum):
    DELIVERY = "DELIVERY"
    RETURN = "RETURN"

# constants.py에도 동일한 enum 정의
class DeliveryType(str, Enum):
    DELIVERY = "DELIVERY"
    RETURN = "RETURN"
```

- **문제점**: `common.py`와 `constants.py`가 거의 동일한 코드 구조를 가지며, 특히 상태 코드와 메시지 매핑이 중복됩니다.
- **심각도**: 높음 (코드 변경 시 두 곳 모두 수정해야 하는 유지보수 위험)

### 1-2. 날짜/시간 관련 함수 분산
```javascript
// dateUtils.js
export const formatDate = (date, format = 'YYYY-MM-DD HH:mm:ss') => {
  if (!date) return '-';
  return dayjs(date).format(format);
};

// 다른 컴포넌트에서도 유사 기능 구현
const formattedDate = dayjs(item.created_at).format('YYYY-MM-DD HH:mm');
```

- **문제점**: 날짜 관련 헬퍼 함수가 `dateUtils.js`에 정의되어 있지만, 여러 컴포넌트에서 동일한 기능을 직접 구현합니다.
- **심각도**: 중간 (일관성 저하와 로직 변경 시 누락 위험)

### 1-3. 에러 처리 메커니즘 중복
```javascript
// errorHandlers.js의 showUniqueMessage 함수와 유사한 기능이
// 여러 컴포넌트에서 직접 구현됨
message.error('대시보드 상태 변경 중 오류가 발생했습니다');

// api.js에서도 유사한 에러 처리
handleApiError(error, { context: '상태 변경' });
```

- **문제점**: 오류 메시지 표시 방식이 통일되지 않고, 비슷한 기능이 여러 파일에 분산되어 있습니다.
- **심각도**: 중간 (사용자 경험 불일관성)

## 2. 서비스 계층 중복

### 2-1. 락 관련 로직 중복
```python
# dashboard_service.py와 handover_service.py에서 유사한 락 로직 반복
def acquire_lock(self, dashboard_id: int, user_id: str) -> Optional[LockResponse]:
    # 락 획득 로직...

# handover_service.py에도 유사한 함수
def acquire_lock(self, handover_id: int, current_user: str, timeout: int = 300):
    # 비슷한 락 획득 로직...
```

- **문제점**: 락 획득/해제 로직이 서비스마다 중복 구현되어 있습니다.
- **심각도**: 높음 (락 메커니즘 변경 시 여러 서비스를 수정해야 함)

### 2-2. API 응답 포맷팅 중복
```python
# 여러 서비스에서 반복되는 응답 구조화
return {
    "success": True,
    "message": "락을 획득했습니다",
    "data": lock_info
}

# 다른 서비스 메서드에서도 유사한 형태
return {
    "success": False,
    "error_code": "LOCK_CONFLICT",
    "message": "다른 사용자가 수정 중입니다."
}
```

- **문제점**: API 응답 구조화 로직이 여러 서비스에 중복되어 있습니다.
- **심각도**: 중간 (응답 형식 변경 시 전체 코드 수정 필요)

## 3. 리포지토리 계층 중복

### 3-1. CRUD 기본 연산 중복
```python
# dashboard_repository.py와 handover_repository.py에서 유사한 패턴
def get_dashboard_by_id(self, dashboard_id: int) -> Optional[Dashboard]:
    return self.db.query(Dashboard).filter(Dashboard.dashboard_id == dashboard_id).first()

# 거의 동일한 패턴의 handover 조회 함수
def get_handover_by_id(self, handover_id: int) -> Optional[HandoverRecord]:
    return self.db.query(HandoverRecord).filter(HandoverRecord.handover_id == handover_id).first()
```

- **문제점**: 기본 CRUD 로직이 각 리포지토리마다 반복 구현되어 있습니다.
- **심각도**: 중간 (공통 기능을 추상화하여 코드량 감소 가능)

### 3-2. 행 수준 락 중복 구현
```python
# 여러 리포지토리에서 유사한 행 락 로직
def get_dashboard_with_lock(self, dashboard_id: int, user_id: str):
    try:
        # 행 락 획득 로직...
    except Exception as e:
        # 예외 처리...

# handover_repository에도 유사한 함수
def get_handover_with_lock(self, handover_id: int, user_id: str):
    try:
        # 유사한 락 획득 로직...
    except Exception as e:
        # 유사한 예외 처리...
```

- **문제점**: 행 수준 락 관련 로직이 각 리포지토리에 중복되어 있습니다.
- **심각도**: 높음 (락 메커니즘 변경 시 모든 리포지토리 수정 필요)

## 4. 프론트엔드 컴포넌트 중복

### 4-1. 페이지 컴포넌트 중복 구조
```javascript
// DashboardPage.js와 AdminPage.js의 구조가 매우 유사
const DashboardPage = () => {
  const [selectedRowKeys, setSelectedRowKeys] = useState([]);
  // 매우 유사한 훅 사용
  const {
    dashboards: data,
    isLoading,
    searchParams,
    // ... 중복 코드
  } = useDashboardData('USER');
  
  // 중복되는 함수들...
}

// AdminPage.js도 거의 동일한 구조
const AdminPage = () => {
  const [selectedRowKeys, setSelectedRowKeys] = useState([]);
  // 매우 유사한 훅 사용
  const {
    dashboards: data,
    isLoading,
    searchParams,
    // ... 중복 코드
  } = useDashboardData('ADMIN');
  
  // 중복되는 함수들...
}
```

- **문제점**: `DashboardPage.js`와 `AdminPage.js`가 약 70-80% 정도 중복된 코드 구조를 가집니다.
- **심각도**: 매우 높음 (대부분의 로직을 공통 컴포넌트로 추출 가능)

### 4-2. 모달 컴포넌트 중복
```javascript
// 여러 모달 컴포넌트에서 유사한 구조 반복
const StatusChangeModal = ({
  open,
  onOk,
  onCancel,
  form,
  confirmLoading,
  // ... 유사한 속성
}) => {
  // 모달 공통 로직
  return (
    <Modal
      title="상태 변경"
      open={open}
      onOk={onOk}
      onCancel={onCancel}
      // ... 유사한 속성
    >
      {/* 유사한 폼 구조 */}
    </Modal>
  );
};

// 다른 모달도 매우 유사한 구조
const AssignDriverModal = ({
  open,
  onOk,
  onCancel,
  form,
  confirmLoading,
  // ... 유사한 속성
}) => {
  // 모달 공통 로직
  return (
    <Modal
      title="배차 처리"
      open={open}
      onOk={onOk}
      onCancel={onCancel}
      // ... 유사한 속성
    >
      {/* 유사한 폼 구조 */}
    </Modal>
  );
};
```

- **문제점**: 여러 모달 컴포넌트(`StatusChangeModal`, `AssignDriverModal`, `DashboardDetailModal` 등)가 비슷한 구조와 로직을 가집니다.
- **심각도**: 높음 (기본 모달 구조를 추상화하여 컴포넌트 크기 축소 가능)

### 4-3. API 호출 및 에러 처리 중복
```javascript
// 여러 페이지 및 컴포넌트에서 유사한 API 호출 패턴
// 성공/실패 핸들링 중복
try {
  const response = await getDashboardDetail(id);
  if (response && response.data && response.data.success) {
    const dashboardData = response.data.data;
    openDetailModal(dashboardData);
  } else {
    message.error('상세 정보를 불러오는데 실패했습니다');
  }
} catch (error) {
  console.error('상세 정보 조회 오류:', error);
  message.error('상세 정보를 불러오는데 실패했습니다');
}
```

- **문제점**: API 호출 및 에러 처리 패턴이 여러 컴포넌트에 반복됩니다.
- **심각도**: 중간 (공통 API 호출 헬퍼 함수로 추출 가능)

## 5. 커스텀 훅 중복 및 비효율성

### 5-1. 유사한 훅 로직
```javascript
// useDashboardData.js와 다른 훅들의 유사한 구조
const useDashboardData = (userRole = 'USER') => {
  const [searchParams, setSearchParams] = useState({...});
  
  // API 호출 로직
  const fetchData = useCallback(async () => {
    // 유사한 데이터 가져오기 로직
  }, [searchParams]);

  // React Query 사용
  const {
    data: apiResponse,
    isLoading,
    isError,
    refetch,
  } = useQuery(['dashboards', searchParams], fetchData, {...});

  // 여러 헬퍼 함수들
  const handleSearch = useCallback(...)
  const handlePaginationChange = useCallback(...)
  
  return {...}
};

// 다른 커스텀 훅도 유사한 패턴
```

- **문제점**: 여러 커스텀 훅이 유사한 데이터 가져오기, 검색, 페이지네이션 패턴을 중복 구현합니다.
- **심각도**: 중간 (더 일반적인 데이터 관리 훅으로 추상화 가능)

## 6. 전반적인 구조적 문제

### 6-1. 비일관적인 오류 처리
```python
# 서로 다른 에러 처리 스타일
# 스타일 1: 예외 발생
if not dashboard:
    raise NotFoundException(f"ID가 {dashboard_id}인 대시보드를 찾을 수 없습니다")

# 스타일 2: 오류 객체 반환
if not handover:
    return {
        "success": False,
        "error_code": "NOT_FOUND",
        "message": "인수인계 항목을 찾을 수 없습니다."
    }
```

- **문제점**: 백엔드에서 일관되지 않은 오류 처리 패턴을 사용합니다.
- **심각도**: 높음 (예측 불가능한 동작과 오류 처리 복잡성 증가)

### 6-2. 과도한 계층 및 래퍼 함수
```python
# repository > service > router 계층을 통한 단순 CRUD 작업의 과도한 래핑
# router.py
@router.get("/{dashboard_id}", response_model=DashboardDetailResponse)
async def get_dashboard_detail(
    dashboard_id: int,
    service: DashboardService = Depends(get_dashboard_service),
):
    dashboard = service.get_dashboard_detail(dashboard_id)
    # ...

# service.py
def get_dashboard_detail(self, dashboard_id: int) -> Dict[str, Any]:
    dashboard = self.repository.get_dashboard_detail(dashboard_id)
    # ...

# repository.py
def get_dashboard_detail(self, dashboard_id: int) -> Optional[Dashboard]:
    dashboard = self.db.query(Dashboard).filter(Dashboard.dashboard_id == dashboard_id).first()
    # ...
```

- **문제점**: 단순 CRUD 작업이 너무 많은 계층을 거쳐 처리됩니다.
- **심각도**: 중간 (더 간결한 구조로 리팩토링 가능)

## 7. 구체적인 중복 코드 사례

### 7-1. API 응답 구조화 중복
```python
# 여러 파일에서 반복되는 응답 구조화
return {
    "success": True,
    "message": "데이터를 조회했습니다",
    "data": result,
    "meta": {...}
}

# 다른 함수도 유사한 구조
return {
    "success": False,
    "message": "오류가 발생했습니다",
    "error_code": "SERVER_ERROR"
}
```

- **문제점**: API 응답 구조화 코드가 모든 엔드포인트에 반복됩니다.
- **심각도**: 중간 (응답 헬퍼 함수로 추출 가능)

### 7-2. 모듈 간 순환 의존성
```python
# transaction.py와 error.py 간 순환 참조
# transaction.py
from server.utils.error import LockConflictException

# error.py에서도 transaction 관련 타입이나 함수 참조
from server.utils.transaction import ...
```

- **문제점**: 일부 모듈 간에 순환 의존성이 존재합니다.
- **심각도**: 높음 (애플리케이션 로딩 문제와 예측 불가능한 동작 초래)

## 개선 권장사항 요약

1. **중복 유틸리티 통합**: `common.py`와 `constants.py`를 통합하고, 모든 공통 상수와 열거형을 한 곳에서 관리합니다.

2. **공통 훅 및 컴포넌트 추출**: `DashboardPage.js`와 `AdminPage.js`의 공통 로직을 재사용 가능한 컴포넌트로 추출합니다.

3. **락 메커니즘 추상화**: 모든 리포지토리에서 사용하는 행 수준 락 로직을 하나의 공통 유틸리티로 추상화합니다.

4. **일관된 오류 처리**: 백엔드 전체에서 일관된 오류 처리 패턴(예외 또는 객체 반환 중 하나)을 채택합니다.

5. **모달 컴포넌트 추상화**: 기본 모달 구조를 추상화한 베이스 컴포넌트를 만들고, 특정 모달은 이를 확장하도록 합니다.

6. **API 응답 헬퍼**: 응답 구조화를 위한 공통 헬퍼 함수를 만들어 일관된 API 응답을 보장합니다.

7. **순환 의존성 제거**: 모듈 간 명확한 책임 분리로 순환 의존성을 제거합니다.

루트 명세서의 "단순성 우선"과 "YAGNI" 원칙을 따르면서도, 이러한 중복 코드 제거는 코드베이스를 더 간결하고 유지보수하기 쉽게 만들 것입니다.