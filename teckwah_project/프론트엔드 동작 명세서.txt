III. 프론트엔드 동작 명세서
1. 개요 및 구성
1.1 사용 기술 및 라이브러리
핵심 프레임워크: Dash 2.14.1

UI 컴포넌트: Dash Bootstrap Components 1.5.0

차트 라이브러리: Plotly

스타일링: Bootstrap CSS, 커스텀 CSS

1.2 폴더 구조 및 주요 파일
api: API 클라이언트 (api_client.py)

assets: 정적 자원 (CSS, 이미지)

callbacks: 상호작용 로직 (auth_callbacks.py, dashboard_callbacks.py 등)

components: 재사용 UI 컴포넌트 (alerts.py, modals.py, navbar.py)

layouts: 페이지 레이아웃 (login_layout.py, dashboard_layout.py 등)

utils: 유틸리티 함수 (auth_helper.py, format_helper.py 등)

2. 페이지 구조 및 레이아웃
2.1 로그인 페이지
구성요소:

시스템 로고 및 타이틀

로그인 폼 (ID, 비밀번호 입력)

로그인 버튼

오류 메시지 영역

동작 흐름:

폼 입력 → 유효성 검사 → API 호출 → 토큰 저장 → 대시보드로 리다이렉트

오류 발생 시 오류 메시지 표시

2.2 대시보드 페이지
구성요소:

헤더 영역 (타이틀, 설명)

날짜 필터 (ETA 기준)

주문번호 검색

액션 버튼 (신규 등록, 배차, 삭제, 새로고침)

필터 영역 (종류, 부서, 창고)

대시보드 테이블

모달 컨테이너 (상세, 배차, 삭제, 신규 등록)

동작 흐름:

페이지 로드 → 날짜 설정 → 데이터 자동 조회

필터 변경 → 필터 적용 버튼 클릭 → 테이블 갱신

행 클릭 → 상세 모달 열기 → 상태 변경/정보 수정

행 선택 → 배차/삭제 버튼 활성화 → 작업 수행

2.3 시각화 페이지
구성요소:

헤더 영역 (타이틀, 설명)

차트 타입 선택기

날짜 필터

새로고침 버튼

배송 현황 차트 컨테이너

통계 카드 (총 건수, 대기 건수, 완료 건수)

상태별 파이 차트

부서별 바 차트

시간대별 접수량 차트 컨테이너

통계 카드 (총 건수, 평균 건수, 피크 시간)

시간대별 라인 차트

부서별 히트맵

동작 흐름:

차트 타입 선택 → 컨테이너 전환

날짜 선택 → 새로고침 클릭 → 데이터 로드 → 차트 갱신

2.4 다운로드 페이지 (관리자 전용)
구성요소:

헤더 영역 (타이틀, 설명)

다운로드 설정 카드

날짜 범위 선택

다운로드 가능 날짜 정보

Excel 다운로드 버튼

관리자 권한 확인 영역

로딩 스피너

동작 흐름:

권한 확인 → 관리자가 아니면 접근 차단

날짜 선택 → 다운로드 버튼 클릭 → 엑셀 파일 다운로드

3. 컴포넌트 및 상호작용
3.1 네비게이션 바
구성요소:

로고 및 시스템 이름

네비게이션 메뉴 (대시보드, 시각화, 다운로드)

세션 확인 및 토큰 갱신 버튼

사용자 정보 표시

로그아웃 버튼

동작 기능:

페이지 이동

세션 상태 확인

토큰 수동 갱신

로그아웃 처리

3.2 모달 컴포넌트
상세 정보 모달:

주문 정보, 시간 정보, 고객 정보, 배송 정보 표시

메모 입력/수정 기능

상태 변경 버튼

락 상태 표시

배차 모달:

기사 정보 입력 (이름, 연락처)

선택한 주문 목록 표시

배차 처리 기능

삭제 확인 모달:

삭제 확인 메시지

선택한 주문 수 표시

삭제 처리 기능

신규 등록 모달:

주문 정보 입력 폼

고객 정보 입력 폼

유효성 검사

등록 처리 기능

3.3 알림 컴포넌트
구성요소:

아이콘 (유형에 따라 변경)

메시지 텍스트

상태 색상 (primary, success, warning, danger)

자동 닫기 타이머

동작 기능:

작업 결과 표시

오류 알림

경고 메시지 표시

자동 사라짐

3.4 테이블 컴포넌트
구성요소:

체크박스 선택 열

데이터 열 (주문번호, 종류, 상태 등)

상태별 색상 구분

동작 기능:

행 선택/해제

행 클릭 시 상세 모달 열기

선택 상태에 따른 버튼 활성화/비활성화

정렬 기능

4. 상태 관리 및 데이터 흐름
4.1 주요 상태 저장소
auth-store (세션 스토리지):

access_token: 요청 인증용 토큰

refresh_token: 토큰 갱신용 토큰

is_authenticated: 인증 상태

auth_time: 인증 시간 (갱신 필요 감지용)

user-info-store (세션 스토리지):

user_id: 사용자 식별자

department: 소속 부서

role: 역할 (ADMIN 또는 USER)

is_admin: 관리자 여부

app-state-store (메모리 스토리지):

alert: 알림 정보 (메시지, 색상, 지속시간)

modals: 모달 상태 정보 (열림 여부, 관련 데이터)

filters: 필터 상태 (종류, 부서, 창고)

reload_data: 데이터 리로드 트리거

dashboard-data-store (메모리 스토리지):

현재 테이블 데이터

날짜 범위 정보

4.2 주요 데이터 흐름
인증 흐름:

로그인 → 토큰 저장 → 사용자 정보 저장 → 대시보드 접근

페이지 접근 → 인증 확인 → 인증 안됨 → 로그인 리다이렉트

토큰 만료 → 토큰 갱신 시도 → 실패 → 로그인 리다이렉트

대시보드 데이터 흐름:

날짜 선택 → 조회 버튼 클릭 → API 호출 → 데이터 저장 → 테이블 갱신

필터 적용 → 데이터 필터링 → 테이블 갱신

모달 작업 완료 → reload_data 트리거 설정 → 데이터 자동 리로드

비관적 락 흐름:

상세 모달 열기 → 락 상태 확인 → 락 있음 → 읽기 전용 모드

편집 시작 → 락 획득 시도 → 성공 → 편집 활성화

편집 완료/취소 → 락 해제 → 결과 표시

시각화 데이터 흐름:

차트 타입 선택 → 컨테이너 전환

날짜 선택 → 새로고침 클릭 → API 호출 → 데이터 수신 → 차트 생성

5. API 클라이언트 및 오류 처리
5.1 API 클라이언트 구조
설정 관리:

공통 URL과 타임아웃 설정

헤더 생성 유틸리티 함수

요청 처리:

HTTP 메서드별 함수 (GET, POST, PATCH, DELETE)

토큰 자동 추가

JSON 변환

응답 처리:

공통 응답 구조 파싱

오류 처리 및 메시지 추출

5.2 오류 처리 전략
네트워크 오류:

타임아웃, 연결 실패 감지

사용자 친화적 메시지 표시

인증 오류 (401):

토큰 만료 감지

로그인 페이지로 리다이렉트

락 충돌 오류 (423):

충돌 감지

락 소유자 정보 표시

일반 오류:

서버 메시지 추출

알림 표시

5.3 사용자 피드백
로딩 상태 표시:

API 호출 시작 → 로딩 표시

완료 → 로딩 숨김

알림 메시지:

성공/실패 상태에 따라 색상, 메시지 출력

자동 사라짐

필드 유효성 피드백:

실시간 유효성 검사

오류 메시지 인라인 표시

6. 주요 기능별 흐름
6.1 로그인 및 인증 관리
로그인 프로세스:

사용자 입력 → 기본 검증 → API 호출 → 토큰 저장 → 리다이렉트

실패 시 오류 메시지 표시

세션 관리:

페이지 접근 시 인증 확인

인증 안된 경우 로그인 페이지로 리다이렉트

로그인 상태로 로그인 페이지 접근 시 대시보드로 리다이렉트

토큰 갱신:

세션 만료 확인 → 토큰 갱신 버튼 활성화

버튼 클릭 → 리프레시 토큰으로 갱신 시도

실패 시 로그인 페이지로 리다이렉트

6.2 대시보드 관리
조회 프로세스:

날짜 선택 → 조회 버튼 클릭 → API 호출 → 데이터 표시

필터 설정 → 필터 적용 버튼 클릭 → 데이터 필터링

상세 정보 조회/편집:

행 클릭 → 상세 모달 열기 → 락 상태 확인

락 없음 → 편집 가능

락 있음 → 읽기 전용 모드

상태 변경:

상태 버튼 클릭 → 락 획득 → 상태 변경 API 호출 → 락 해제

결과 표시 → 데이터 리로드

배차 처리:

행 선택 → 배차 버튼 클릭 → 배차 모달 열기

기사 정보 입력 → 배차 완료 버튼 클릭

API 호출 → 결과 표시 → 데이터 리로드

삭제 처리 (관리자 전용):

행 선택 → 삭제 버튼 클릭 → 삭제 확인 모달 열기

확인 버튼 클릭 → API 호출 → 결과 표시 → 데이터 리로드

6.3 시각화 기능
배송 현황 차트:

차트 타입 선택 → 날짜 설정 → 새로고침 버튼 클릭

API 호출 → 데이터 수신 → 차트 및 통계 카드 갱신

시간대별 접수량 차트:

차트 타입 선택 → 날짜 설정 → 새로고침 버튼 클릭

API 호출 → 데이터 수신 → 차트 및 통계 카드 갱신

6.4 다운로드 기능 (관리자 전용)
Excel 다운로드:

관리자 권한 확인 → 날짜 설정 → 다운로드 버튼 클릭

API 호출 → 파일 수신 → 다운로드 시작

결과 처리(성공/실패) → 알림 표시

7. 보안 및 접근 제어
7.1 인증 관리
토큰 기반 인증:

모든 API 요청에 Authorization 헤더 포함

세션 스토리지에 토큰 저장 (로컬 스토리지 사용 안 함)

권한 기반 접근 제어:

관리자 페이지 접근 제한 (다운로드 페이지)

관리자 전용 기능 버튼 비활성화 (삭제 등)

7.2 데이터 보호
인증 정보 취급:

비밀번호 암호화 전송 (HTTPS 가정)

토큰 만료 시간 관리

세션 관리:

명시적 로그아웃 처리

토큰 만료 시 자동 세션 종료

8. 반응형 디자인 및 사용성
8.1 반응형 고려사항
모바일 대응:

컨테이너 유동적 크기 조정

카드 및 패널 스택 처리

고해상도 최적화:

1920x1080 해상도 기준 레이아웃

여백 및 패딩 최적화

8.2 사용성 개선
로딩 상태 표시:

데이터 로드 중 스피너 표시

빈 데이터 전용 UI

알림 메시지:

작업 결과 즉시 피드백

색상 구분으로 상태 명확화

오류 처리:

사용자 친화적 오류 메시지

오류 후 복구 경로 제공

9. 테스트 및 유지보수 고려사항
9.1 디버깅 및 로깅
콘솔 로깅:

중요 작업 로깅

오류 상세 정보 기록

사용자 피드백:

작업 진행 상태 표시

오류 발생 시 명확한 안내

9.2 성능 최적화
데이터 로딩 최적화:

필요 시에만 API 호출

로컬 캐싱 활용

UI 반응성:

중요 UI 요소 우선 렌더링

대용량 데이터 페이지네이션

III. 프론트엔드 동작 명세서 (계속)
10. 유지보수 및 확장성 고려사항
10.1 코드 구조화 원칙
컴포넌트 분리:

기능별 컴포넌트 모듈화

재사용 가능한 UI 요소 독립 관리

관심사 분리 원칙 적용

콜백 모듈화:

기능별 콜백 그룹화 (auth_callbacks, dashboard_callbacks 등)

단일 책임 원칙 적용

부작용 최소화 및 명시적 상태 관리

유틸리티 분리:

공통 기능 모듈화 (format_helper, auth_helper 등)

비즈니스 로직과 UI 로직 분리

테스트 용이성 확보

10.2 백엔드 인터페이스 의존성 관리
API 클라이언트 중앙화:

모든 API 호출은 api_client.py를 통해 수행

백엔드 API 변경 시 영향 범위 최소화

응답 구조 파싱 및 오류 처리 일관성 유지

데이터 변환 계층:

백엔드 응답 → 프론트엔드 데이터 구조 변환 표준화

날짜, 상태 코드 등 포맷팅 일관성 유지

백엔드 응답 구조 변경에 대응하기 위한 추상화

10.3 확장 지점
새로운 차트 유형:

시각화 페이지에 새로운 차트 타입 추가 가능

기존 시각화 패턴 활용 확장

추가 필터 조건:

필터 컴포넌트 확장 가능성 고려

상태 저장 구조 유연성 확보

새로운 모달 유형:

모달 템플릿 활용 확장 가능

공통 모달 동작 패턴 활용

11. 외부 시스템 연동 고려사항
11.1 백엔드 API 의존성
요청/응답 형식:

서버에서 정의한 데이터 형식 사용

클라이언트 측 파싱 및 검증 구현

변경에 대응하는 유연한 구조 설계

인증 메커니즘:

JWT 기반 토큰 인증 활용

토큰 만료 처리 및 갱신 로직 구현

인증 오류 일관성 있게 처리

11.2 환경 설정 관리
환경 변수 활용:

API URL 및 타임아웃 등 외부 설정 분리

개발/운영 환경 분리 용이성 확보

설정 중앙화로 일관성 유지

로깅 전략:

중요 이벤트 로깅

오류 상황 상세 기록

트러블슈팅 지원 구조

12. 사용자 시나리오별 구현 가이드
12.1 신규 사용자 로그인
초기 화면: 로그인 페이지 자동 표시

입력 과정: 사용자 ID, 비밀번호 입력 → 로그인 버튼 클릭

검증 과정: 입력값 기본 검증 → API 호출 → 인증 성공/실패 확인

성공 경로: 토큰 저장 → 사용자 정보 저장 → 대시보드 페이지 이동

실패 경로: 오류 메시지 표시 → 입력 필드 초기화/포커스

12.2 대시보드 조회 및 필터링
초기 로드: 현재 날짜 설정 → 데이터 자동 조회 → 테이블 표시

날짜 필터링: 날짜 범위 선택 → 조회 버튼 클릭 → 데이터 갱신

속성 필터링: 필터 설정 (종류/부서/창고) → 필터 적용 버튼 클릭 → 테이블 필터링

주문번호 검색: 주문번호 입력 → 검색 버튼 클릭 → 검색 결과 표시

12.3 주문 상세 조회 및 상태 변경
상세 조회: 테이블 행 클릭 → 상세 모달 표시 → 락 상태 확인

메모 입력: 메모 영역 입력 → 메모 저장 버튼 클릭 → API 호출 → 결과 표시

상태 변경: 상태 버튼 클릭 → 락 획득 → API 호출 → 상태 변경 → 락 해제 → 결과 표시

락 충돌: 다른 사용자가 락 보유 중 → 락 정보 표시 → 읽기 전용 모드 적용

12.4 배차 처리
대상 선택: 대기 상태 주문 체크박스 선택 → 배차 버튼 활성화 → 배차 버튼 클릭

기사 정보 입력: 배차 모달 표시 → 기사명, 연락처 입력 → 배차 완료 버튼 클릭

처리 과정: 다중 락 획득 → API 호출 → 배차 처리 → 락 해제 → 결과 표시

실패 처리: 배차 실패 → 오류 메시지 표시 → 입력 유지 상태로 재시도 가능

12.5 시각화 데이터 분석
배송 현황 차트:

차트 타입 선택 → 날짜 설정 → 새로고침 버튼 클릭

API 호출 → 데이터 수신 → 차트 및 통계 카드 갱신

시간대별 접수량 차트:

차트 타입 선택 → 날짜 설정 → 새로고침 버튼 클릭

API 호출 → 데이터 수신 → 차트 및 통계 카드 갱신

12.6 엑셀 데이터 다운로드 (관리자)
페이지 접근: 네비게이션 바에서 다운로드 메뉴 클릭 → 권한 확인 → 다운로드 페이지 이동

날짜 설정: 조회 기간 선택 → 다운로드 가능 날짜 범위 확인

다운로드 실행: Excel 다운로드 버튼 클릭 → 로딩 표시 → API 호출 → 파일 다운로드

결과 처리: 다운로드 성공 → 성공 알림 표시 / 실패 → 오류 메시지 표시

13. 결론 및 주요 고려사항
13.1 주요 설계 특징
단순성 우선: 과도한 추상화 없이 직관적 코드 구조 유지

명시적 상태 관리: 중앙화된 상태 저장소와 명확한 갱신 흐름

일관된 사용자 경험: 알림, 로딩, 오류 처리 패턴 통일

백엔드 인터페이스 격리: API 클라이언트를 통한 백엔드 의존성 관리

락 기반 동시성 제어: 비관적 락 메커니즘을 통한 동시 편집 제어

13.2 핵심 구현 원칙
기능 격리: 모든 기능은 독립적 모듈로 구현

명시적 액션: 모든 데이터 변경은 사용자 액션에 의해서만 발생

피드백 우선: 모든 작업에 명확한 사용자 피드백 제공

일관된 인터페이스: 모든 UI 요소는 일관된 패턴과 스타일 유지

확장 용이성: 새로운 기능 추가가 기존 코드에 최소한의 영향만 미치도록 설계

13.3 주의사항 및 제약사항
프레임워크 특성: Dash 기반 SPA 구조의 제약사항 이해 필요

상태 관리 복잡성: 중첩된 콜백 구조 이해 및 관리 필요

락 메커니즘 제약: 5분 고정 타임아웃, 자동 연장 없음

검증 책임: 주요 데이터 검증은 프론트엔드 책임으로 철저히 구현 필요

환경 의존성: 백엔드 API 인터페이스 변경에 민감한 구조

13.4 향후 개선 가능성
컴포넌트 재사용성 강화: 더 작은 단위의 재사용 가능한 컴포넌트 분리

반응형 디자인 개선: 다양한 화면 크기에 더 효과적으로 대응

성능 최적화: 대용량 데이터 처리 시 필요한 최적화 지점 개선

테스트 자동화: 주요 기능에 대한 자동화된 테스트 구현

사용성 개선: 사용자 피드백 기반 UI/UX 지속 개선

IV. 백엔드-프론트엔드 통합 인터페이스 명세서
1. API 인터페이스 정의
1.1 인증 관련 API
POST /auth/login

요청 형식: { "user_id": "사용자ID", "password": "비밀번호" }

응답 형식: { "success": true, "message": "로그인 성공", "token": { "access_token": "JWT토큰문자열", "refresh_token": "리프레시토큰문자열" }, "user": { "user_id": "사용자ID", "user_department": "CS|HES|LENOVO", "user_role": "ADMIN|USER" } }

POST /auth/refresh

요청 형식: { "refresh_token": "리프레시토큰문자열" }

응답 형식: { "success": true, "message": "토큰이 갱신되었습니다", "data": { "token": { "access_token": "새JWT토큰문자열", "refresh_token": "새리프레시토큰문자열" } } }

POST /auth/logout

요청 형식: { "refresh_token": "리프레시토큰문자열" }

응답 형식: { "success": true, "message": "로그아웃이 완료되었습니다" }

1.2 대시보드 관련 API
POST /dashboard/list

요청 형식: { "start_date": "YYYY-MM-DD", "end_date": "YYYY-MM-DD" }

응답 형식: { "success": true, "message": "데이터를 조회했습니다", "data": { "items": [ { "dashboard_id": 123, "order_no": "ORD12345", "type": "DELIVERY|RETURN", "status": "WAITING|IN_PROGRESS|COMPLETE|ISSUE|CANCEL", "department": "CS|HES|LENOVO", "warehouse": "SEOUL|BUSAN|GWANGJU|DAEJEON", "eta": "2023-03-15T14:30:00", "customer": "고객명", "region": "서울시 강남구 역삼동", "driver_name": "기사명" } ], "date_range": { "oldest_date": "2023-01-01", "latest_date": "2023-03-31" } } }

GET /dashboard/{dashboard_id}

응답 형식: { "success": true, "message": "상세 정보를 조회했습니다", "data": { "dashboard_id": 123, "order_no": "ORD12345", "type": "DELIVERY|RETURN", "status": "WAITING|IN_PROGRESS|COMPLETE|ISSUE|CANCEL", "department": "CS|HES|LENOVO", "warehouse": "SEOUL|BUSAN|GWANGJU|DAEJEON", "eta": "2023-03-15T14:30:00", "create_time": "2023-03-14T10:30:00", "depart_time": "2023-03-15T09:30:00", "complete_time": "2023-03-15T14:45:00", "postal_code": "12345", "city": "서울시", "county": "강남구", "district": "역삼동", "address": "상세주소", "customer": "고객명", "contact": "연락처", "driver_name": "기사명", "driver_contact": "기사연락처", "remarks": [ { "remark_id": 456, "content": "메모내용", "created_at": "2023-03-14T14:30:00", "created_by": "작성자ID" } ], "is_locked": false }, "is_locked": false, "lock_info": null }

PATCH /dashboard/{dashboard_id}/status

요청 형식: { "status": "WAITING|IN_PROGRESS|COMPLETE|ISSUE|CANCEL", "is_admin": false }

응답 형식: { "success": true, "message": "상태가 변경되었습니다", "data": { "dashboard_id": 123, "status": "IN_PROGRESS", "depart_time": "2023-03-15T09:30:00" } }

1.3 락 관련 API
POST /dashboard/{dashboard_id}/lock

요청 형식: { "lock_type": "EDIT|STATUS|ASSIGN|REMARK" }

응답 형식: { "success": true, "message": "락을 획득했습니다", "data": { "dashboard_id": 123, "locked_by": "사용자ID", "lock_type": "EDIT", "expires_at": "2023-03-15T15:30:00" } }

DELETE /dashboard/{dashboard_id}/lock

응답 형식: { "success": true, "message": "락을 해제했습니다", "data": { "dashboard_id": 123 } }

2. 공통 오류 코드 및 메시지
2.1 HTTP 상태 코드
200 OK: 요청 성공

400 Bad Request: 클라이언트 요청 오류

401 Unauthorized: 인증 실패 또는 토큰 만료

403 Forbidden: 권한 부족

404 Not Found: 리소스 없음

422 Unprocessable Entity: 데이터 검증 실패

423 Locked: 비관적 락 충돌

500 Internal Server Error: 서버 오류

2.2 오류 응답 형식
{ "success": false, "message": "사용자 친화적 오류 메시지", "error_code": "오류 코드", "timestamp": "2023-03-15T14:30:00" }

2.3 주요 오류 코드
UNAUTHORIZED: 인증 필요 또는 실패

INVALID_TOKEN: 유효하지 않은 토큰

TOKEN_EXPIRED: 만료된 토큰

FORBIDDEN: 권한 부족

NOT_FOUND: 리소스 없음

VALIDATION_ERROR: 데이터 검증 실패

RESOURCE_LOCKED: 락 충돌

INTEGRITY_ERROR: 데이터 무결성 위반

SERVER_ERROR: 서버 내부 오류

3. 유저 시나리오별 통합 흐름
3.1 로그인 및 인증 흐름
프론트엔드: 로그인 폼 표시 → 사용자 입력 → 기본 검증

백엔드: 사용자 인증 → 토큰 생성 → 응답 반환

프론트엔드: 토큰 저장 → 사용자 정보 저장 → 대시보드 이동

3.2 대시보드 조회 흐름
프론트엔드: 날짜 범위 설정 → API 요청

백엔드: 날짜 검증 → 데이터 쿼리 → 응답 구성

프론트엔드: 데이터 수신 → 테이블 렌더링 → 필터 적용

3.3 상태 변경 흐름
프론트엔드: 상태 버튼 클릭 → 락 획득 요청

백엔드: 락 상태 확인 → 락 생성 → 응답 반환

프론트엔드: 락 획득 확인 → 상태 변경 요청

백엔드: 상태 전이 검증 → 상태 변경 → 자동 시간 갱신 → 응답 반환

프론트엔드: 락 해제 요청 → 결과 표시

백엔드: 락 해제 → 응답 반환

3.4 비관적 락 충돌 처리 흐름
프론트엔드: 락 획득 요청

백엔드: 기존 락 확인 → 충돌 감지 → 423 Locked 응답

프론트엔드: 충돌 감지 → 락 소유자 정보 표시 → 읽기 전용 모드 활성화

4. 공통 데이터 정의
4.1 대시보드 객체 구조
{ "dashboard_id": "대시보드 ID (정수)", "order_no": "주문번호 (문자열)", "type": "종류 (DELIVERY|RETURN)", "status": "상태 (WAITING|IN_PROGRESS|COMPLETE|ISSUE|CANCEL)", "department": "부서 (CS|HES|LENOVO)", "warehouse": "창고 (SEOUL|BUSAN|GWANGJU|DAEJEON)", "sla": "SLA (문자열)", "eta": "예상도착시간 (ISO 8601 형식)", "create_time": "생성시간 (ISO 8601 형식)", "depart_time": "출발시간 (ISO 8601 형식, 선택적)", "complete_time": "완료시간 (ISO 8601 형식, 선택적)", "postal_code": "우편번호 (문자열)", "city": "도시 (문자열)", "county": "구/군 (문자열)", "district": "동/읍/면 (문자열)", "region": "지역 (city+county+district 조합)", "distance": "거리 (km, 정수)", "duration_time": "소요시간 (분, 정수)", "address": "상세주소 (문자열)", "customer": "고객명 (문자열)", "contact": "연락처 (문자열, 선택적)", "driver_name": "기사명 (문자열, 선택적)", "driver_contact": "기사연락처 (문자열, 선택적)", "created_by": "작성자 ID (문자열, 선택적)" }

4.2 공통 응답 구조
{ "success": "성공 여부 (boolean)", "message": "응답 메시지 (문자열)", "data": "응답 데이터 (객체, 배열, 또는 null)", "meta": "메타 정보 (선택적, 페이지네이션 등)" }

4.3 필터링 옵션
날짜 범위: start_date, end_date (YYYY-MM-DD 형식)

종류: type (ALL, DELIVERY, RETURN)

부서: department (ALL, CS, HES, LENOVO)

창고: warehouse (ALL, SEOUL, BUSAN, GWANGJU, DAEJEON)

상태: status (ALL, WAITING, IN_PROGRESS, COMPLETE, ISSUE, CANCEL)

5. 공통 제약사항 및 고려사항
5.1 성능 고려사항
대량 데이터 처리: 최근 1개월 데이터 위주 처리, 과거 데이터는 제한적 접근

응답 시간: 일반 조회 1초 이내, 대용량 다운로드 5초 이내 목표

API 타임아웃: 기본 10초, 다운로드는 20초로 설정

5.2 보안 고려사항
토큰 관리: 서버는 리프레시 토큰만 저장, 액세스 토큰은 클라이언트만 보유

인증 헤더: 모든 요청에 Authorization: Bearer {token} 헤더 필요

관리자 접근 제어: 삭제, 다운로드 등 특정 기능은 관리자 권한 검증

5.3 확장성 고려사항
데이터 구조 변경: 향후 필드 추가는 기존 클라이언트 호환성 보장

API 버전 관리: 현재 버전 고정, 향후 /api/v2/ 등으로 버전 관리 도입 가능

캐싱 전략: 시각화 데이터 등 자주 변경되지 않는 데이터 캐싱 검토

6. 개발 협업 가이드
6.1 개발 환경 설정
로컬 개발 환경: .env.local 파일 통해 공통 설정 관리

API URL 및 타임아웃: 프론트엔드와 백엔드 간 일치 필요

CORS 설정: 개발 단계에서는 모든 오리진 허용, 프로덕션에서는 제한 필요

6.2 테스트 전략
통합 테스트 시나리오: 주요 사용자 흐름 기반 시나리오 테스트

비관적 락 테스트: 다중 세션 환경에서 락 획득/해제/충돌 테스트

에러 케이스 테스트: 각 오류 유형에 대한 프론트엔드 처리 검증

6.3 배포 고려사항
도커 환경: 단일 컨테이너에 FastAPI와 Dash 함께 배포

환경 변수: 환경별 설정 분리 (.env.local, .env.prod)

로깅 구성: 프로덕션 환경에서 중요 이벤트 중심 로깅 설정

6.4 유지보수 고려사항
API 변경 사항: 변경 시 상호 영향 평가 및 공유

성능 모니터링: 주요 API 응답 시간 지속 모니터링

사용자 피드백: UI/UX 개선을 위한 사용자 피드백 수집 및 반영