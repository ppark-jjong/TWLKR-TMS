# 프로젝트 상세 동작 설명서

*기준 코드: main/routes/, main/service/, main/schema/ 등*
*렌더링 전략: 초기 SSR(첫 페이지) + 전체 데이터 CSR (대시보드, 인수인계 공통)*
*인증: 모든 보호된 라우트 접근 시 인증 확인 및 리디렉션 적용*
*스키마 변경 금지 : 기존에 있는 db 스키마와 model 필드들을 절대 수정하지 마세요
---

## Ⅰ. 프로젝트 개요 및 목표

| 구분            | 내용                           |
| ---- | ---- |
| **실시간 배송 관리** | ETA 기준 주문 조회·상태 관리           |
| **효율적 배차**    | 기사 배정·연락처 관리 일원화             |
| **권한 구분**     | USER / ADMIN 2‑레벨            |
| **UI 범위**     | 한국어, **데스크톱 전용** (모바일 미지원)   |
| **브랜드 컬러**    | `#D72519` (포인트·버튼·링크)        |
| **예상 부하**     | 동시 50 · TPS 100 · ≤ 100 MB/h |
| **렌더링 전략**    | 초기 SSR → 상호작용 CSR(필터·커스터마이징) |

---

## Ⅱ. 아키텍처 원칙 & 기술 스택

### 2.1 핵심 원칙

1. **SSR 우선 + CSR 보조** (SEO·초기 속도 확보)
2. **단일 레코드 = Form(PRG)**, **목록 = JSON**
3. **명시적 액션** – 자동화 최소화
4. **YAGNI** – 필요 기능만 구현
5. **서버 최종 검증, 클라이언트 실시간 검증**
6. **UI 일관성** – 상황별 UI/UX 패턴 통일
7. **자동 헬스체크 리로드 금지 ** - 무조건 사용자 명시적 액션을 통한 리로드만 가능, 자동 헬스체크 금지


### 2.2 기술 스택

| 레이어          | 스택                                             |
| --- | ---- |
| **Backend**  | Python 3.12 · FastAPI · Jinja2                 |
| **Frontend** | HTML / CSS / JS (+ Bootstrap·Tailwind 선택)      |
| **Database** | MySQL 8.0 (init‑db.sql)                        |
| **Infra**    | Docker( GAE Flexible ) · Cloud SQL(Private IP) |

## 보안 & 기타 운영 설정

- **HSTS**, **X‑Content‑Type‑Options**, **X‑Frame‑Options** 기본 적용.
- 쿠키 SameSite =Lax 로 CSRF 기본 방어, Ajax PUT 미사용.
- **Private IP** 연결 + Cloud SQL AuthProxy(로컬).
- 모든 시간 KST(UTC+9), 포맷 `YYYY‑MM‑DD HH:MM`.

---

## Ⅲ. 주요 데이터 처리 원칙 및 오류 방지 가이드

### 3.1 필드명 규칙

* **통일된 명명 규칙:** 백엔드 및 프론트엔드에서 **모든 필드명은 snake_case**로 통일
  * 예: `dashboard_id`, `order_no`, `create_time`, `update_at` 등
  * ❌ 피해야 할 사례: `dashboardId`, `orderNo`, `createTime` (camelCase 사용 금지)
* **불일치 방지:** 템플릿과 JavaScript에서 필드명 참조 시 백엔드에서 전달된 그대로 snake_case 사용
* **자동 변환 없음:** 백엔드-프론트엔드 간 camelCase ↔ snake_case 자동변환을 사용하지 않음

### 3.2 템플릿 데이터 전달 방식

* **Jinja2 템플릿으로 데이터 전달 시:**
  ```python
  # 예시: Python 딕셔너리를 템플릿 컨텍스트로 직접 전달
  context = {
      "initial_data": data_dict,  # 직접 딕셔너리 전달 (JSON 문자열 아님)
      "current_user": user_data
  }
  return templates.TemplateResponse("template.html", context)
  ```

* **템플릿에서 JavaScript로 데이터 전달 시:**
  ```html
  <!-- Jinja2 tojson 필터 사용 -->
  <script>
    var initialData = {{ initial_data|tojson|safe }};
  </script>
  ```

* **오류 방지:** 직접 JSON 문자열 생성 대신 `tojson` 필터 사용 권장

### 3.3 자주 발생하는 오류와 해결 방법

* **JSON 파싱 오류:**
  * 원인: 서버에서 잘못된 JSON 문자열 생성 또는 템플릿에서 부적절한 JSON 처리
  * 해결: `CustomJSONEncoder` 대신 Python 딕셔너리를 직접 전달하고 `tojson` 필터 사용
  
* **필드명 불일치 오류:**
  * 원인: JavaScript에서 camelCase로 참조 시도 vs 서버에서는 snake_case 사용
  * 해결: 모든 필드명을 snake_case로 통일하고 JavaScript에서도 동일하게 사용
  
* **날짜/시간 처리 오류:**
  * 원인: datetime 객체의 직접 직렬화 시도
  * 해결: Python에서 datetime을 ISO 형식 문자열로 변환 후 전달

* **Form 제출 관련 오류:**
  * 주문 생성: GET `/orders/new` 페이지 로드 → POST `/api/orders` 데이터 처리 (정확한 action 속성 설정)
  * 주문 수정: GET `/orders/{id}/edit` 페이지 로드 → POST `/api/orders/{id}` 데이터 처리

---

## 0. 공통 사항

*   **인증:** 아래 명시된 엔드포인트 중 `/login`, `/logout` 및 정적 파일(`/static/...`)을 제외한 **모든 페이지 및 API 접근 시** 서버 측에서 사용자 세션 유효성을 검증합니다. (예: 각 라우터의 `dependencies=[Depends(get_current_user)]` 또는 `Depends(get_admin_user)` 적용)
    *   **인증 실패 시:** 전역 401 예외 핸들러가 사용자를 즉시 로그인 페이지 (`/login`)로 리다이렉트합니다. (`return_to` 쿼리 파라미터 포함)
    *   **권한:** 특정 기능(예: 사용자 관리, 주문 삭제)은 `Depends(get_admin_user)`를 통해 ADMIN 역할만 접근 가능하도록 제한합니다. 권한 부족 시 403 Forbidden 오류를 반환합니다.
*   **락(Lock) 메커니즘:** 주문 및 인수인계 데이터의 동시 수정을 방지하기 위해 `is_locked` (BOOLEAN), `locked_by` (VARCHAR), `locked_at` (DATETIME) 필드를 사용합니다. (`update_by`, `update_at`은 이제 실제 데이터 변경자/시간 기록에만 사용됩니다.)
    *   **수정 페이지 로드 시 락 획득:** 사용자가 수정 버튼 클릭 시 (`GET /orders/{id}/edit`, `GET /handover/{id}/edit`) **서버 라우트 핸들러 내부에서** 해당 레코드의 `is_locked` 상태를 확인하고 **락 획득을 시도**(`acquire_lock` 유틸리티 사용)합니다.
        *   **락 성공:** `is_locked`를 `True`로, `locked_by`를 현재 사용자 ID로, `locked_at`을 현재 시간으로 변경하고 수정 페이지(`order_form.html` 또는 `handover_form.html`)를 정상적으로 반환합니다. **락은 수정이 완료되거나 사용자가 수정을 취소할 때까지 유지됩니다.**
        *   **락 실패:** 이미 `is_locked`가 `True`이고 현재 사용자의 락이 아닌 경우, 사용자를 **상세 페이지로 리다이렉트**하고 URL 쿼리 파라미터로 표준 오류 메시지 (`?error=현재 다른 사용자({locked_by})가 {locked_at_str}부터 수정 중입니다`)를 전달합니다. (락 타임아웃 발생 시에는 락 해제 후 획득 시도)
    *   **수정/삭제 처리 시 락 점검:** `POST /api/orders/{id}`, `POST /api/orders/{id}/delete`, `POST /api/handover/{id}`, `POST /api/handover/{id}/delete` 등의 요청 처리 시, **해당 서비스 함수 내부에서** 먼저 **락 상태를 점검** (`check_lock_status` 유틸리티 사용)하여 현재 요청 사용자가 락을 소유하고 있는지 확인합니다.
        *   **락 소유 확인:** 요청자가 락을 소유한 경우에만 작업을 계속 진행합니다.
        *   **락 소유 실패:** HTTP **423 Locked** 상태 코드와 함께 오류 메시지 (`{ "success": false, "message": "현재 다른 사용자({locked_by})가 수정 중이거나 락이 만료되었습니다. 다시 시도해주세요." }`)를 JSON으로 반환합니다.
    *   **락 타임아웃:** 모든 락은 5분 후 자동으로 만료됩니다 (`LOCK_TIMEOUT_SECONDS=300`). 만료된 락은 다른 사용자가 획득할 수 있습니다.
    *   **수정 페이지에서의 락 관리:**
        *   **락 자동 갱신:** 클라이언트 JavaScript가 2분마다 `/api/orders/{id}/renew-lock` API를 호출하여 락 만료를 방지합니다.
        *   **페이지 이탈 시 락 해제:** 사용자가 수정 페이지를 떠날 때 (브라우저 닫기, 다른 페이지로 이동, 뒤로가기 등) `beforeunload` 이벤트를 통해 `/api/orders/{id}/unlock` API를 호출하여 락을 즉시 해제합니다.
        *   **락 충돌 감지:** 클라이언트가 2분마다 `/api/orders/lock/{id}` API로 락 상태를 확인하여, 다른 사용자가 락을 획득한 경우 경고 메시지를 표시하고 폼을 읽기 전용으로 변경합니다.
    *   **작업 완료 후 락 해제:** 수정 또는 삭제 작업이 성공하거나 실패한 경우, **서비스 함수 또는 라우트 핸들러의 `finally` 블록 등에서 반드시 락을 해제** (`release_lock` 유틸리티 사용, `is_locked`를 `False`로, `locked_by`와 `locked_at`을 `NULL`로 변경)합니다.
    *   **중요: 모든 필드 수정은 수정 페이지에서만 가능합니다.** 인라인 필드 수정 기능은 구현하지 않습니다.
*   **오류 처리:** API 호출 실패 시 표준화된 JSON 응답 (`{ "success": false, "message": "오류 내용", "error_details": "..." }`) 및 적절한 HTTP 상태 코드를 반환합니다. 페이지 로드 실패 시 `error.html` 템플릿을 렌더링하거나, 관련 페이지로 리다이렉트하며 오류 메시지를 쿼리 파라미터로 전달합니다.
*   **알림 기능:** 사용자 액션(생성, 수정, 삭제, 복사 등) 결과 및 락 경고는 **클라이언트 JavaScript**를 통해 알림창으로 표시됩니다.
    *   **서버 응답 (리다이렉션):** 서버는 Form 처리 후 리다이렉션 시 URL 쿼리 파라미터(`?success=...`, `?error=...`)에 메시지를 담아 전달합니다.
    *   **서버 응답 (JSON):** API 엔드포인트는 성공/실패 여부와 메시지를 JSON으로 반환합니다. (예: 락 실패 시 423 응답)
    *   **클라이언트 처리:** 페이지 로드 시 JavaScript(`order_detail.js`, `handover_detail.js` 등)가 URL 쿼리 파라미터를 확인하거나, API 호출 응답(JSON)을 분석하여 `Utils.alerts` 함수를 호출, 알림을 표시합니다. 클라이언트 액션(예: 복사) 결과는 해당 이벤트 핸들러에서 직접 `Utils.alerts`를 호출합니다.
*   **시간:** 모든 시간은 KST (UTC+9) 기준이며, `YYYY-MM-DDTHH:MM` 형식(ISO 8601)으로 표시/처리됩니다. 무조건 해당 방식으로 통일하세요. 이는 HTML, JavaScript, Python 모두에서 효율적인 처리를 위한 표준입니다.
*   **로깅:** 각 동작 포인트별 디버깅에 용이하게 표준 `logging` 라이브러리를 활용한 로그를 구현합니다. (기존 `logger.py` 사용 로직 제거)
*   **JSON 필드 규칙:** API 응답과 클라이언트 간의 데이터 전송 시 **snake_case** 필드명을 사용합니다(예: `dashboard_id`). 클라이언트 JavaScript에서도 동일한 snake_case 필드명을 사용해야 합니다.

## 1. 인증 (Authentication)

### 1.1 로그인 (`/login` - 페이지 및 처리)

*   **페이지 로드:** `GET /login` (HTML 응답)
*   **로그인 처리:**
    *   **HTTP Method:** `POST`
    *   **경로:** `/login`
    *   **전송 방식:** **Form** (`application/x-www-form-urlencoded`)
    *   **요청 필드:** `user_id` (문자열, 필수), `password` (문자열, 필수)
    *   **인증:** 없음
    *   **응답:** 성공 시 `/dashboard` 리다이렉트 (세션 쿠키 `session` 설정), 실패 시 로그인 페이지(`/login`)에 오류 메시지 표시.
    *   **동작:** 사용자 인증 (DB 조회 및 비밀번호 검증) 후 성공 시 세션 생성 및 대시보드 리다이렉트, 실패 시 오류 메시지 표시.

### 1.2 로그아웃 (`/logout`)

*   **HTTP Method:** `POST` (CSRF 방어)
*   **경로:** `/logout`
*   **전송 방식:** **Form**
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **응답:** `/login` 페이지로 리다이렉트 (세션 쿠키 제거 또는 무효화).
*   **동작:** 현재 세션 무효화 후 로그인 페이지로 리다이렉트.

---

## 2. 주문 관리 (Dashboard/Order) - `dashboard_route.py`, `order_routes.py`

### 2.1 대시보드 페이지 초기 로드 (`/dashboard`)

*   **HTTP Method:** `GET`
*   **경로:** `/dashboard`
*   **전송 방식:** HTML (SSR - **기본 구조만 렌더링, 데이터 미포함**)
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 파라미터 (Query):** 없음 (초기 로드 시)
*   **응답:**
    *   `dashboard.html` 템플릿 렌더링 (빈 테이블 구조)
    *   `current_user` (세션 정보)
*   **동작 설명:** 인증 확인 -> 기본 HTML 템플릿(`dashboard.html`) 렌더링. 페이지 로드 후 클라이언트 **JavaScript(`dashboard.js`)가 즉시 `/api/dashboard/list` API를 호출**하여 기본 날짜 범위의 데이터를 가져와 CSR 방식으로 테이블을 채웁니다.

### 2.2 주문 목록 조회 API (`/api/dashboard/list`)

*   **HTTP Method:** `GET`
*   **경로:** `/api/dashboard/list`
*   **전송 방식:** **JSON**
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 파라미터 (Query):** `start_date` (필수), `end_date` (필수) - 클라이언트에서 날짜 범위를 지정하여 전송
*   **응답:** (`DashboardListResponse` JSON, snake_case 필드명 - **지정된 날짜 범위 내 모든 주문 데이터 포함**)
*   **동작:** 인증 확인 -> `get_dashboard_list` 서비스 호출 (지정된 날짜 범위 기준, **페이지네이션 없음**) -> JSON 응답. 클라이언트 JavaScript는 이 데이터를 받아 화면 렌더링, 필터링, 페이지네이션을 처리합니다.

### 2.3 주문번호 검색 API (`/api/dashboard/search`)

*   **HTTP Method:** `GET`
*   **경로:** `/api/dashboard/search`
*   **전송 방식:** **JSON**
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 파라미터 (Query):** `order_no`
*   **응답:** (JSON - `{success, message, data: {order: DashboardListItem | null}}`)
*   **동작:** 인증 확인 -> `search_dashboard_by_order_no` 호출 (단일 검색) -> JSON 응답.

### 2.4 주문 상세 페이지 조회 (`/orders/{id}`)

*   **HTTP Method:** `GET`
*   **경로:** `/orders/{id}`
*   **전송 방식:** HTML (SSR)
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 파라미터 (Path):** `id`
*   **응답:** `order_page.html` 렌더링 (`order` 객체, `current_user` 포함)
*   **동작 설명:** 인증 확인 -> `get_dashboard_by_id` 호출 -> 템플릿 렌더링. **페이지 관련 JavaScript 로직(상태 수정 등)은 `main/static/js/order_detail.js` 파일에 분리되어 있으며, 템플릿에서 해당 파일을 로드합니다.**

### 2.5 주문 생성 처리 (`/api/orders`)

*   **HTTP Method:** `POST`
*   **경로:** `/api/orders`
*   **전송 방식:** **Form**
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 필드:** `order_no`, `type`, `department`, ... , `remark`(선택) - HTML form 필드명은 모두 snake_case
*   **응답:** 성공 시 `/orders/{new_id}` 리다이렉트 (성공 메시지 포함), 실패 시 오류 응답 또는 리다이렉트 (오류 메시지 포함).
*   **동작:** 인증 확인 -> Form 데이터 유효성 검증 -> `create_dashboard` 서비스 호출 -> 성공 시 리다이렉트.

### 2.6 주문 수정 페이지 로드 (`/orders/{id}/edit`)

*   **HTTP Method:** `GET`
*   **경로:** `/orders/{id}/edit`
*   **전송 방식:** HTML (SSR)
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 파라미터 (Path):** `id`
*   **응답:**
    *   **락 성공:** `order_form.html` 렌더링 (`order` 정보 등 포함)
    *   **락 실패:** `/orders/{id}` 로 리다이렉트 + 알림 메시지 (`?error=현재 다른 사용자가 수정 중입니다`)
*   **동작:** 인증 확인 -> `get_dashboard_by_id` 호출 -> 서버 내부에서 락 획득 시도 (`acquire_lock`) -> 성공 시 템플릿 렌더링, 실패 시 상세 페이지로 리다이렉트.

### 2.7 주문 수정 처리 (`/api/orders/{id}`)

*   **HTTP Method:** `POST`
*   **경로:** `/api/orders/{id}`
*   **전송 방식:** **Form**
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 파라미터 (Path):** `id`
*   **요청 필드:** `type`, `department`, ..., `status`(선택), `driver_name`(선택), `driver_contact`(선택) - HTML form 필드명은 snake_case
*   **응답:** 성공 시 `/orders/{id}` 리다이렉트 (성공 메시지 포함), 실패 시 (락 실패 포함) 오류 응답 또는 리다이렉트 (오류 메시지 포함).
*   **동작:** 인증 확인 -> 서비스 함수 내부에서 락 획득 시도 (`acquire_lock`) -> 실패 시 423 Locked 또는 리다이렉트 -> 성공 시 Form 데이터 유효성 검증 -> `update_dashboard` 서비스 호출 (상태 변경 로직 포함) -> 작업 완료 후 락 해제 (`release_lock`) -> 성공 시 리다이렉트.

### 2.8 주문 삭제 처리 (`/api/orders/{id}/delete`)

*   **HTTP Method:** `POST`
*   **경로:** `/api/orders/{id}/delete`
*   **전송 방식:** **Form**
*   **인증:** 필요 (`Depends(get_admin_user)`)
*   **권한:** **ADMIN**
*   **요청 파라미터 (Path):** `id`
*   **응답:** 성공 시 `/dashboard` 리다이렉트 (성공 메시지 포함), 실패 시 (락 실패 포함) `/orders/{id}` 리다이렉트 (오류 메시지 포함).
*   **동작:** 인증/권한 확인 -> 서비스 함수 내부에서 락 획득 시도 (`acquire_lock`) -> 실패 시 423 Locked 또는 리다이렉트 -> 성공 시 `delete_dashboard` 서비스 호출 -> 작업 완료 후 락 해제 (`release_lock`) -> 성공/실패에 따라 리다이렉트.

---

## 3. 인수인계 (Handover) - `handover_route.py`

### 3.1 인수인계 페이지 로드 (`/handover`)

*   **HTTP Method:** `GET`
*   **경로:** `/handover`
*   **전송 방식:** HTML (SSR - **기본 구조만 렌더링, 데이터 미포함**)
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 파라미터 (Query):** 없음 (초기 로드 시)
*   **응답:** `handover.html` 렌더링 (빈 테이블 구조), `current_user` 포함
*   **동작 설명:** 인증 확인 -> 기본 HTML 템플릿(`handover.html`) 렌더링. 페이지 로드 후 **클라이언트 JavaScript(`main/static/js/handover.js`)가 즉시 `/api/handover/list` API를 호출**하여 전체 인수인계/공지사항 데이터를 가져와 CSR 방식으로 테이블을 채웁니다. **페이지 관련 모든 JavaScript 로직은 `handover.js` 파일에 분리되어 있으며, 템플릿에서 해당 파일을 로드합니다.**

### 3.2 인수인계 목록 조회 API (`/api/handover/list`)

*   **HTTP Method:** `GET`
*   **경로:** `/api/handover/list`
*   **전송 방식:** **JSON**
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 파라미터 (Query):** `is_notice` (boolean, 선택 - 공지사항/일반 인수인계 구분, 미지정 시 전체 반환 가정)
*   **응답:** (JSON - `{success, message, data: List[HandoverListItem]}` - **조건에 맞는 모든 데이터**)
*   **동작:** 인증 확인 -> `get_handover_list_all` 서비스 호출 (DB에서 조건에 맞는 전체 목록 조회) -> JSON 응답. 클라이언트 JavaScript는 이 데이터를 받아 화면 렌더링 및 필터링('전체', '공지', '인수인계' 탭)을 처리합니다.

### 3.3 인수인계 상세 페이지 조회 (`/handover/{id}`)

*   **HTTP Method:** `GET`
*   **경로:** `/handover/{id}`
*   **전송 방식:** HTML (SSR)
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **응답:** `handover_detail.html` 렌더링 (`handover` 객체, `current_user` 포함)
*   **동작:** 인증 확인 -> `get_handover_by_id` 호출 -> 템플릿 렌더링.
*   **참고사항:** 인수인계 상세에는 제목, 내용, 공지사항 여부, 생성자, 업데이트 정보가 표시되며, "확인 완료" 기능은 실제로 구현되지 않음.

### 3.4 인수인계 생성 페이지 로드 (`/handover/new`)

*   **HTTP Method:** `GET`
*   **경로:** `/handover/new`
*   **전송 방식:** HTML (SSR)
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **응답:** `handover_form.html` 렌더링 (ADMIN 사용자는 공지사항 설정 옵션이 표시됨)
*   **동작:** 인증 확인 -> 생성 폼 렌더링 (ADMIN 사용자에게만 `is_notice` 체크박스 표시).

### 3.5 인수인계 생성 처리 (`/api/handover`)

*   **HTTP Method:** `POST`
*   **경로:** `/api/handover`
*   **전송 방식:** **Form**
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 필드:** `title`, `content`, `is_notice`
*   **응답:** 성공 시 `/handover/{new_id}` 리다이렉트 (성공 메시지 포함), 실패 시 오류 응답 또는 리다이렉트 (오류 메시지 포함).
*   **동작:** 인증 확인 -> (공지사항 설정 시 ADMIN 권한 확인) -> `create_handover` 서비스 호출 -> 성공 시 리다이렉트.
*   **참고사항:** 공지사항으로 설정(`is_notice=true`)은 ADMIN 사용자만 가능하며, 일반 사용자가 시도할 경우 권한 오류 발생.

### 3.6 인수인계 수정 페이지 로드 (`/handover/{id}/edit`)

*   **HTTP Method:** `GET`
*   **경로:** `/handover/{id}/edit`
*   **전송 방식:** HTML (SSR)
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 파라미터 (Path):** `id`
*   **응답:**
    *   **락 성공 & 권한 있음:** `handover_form.html` 렌더링 (`handover` 정보 등 포함)
    *   **락 실패 또는 권한 없음:** `/handover/{id}` 로 리다이렉트 + 알림 메시지 (`?error=...`)
*   **동작:** 인증 확인 -> `get_handover_by_id` 호출 -> 작성자 또는 ADMIN 권한 확인 -> **서버 내부에서 락 획득 시도 (`acquire_lock`)** -> 성공 시 템플릿 렌더링, 실패 시 상세 페이지로 리다이렉트.

### 3.7 인수인계 수정 처리 (`/api/handover/{id}`)

*   **HTTP Method:** `POST`
*   **경로:** `/api/handover/{id}`
*   **전송 방식:** **Form**
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **요청 필드:** `title`, `content`, `is_notice`
*   **응답:** 성공 시 `/handover/{id}` 리다이렉트 (성공 메시지 포함), 실패 시 (락 실패 포함) 오류 응답 또는 리다이렉트 (오류 메시지 포함).
*   **동작:** 인증 확인 -> (작성자 또는 ADMIN 권한 확인) -> (공지사항 변경 시 ADMIN 권한 확인) -> **서비스 함수 내부에서 락 획득 시도 (`acquire_lock`)** -> 실패 시 423 Locked 또는 리다이렉트 -> 성공 시 `update_handover` 서비스 호출 -> **작업 완료 후 락 해제 (`release_lock`)** -> 성공 시 리다이렉트.
*   **참고사항:** 
     * 수정은 원래 작성자와 ADMIN만 가능
     * 공지사항 여부 변경(`is_notice` 값 변경)은 ADMIN만 가능

### 3.8 인수인계 삭제 처리 (`/api/handover/{id}/delete`)

*   **HTTP Method:** `POST`
*   **경로:** `/api/handover/{id}/delete`
*   **전송 방식:** **Form**
*   **인증:** 필요 (`Depends(get_current_user)`)
*   **권한:** 작성자 본인 또는 ADMIN (서비스 내 확인)
*   **응답:** 성공 시 `/handover` 리다이렉트 (성공 메시지 포함), 실패 시 (락 실패 포함) `/handover/{id}` 리다이렉트 (오류 메시지 포함).
*   **동작:** 인증 확인 -> **서비스 함수 내부에서 락 획득 시도 (`acquire_lock`)** -> 실패 시 423 Locked 또는 리다이렉트 -> 성공 시 권한 확인 (작성자 또는 ADMIN 확인) -> `delete_handover` 서비스 호출 -> **작업 완료 후 락 해제 (`release_lock`)** -> 성공/실패에 따라 리다이렉트.

---

## 4. 사용자 관리 (Admin 전용) - `users_route.py`

*   **기본 페이지 경로:** `/admin/users`
*   **기본 API 경로:** `/api/admin/users`
*   **인증:** 모든 경로 ADMIN 권한 필요 (`Depends(get_admin_user)`).

### 4.1 사용자 목록 조회 페이지 (`/admin/users`)
*   **HTTP Method:** `GET`, **전송:** HTML(SSR), **응답:** `users.html`
*   **동작:** ADMIN 확인 -> `get_user_list` 호출 -> 템플릿 렌더링.

### 4.2 사용자 생성 처리 (`/api/admin/users`)
*   **HTTP Method:** `POST`