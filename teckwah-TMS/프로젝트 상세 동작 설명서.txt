# 프로젝트 상세 동작 설명서

*기준 문서: 프로젝트 기본 설명서.txt *
*기준 코드: main/routes/, main/service/, main/schema/ 등*
*렌더링 전략: 초기 SSR(첫 페이지) + 전체 데이터 CSR (대시보드, 인수인계 공통)*
*인증: 모든 보호된 라우트 접근 시 인증 확인 및 리디렉션 적용*
*스키마 변경 금지 : 기존에 있는 db 스키마와 model 필드들을 절대 수정하지 마세요요
---

## 0. 공통 사항

*   **인증:** 아래 명시된 엔드포인트 중 `/login`, `/logout` 및 정적 파일(`/static/...`)을 제외한 **모든 페이지 및 API 접근 시** 서버 측에서 사용자 세션 유효성을 검증합니다. (예: `Depends(get_current_user)` 의존성 주입 또는 미들웨어 활용)
    *   **인증 실패 시:** 사용자를 즉시 로그인 페이지 (`/login`)로 리다이렉트합니다.
    *   **권한:** 특정 기능(예: 사용자 관리, 주문 삭제)은 세션에 저장된 사용자 역할(`role`)을 추가로 확인하여 ADMIN만 접근 가능하도록 제한합니다. 권한 부족 시 403 Forbidden 오류 또는 적절한 메시지를 반환합니다.
*   **락(Lock) 메커니즘:** 주문 및 인수인계 데이터의 동시 수정을 방지하기 위해, 수정/삭제/상태변경/기사배정 등 **데이터 변경 작업 전에는 반드시 해당 레코드에 대한 락을 획득**하고, 작업 완료 또는 실패 시 **락을 해제**하는 로직이 서버(`service` 계층)에 구현됩니다. 락 획득 실패 시 (다른 사용자가 편집 중) HTTP 423 Locked 상태 코드 및 오류 메시지를 반환합니다.
*   **오류 처리:** API 호출 실패 시 표준화된 JSON 응답 (`{ "success": false, "message": "오류 내용", "error_details": "..." }`) 및 적절한 HTTP 상태 코드를 반환합니다.
*   **시간:** 모든 시간은 KST (UTC+9) 기준이며, `YYYY-MM-DD HH:MM` 형식으로 표시/처리됩니다. 무조건 해당 방식으로 통일하세요
*   **로깅:** 각 동작 포인트별 디버깅에 용이하게 logging 라이브러리를 활용한 간략한 로그를 같이 구현하세요 만약 기존에 있던 logger.py를 사용하는 로직을 확인 후 삭제하고 logging으로 변경하세요

## 1. 인증 (Authentication)

### 1.1 로그인 (`/login`)

*   **HTTP Method:** `POST`
*   **전송 방식:** **Form** (`application/x-www-form-urlencoded`)
*   **요청 필드:** `user_id` (문자열, 필수), `password` (문자열, 필수)
*   **인증:** 없음 (로그인 자체는 인증 불필요)
*   **응답:** 성공 시 `/dashboard` 리다이렉트 (세션 쿠키 `session` 설정 - `user_id`, `role` 등 포함), 실패 시 로그인 페이지(`/login`)에 오류 메시지 표시.
*   **동작:** 사용자 인증 (DB 조회 및 비밀번호 검증) 후 성공 시 세션 생성 및 대시보드 리다이렉트, 실패 시 오류 메시지 표시.

### 1.2 로그아웃 (`/logout`)

*   **HTTP Method:** `POST` (CSRF 방어)
*   **전송 방식:** **Form**
*   **인증:** 필요 (로그인된 사용자만 로그아웃 가능)
*   **응답:** `/login` 페이지로 리다이렉트 (세션 쿠키 제거 또는 무효화).
*   **동작:** 현재 세션 무효화 후 로그인 페이지로 리다이렉트.

---

## 2. 대시보드 (주문 관리)

### 2.1 대시보드 페이지 초기 로드 (`/dashboard`)

*   **HTTP Method:** `GET`
*   **전송 방식:** HTML (Server-Side Rendering - **첫 페이지 데이터 포함**)
*   **인증:** 필요
*   **요청 파라미터 (Query):**
    *   `start_date` (선택): 초기 조회 시작일 (YYYY-MM-DD), 없으면 오늘 날짜
    *   `end_date` (선택): 초기 조회 종료일 (YYYY-MM-DD), 없으면 오늘 날짜
*   **응답:**
    *   `dashboard.html` 템플릿 렌더링
    *   `initial_data` (컨텍스트 변수):
        *   `orders`: 조회된 날짜 기준 **첫 30개** 주문 목록 (`DashboardListItem` 형식의 객체 리스트, ETA 내림차순 정렬)
        *   `pagination`: 초기 페이지 정보 (totalCount: 전체 개수, page: 1, pageSize: 30, totalPages)
        *   `start_date`, `end_date`: 실제 적용된 조회 날짜 (ISO 형식, YYYY-MM-DD)
        *   `error_message` (선택): 날짜 범위 오류 등 메시지
    *   `current_user`: 현재 로그인 사용자 정보 (세션에서 가져옴)
*   **동작 설명:**
    1.  인증 확인.
    2.  요청 파라미터 또는 오늘 날짜 기준으로 조회 날짜 범위를 확정합니다.
    3.  **페이지네이션 지원 서비스 함수** (`get_dashboard_list_paginated` - 별도 구현 또는 기존 함수 수정 필요)를 호출하여, 확정된 날짜 범위 내 주문 데이터를 ETA 기준 내림차순으로 정렬하여 **첫 30개**(`initial_page_size`)와 **전체 데이터 개수**를 가져옵니다.
    4.  전체 데이터 개수를 사용하여 초기 페이지네이션 정보 (`pagination`)를 계산합니다.
    5.  조회된 첫 30개 데이터 (`orders`)와 페이지 정보, 날짜, 사용자 정보를 컨텍스트에 담아 `dashboard.html` 템플릿을 렌더링합니다.
    6.  클라이언트 JS는 이 `initial_data`를 사용하여 초기 화면을 구성하고, 이후 전체 데이터 로드를 준비합니다.

### 2.2 주문 목록 조회 API (`/dashboard/list`)

*   **HTTP Method:** `GET`
*   **전송 방식:** **JSON**
*   **인증:** 필요
*   **요청 파라미터 (Query):** `start_date` (필수, YYYY-MM-DD), `end_date` (필수, YYYY-MM-DD)
*   **응답:** (`DashboardListResponse` 스키마 기반)
    *   `success` (boolean)
    *   `message` (string)
    *   `data`: 해당 날짜 범위의 **모든** 주문 목록 (`DashboardListItem` 객체 리스트, ETA 내림차순)
        *   필드: `dashboardId`, `orderNo`, `type`, `department`, `warehouse`, `sla`, `region`, `eta`, `customer`, `status`, `driverName`
*   **동작:** 인증 확인 -> 날짜 유효성 검사 -> `dashboard_service.get_dashboard_list` (페이지네이션 없음) 호출하여 전체 데이터 조회 -> JSON 응답.

### 2.3 주문번호 검색 API (`/dashboard/search`)

*   **HTTP Method:** `GET`
*   **전송 방식:** **JSON**
*   **인증:** 필요
*   **요청 파라미터 (Query):** `order_no` (필수, 문자열, 앞뒤 공백 자동 제거)
*   **응답:**
    *   `success` (boolean)
    *   `message` (string)
    *   `data`: `{ "order": DashboardListItem | null }` (페이지네이션 없음)
*   **동작:** 인증 확인 -> `order_no` 공백 제거 및 유효성 검사 -> `dashboard_service.search_dashboard_by_order_no` (단일 검색) 호출 -> 결과(객체 또는 null)를 JSON 응답.

### 2.4 주문 상세 페이지 조회 (`/orders/{id}`)

*   **HTTP Method:** `GET`
*   **전송 방식:** HTML (SSR)
*   **인증:** 필요
*   **요청 파라미터 (Path):** `id` (정수)
*   **응답:** `order_detail.html` 렌더링 (`order` 상세 정보, `lock_info`, `current_user` 포함)
*   **동작:** 인증 확인 -> ID로 주문 조회 (`get_dashboard_by_id`) -> 락 상태 확인 (`get_lock_status`) -> 상세 페이지 템플릿 렌더링.

### 2.5 주문 생성 (`/orders`)

*   **HTTP Method:** `POST`
*   **전송 방식:** **Form**
*   **인증:** 필요
*   **요청 필드:** 주문 정보 (`DashboardCreate` 스키마 기반, `remark`, `contact` 외 필수)
    *   `orderNo`, `type`, `department`, `warehouse`, `sla`, `eta`, `postalCode`, `address`, `customer`, `contact`(선택), `remark`(선택)
*   **응답:** 성공 시 `/orders/{new_id}` 리다이렉트, 실패 시 생성 폼 재표시 (오류 메시지 포함)
*   **동작:** 인증 확인 -> Form 데이터 유효성 검증 (`DashboardCreate`) -> `create_dashboard` 서비스 호출 (DB 생성) -> 성공 시 리다이렉트.

### 2.6 주문 수정 (`/orders/{id}`)

*   **HTTP Method:** `POST`
*   **전송 방식:** **Form**
*   **인증:** 필요
*   **요청 파라미터 (Path):** `id` (정수)
*   **요청 필드:** 주문 정보 (`DashboardUpdate` 스키마 기반, `remark`, `contact` 외 필수 - **생성과 필드 동일**)
*   **응답:** 성공 시 `/orders/{id}` 리다이렉트, 실패 시 수정 폼 재표시 (오류 메시지 포함)
*   **동작:** 인증 확인 -> **락 획득** (`acquire_lock`) -> Form 데이터 유효성 검증 (`DashboardUpdate`) -> `update_dashboard` 서비스 호출 (DB 업데이트) -> **락 해제** (`release_lock`) -> 성공 시 리다이렉트.

### 2.7 주문 삭제 (`/orders/{id}/delete`)

*   **HTTP Method:** `POST`
*   **전송 방식:** **Form**
*   **인증:** 필요
*   **권한:** **ADMIN**
*   **요청 파라미터 (Path):** `id` (정수)
*   **응답:** 성공 시 `/dashboard` 리다이렉트, 실패 시 오류 처리 (예: 이전 페이지 리다이렉트 + 메시지)
*   **동작:** 인증 및 ADMIN 권한 확인 -> **락 획득** (`acquire_lock`) -> `delete_dashboard` 서비스 호출 (DB 삭제) -> (락 자동 해제됨) -> 성공 시 리다이렉트.

### 2.8 주문 상태 변경 (상세 페이지 내)

*   **API Endpoint:** `/orders/{id}/status` (예시)
*   **HTTP Method:** `POST` (Form 가정)
*   **인증:** 필요
*   **요청 파라미터 (Path):** `id` (정수)
*   **요청 필드:** `status` (문자열, 새 상태 값)
*   **응답:** 성공 시 상세 페이지 리로드 또는 AJAX 성공 메시지, 실패 시 오류 메시지 (상세 페이지 내 표시)
*   **동작:** 인증 확인 -> **락 획득** -> `change_status` 서비스 호출 (상태 전이 규칙 검증, `status` 및 관련 시간 필드 업데이트) -> **락 해제** -> 성공/실패 응답.

### 2.9 기사 배정/변경 (상세 페이지 내)

*   **API Endpoint:** `/orders/{id}/driver` (예시)
*   **HTTP Method:** `POST` (Form 가정)
*   **인증:** 필요
*   **요청 파라미터 (Path):** `id` (정수)
*   **요청 필드:** `driver_name` (문자열, 필수), `driver_contact` (문자열, 선택)
*   **응답:** 성공 시 상세 페이지 리로드 또는 AJAX 성공 메시지, 실패 시 오류 메시지 (상세 페이지 내 표시)
*   **동작:** 인증 확인 -> **락 획득** -> `assign_driver` 서비스 호출 (`driver_name`, `driver_contact` 필드 업데이트) -> **락 해제** -> 성공/실패 응답.

### 2.10 주문 락 상태 확인 API (`/lock/order/{id}`)

*   **HTTP Method:** `GET`
*   **전송 방식:** **JSON**
*   **인증:** 필요
*   **요청 파라미터 (Path):** `id` (정수)
*   **응답:** `{ "editable": boolean, "message": string, "locked_by": string | null, "locked_at": string | null }` (`LockStatusResponse`)
*   **동작:** 인증 확인 -> `get_lock_status` 서비스 호출 (DB 락 정보 및 타임아웃 확인) -> JSON 응답.

---

## 3. 인수인계 (Handover)

### 3.1 인수인계 페이지 로드 (`/handover`)

*   **HTTP Method:** `GET`
*   **전송 방식:** HTML (SSR - **첫 페이지 데이터 포함**)
*   **인증:** 필요
*   **요청 파라미터 (Query):**
    *   `page` (선택): 초기 페이지 번호 (기본값 1)
    *   `page_size` (선택): 페이지당 항목 수 (기본값 30)
*   **응답:**
    *   `handover.html` 템플릿 렌더링
    *   `initial_data` (컨텍스트 변수):
        *   `handovers`: 조회된 **첫 페이지**의 인수인계 목록 (예: `HandoverListItem` 형식 리스트, 최신순 정렬)
        *   `pagination`: 초기 페이지 정보 (totalCount: 전체 개수, page, pageSize, totalPages)
        *   `notices` (선택): 공지사항 목록 데이터 (별도 조회)
    *   `current_user`: 현재 로그인 사용자 정보
*   **동작 설명:**
    1.  인증 확인.
    2.  **페이지네이션 지원 서비스 함수** (`get_handover_list_paginated` - 구현 필요)를 호출하여, 요청된 페이지의 인수인계 데이터와 전체 데이터 개수를 가져옵니다.
    3.  전체 데이터 개수로 페이지네이션 정보를 계산합니다.
    4.  (선택적) 공지사항 데이터를 조회합니다.
    5.  조회된 첫 페이지 데이터, 페이지 정보, 공지사항 등을 컨텍스트에 담아 `handover.html` 템플릿을 렌더링합니다.
    6.  클라이언트 JS는 이 `initial_data`를 사용하여 초기 화면을 구성하고, 이후 전체 데이터 로드를 준비합니다.

### 3.2 인수인계 목록 조회 API (`/api/handover/list`)

*   **HTTP Method:** `GET`
*   **전송 방식:** **JSON**
*   **인증:** 필요
*   **요청 파라미터 (Query):** 없음
*   **응답:** `{ "success": boolean, "message": string, "data": List[HandoverListItem] }` (**모든** 인수인계 목록, 페이지네이션 없음)
*   **동작:** 인증 확인 -> `handover_service.get_handover_list` (페이지네이션 없음, 구현 필요) 호출하여 전체 데이터 조회 -> JSON 응답.

### 3.3 인수인계 상세 페이지 조회 (`/handover/{id}`)

*   **HTTP Method:** `GET`
*   **전송 방식:** HTML (SSR)
*   **인증:** 필요
*   **응답:** `handover_detail.html` 렌더링 (`handover` 상세 정보, `lock_info`, `current_user` 포함)
*   **동작:** 인증 확인 -> ID로 인수인계 조회 -> 락 상태 확인 -> 상세 페이지 렌더링.

### 3.4 인수인계 생성 (`/handover`)

*   **HTTP Method:** `POST`
*   **전송 방식:** **Form**
*   **인증:** 필요
*   **응답:** 성공 시 `/handover/{new_id}` 리다이렉트, 실패 시 생성 폼 재표시
*   **동작:** 인증 확인 -> 유효성 검증 -> DB 생성 -> 리다이렉트.

### 3.5 인수인계 수정 (`/handover/{id}`)

*   **HTTP Method:** `POST`
*   **전송 방식:** **Form**
*   **인증:** 필요
*   **응답:** 성공 시 `/handover/{id}` 리다이렉트, 실패 시 수정 폼 재표시
*   **동작:** 인증 확인 -> 락 획득 -> 유효성 검증 -> DB 업데이트 -> 락 해제 -> 리다이렉트.

### 3.6 인수인계 삭제 (`/handover/{id}/delete`)

*   **HTTP Method:** `POST`
*   **전송 방식:** **Form**
*   **인증:** 필요
*   **권한:** ADMIN (필요시)
*   **응답:** 성공 시 `/handover` 리다이렉트, 실패 시 오류 처리
*   **동작:** 인증/권한 확인 -> 락 획득 -> DB 삭제 -> 리다이렉트.

### 3.7 인수인계 락 상태 확인 API (`/lock/handover/{id}`)

*   **HTTP Method:** `GET`
*   **전송 방식:** **JSON**
*   **인증:** 필요
*   **응답:** (`LockStatusResponse` 와 유사) 락 상태 정보
*   **동작:** 인증 확인 -> 해당 인수인계 락 상태 확인 -> JSON 응답.

---

## 4. 사용자 관리 (Admin 전용)

*   **기본 경로:** `/admin/users` (예시)
*   **인증:** 모든 하위 경로 접근 시 ADMIN 권한 필요.

### 4.1 사용자 목록 조회 페이지 (`/admin/users`)
*   **HTTP Method:** `GET`, **전송:** HTML(SSR), **응답:** `user_list.html` (사용자 목록 포함)
*   **동작:** ADMIN 확인 -> 모든 사용자 조회 -> 목록 페이지 렌더링.

### 4.2 사용자 생성 페이지 (`/admin/users/new`)
*   **HTTP Method:** `GET`, **전송:** HTML(SSR), **응답:** `user_create.html` (입력 폼)
*   **동작:** ADMIN 확인 -> 생성 폼 렌더링.

### 4.3 사용자 생성 처리 (`/admin/users`)
*   **HTTP Method:** `POST`, **전송:** Form, **요청:** `user_id`, `password`, `role`
*   **응답:** 성공 시 `/admin/users` 리다이렉트, 실패 시 생성 폼 재표시
*   **동작:** ADMIN 확인 -> 유효성/중복 검증 -> 비밀번호 해싱 -> DB 생성 -> 리다이렉트.

### 4.4 사용자 삭제 처리 (`/admin/users/{user_id}/delete`)
*   **HTTP Method:** `POST`, **전송:** Form
*   **응답:** 성공 시 `/admin/users` 리다이렉트, 실패 시 목록 페이지 + 메시지
*   **동작:** ADMIN 확인 -> DB 삭제 -> 리다이렉트 (자기 자신 삭제 불가 로직 고려).

---

## 5. 클라이언트 사이드 동작 (JavaScript - dashboard.js, handover.js 등)

*   **공통 원칙 (JS 오류 방지 및 성능 최적화):**
    *   **오류 방지:** DOM 요소 접근 전 `null` 체크, API 응답 구조 확인, `try...catch` 활용.
    *   **성능 최적화:** `innerHTML` 대량 할당, 이벤트 위임, 내장 배열 메서드 활용.
    *   **코드 구조화:** 기능별 함수 분리, 별도 JS 파일 권장.
    *   **상태 관리:** 필터, 페이지, 데이터 배열 등 상태 변수 명확화.
    *   **로딩 상태:** API 호출 시 로딩 인디케이터 처리.

*   **대시보드 페이지 (`dashboard.js`):**
    *   **초기화:**
        1.  SSR로 전달된 `initial_data` (`orders`는 첫 30개, `pagination`은 전체 기준)로 테이블 초기 렌더링 및 페이지네이션 UI 설정.
        2.  `allOrders` 배열 변수 선언 (초기값은 비어있거나 `initial_data.orders`).
        3.  현재 필터, 페이지 상태 변수 초기화 (`initial_data.pagination` 참고).
        4.  **페이지 로드 완료 후 비동기적으로:** `/dashboard/list` API 호출 (현재 날짜 범위) -> 응답 성공 시 `allOrders`를 **전체 데이터로 업데이트**. (초기 렌더링은 유지)
    *   **데이터 로딩 (`loadAndRenderTable`):** 날짜 변경+조회 시 `/dashboard/list` API 호출 -> `allOrders` 업데이트 -> `renderTable()` 호출.
    *   **렌더링 (`renderTable`):** `allOrders` 기반 CSR 필터링/페이징 -> `<tbody>` 업데이트 (`innerHTML` 활용) -> 페이지네이션 UI 업데이트.
    *   **이벤트 핸들러:** 필터 변경, 페이지네이션 변경 시 상태 변수 업데이트 후 `renderTable()` 호출. 새로고침 시 `loadAndRenderTable()` 호출.
    *   **검색:** `/dashboard/search` API 호출 -> 단일 결과(`order`)로 테이블 1행 표시 또는 "결과 없음", 페이지네이션 숨김.
    *   **기타:** 컬럼 커스터마이징, 행 클릭 이벤트 처리.

*   **인수인계 페이지 (`handover.js`):**
    *   **초기화:**
        1.  SSR 데이터(`initial_data.handovers`, `pagination`)로 테이블/페이지네이션 초기 설정.
        2.  `allHandovers` 배열 선언.
        3.  **페이지 로드 완료 후 비동기적으로:** `/api/handover/list` API 호출 -> 응답 성공 시 `allHandovers`를 전체 데이터로 업데이트.
    *   **렌더링 (`renderHandoverTable`):** `allHandovers` 기반 CSR 페이징 -> `<tbody>` 업데이트 -> 페이지네이션 UI 업데이트.
    *   **이벤트 핸들러:** 페이지네이션 변경 시 상태 변수 업데이트 후 `renderHandoverTable()` 호출.
    *   **행 클릭:** `/handover/{id}` 이동.

--- 