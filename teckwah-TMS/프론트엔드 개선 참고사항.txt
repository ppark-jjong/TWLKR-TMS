# 프론트엔드 개선 참고사항 (업데이트)

> 본 문서는 기존 "프론트엔드 개선 참고사항.txt"를 상세 동작 명세서 기반으로 업데이트하여 실제 구현된 코드와 일치시키고, 명확한 DOM vs innerHTML 렌더링 방식 가이드라인을 추가한 버전입니다.

## 1. Jinja2 템플릿 시스템 활용 원칙

- **서버 렌더링 최대 활용**: 모든 초기 페이지 구조와 데이터는 Jinja2로 렌더링하여 제공
- **템플릿 상속 및 재사용**: 공통 레이아웃, 헤더, 푸터 등은 템플릿 상속으로 관리
- **서버 데이터 직접 바인딩**: 템플릿 변수를 사용하여 서버 데이터 직접 표시
- **조건부 렌더링**: 서버 측에서 권한이나 상태에 따른 UI 요소 표시 결정

## 2. CSS 관리 방식

- **외부 CSS 파일 사용**: 모든 스타일은 별도 CSS 파일로 관리
- **클래스 기반 스타일링**: 인라인 스타일 지양, 클래스 기반 스타일 사용
- **일관된 네이밍 컨벤션**: 프로젝트 전체에서 일관된 클래스 이름 규칙 적용
- **상태별 스타일**: 행 배경색은 상태에 따라 지정된 색상 적용
  - 대기: `rgb(255, 246, 203)`
  - 진행: `rgb(179, 228, 250)`
  - 완료: `rgb(210, 250, 171)`
  - 이슈: `rgb(252, 173, 161)`
  - 취소: `rgb(196, 196, 196)`

## 3. JavaScript 역할 재정의

- **DOM 직접 생성 금지**: HTML 구조를 JS에서 생성하지 말고 Jinja2 템플릿 활용
- **상호작용에 집중**: 클릭, 폼 제출 등 사용자 상호작용 처리에만 집중
- **기존 HTML 구조 존중**: 이미 있는 DOM 요소를 조작하는 방식으로 개발
- **이벤트 위임 활용**: 테이블 등 여러 요소에 이벤트를 개별 적용하지 않고 위임 패턴 사용

## 4. 데이터 처리 방식

- **초기 데이터**: 페이지 로드 시 Jinja2로 렌더링된 HTML에 포함
- **추가 데이터**: 필요시에만 AJAX로 가져와 DOM 업데이트
- **부분 갱신**: 전체 페이지 대신 필요한 부분만 업데이트
- **데이터 캐싱**: 자주 사용되는 데이터는 localStorage에서 캐싱 (컬럼 설정 등)

## 5. 렌더링 방식 가이드라인 (DOM 조작 vs innerHTML)

### DOM 조작 적합 상황
- **개별 요소 상태 변경**: 클래스, 속성, 값 등의 개별 변경
  ```javascript
  // 예시: 상태 배지 변경
  function updateOrderStatus(orderId, newStatus) {
    const row = document.querySelector(`tr[data-id="${orderId}"]`);
    if (!row) return;
    
    // 행 클래스 변경 (DOM 조작)
    row.className = row.className.replace(/status-row-\w+/, `status-row-${newStatus}`);
    
    // 상태 배지 업데이트 (DOM 조작)
    const statusCell = row.querySelector('.column-status');
    const statusBadge = statusCell.querySelector('.status-badge');
    statusBadge.className = `status-badge status-${newStatus}`;
    statusBadge.textContent = getStatusLabel(newStatus);
  }
  ```

- **이벤트 핸들러가 연결된 요소 업데이트**: 이벤트 유지가 필요한 경우
- **부분적 업데이트**: 테이블의 특정 셀만 변경할 때
- **성능이 중요한 빈번한 업데이트**: 자주 변경되는 내용

### innerHTML 적합 상황
- **대규모 콘텐츠 일괄 교체**: 모달 내용 전체 교체, 다수 행 렌더링
  ```javascript
  // 예시: 주문 상세 모달 내용 표시
  function displayOrderDetail(data) {
    const modal = document.getElementById('orderDetailModal');
    if (!modal) return;
    
    // 모달 콘텐츠 전체 교체 (innerHTML)
    modal.innerHTML = `
      <div class="modal-header">
        <h2 class="modal-title">주문 상세 정보</h2>
        <span class="modal-close">&times;</span>
      </div>
      
      <div class="modal-body">
        <!-- 여러 폼 필드와 섹션 -->
      </div>
      
      <div class="modal-footer">
        <!-- 버튼들 -->
      </div>
    `;
    
    // 이벤트 핸들러 재설정 필요
    initModalEventHandlers();
  }
  ```

- **테이블 전체 데이터 갱신**: 필터링 결과 표시 등
- **정적 콘텐츠 생성**: 알림 메시지, 설명 텍스트 등
- **구현 간결성 우선 시**: 복잡한 DOM 구조를 간결하게 처리

### 하이브리드 접근법
- **정적 구조는 Jinja2, 동적 내용은 JS로 업데이트**
- **이벤트 핸들러 관리 패턴**:
  ```javascript
  // 이벤트 위임 패턴
  document.querySelector('#orderTable tbody').addEventListener('click', (e) => {
    const row = e.target.closest('tr');
    if (!row || row.classList.contains('no-data-row')) return;
    
    const orderId = row.getAttribute('data-id');
    if (orderId) {
      openOrderDetail(orderId);
    }
  });
  ```

- **주요 렌더링 함수 분리**: 데이터 처리와 UI 갱신 로직 분리
- **데이터 속성 활용**: HTML 요소에 `data-*` 속성으로 메타데이터 저장

## 6. 상태 관리 및 사용자 상호작용

- **네임스페이스 사용**: 전역 네임스페이스 오염 방지를 위한 객체 패턴 사용
  ```javascript
  // 네임스페이스 예시
  const Dashboard = {
    config: { /* 설정 값 */ },
    state: { /* 상태 변수 */ },
    init: function() { /* 초기화 */ },
    // 기타 메서드들...
  };
  ```

- **상태 중앙화**: 페이지 상태(필터, 페이지네이션 등)를 객체에 통합 관리
- **알림 시스템 표준화**: 모든 사용자 알림은 통일된 방식으로 표시
- **락 관리**: 편집 시 락 획득/해제 로직 구현 (주요 CRUD 작업 전 확인)

## 7. 페이지별 구현 가이드

### 대시보드 페이지
- **초기 로드**: ETA 기본값 오늘로 설정, SSR로 today ETA 주문 로드
- **필터링**: 날짜/주문번호는 서버 요청, 상태/부서/창고는 클라이언트 필터링
- **테이블 행 상호작용**: 행 클릭 시 상세 정보 모달 표시
- **모달 내 작업**: 상세 정보 조회, 편집, 상태 변경, 배차 모두 단일 모달에서 처리

### 인수인계 페이지
- **초기 로드**: 공지(30%), 인수인계(70%) 영역 동시 로드
- **데이터 관리**: 관리자/일반 사용자 권한에 따른 UI 차등 표시
- **락 메커니즘**: 대시보드와 동일한 락 로직 적용

### 사용자 관리 페이지
- **관리자 전용**: 사용자 목록, 추가, 삭제 기능 제공
- **간소화된 UI**: 최소한의 기능만 제공

## 8. 코드 구조화 및 모듈화

- **기능별 파일 분리**: 
  - `common.js`: 공통 유틸리티 및 API 호출
  - `dashboard.js`: 대시보드 페이지 전용 기능
  - `handover.js`: 인수인계 페이지 전용 기능
  - `users.js`: 사용자 관리 페이지 전용 기능

- **잘 정의된 초기화 순서 예시**:
  ```javascript
  document.addEventListener('DOMContentLoaded', function() {
    // 1. 공통 UI 요소 초기화
    TMS.initUI();
    
    // 2. 페이지별 초기화
    Dashboard.init();
  });
  ```

- **재사용 가능한 컴포넌트**: 알림, 모달, 로딩 등 공통 UI 컴포넌트 모듈화

## 9. 성능 최적화 및 사용자 경험

- **적절한 렌더링 전략 선택**: 상황에 맞는 DOM/innerHTML 방식 적용
- **불필요한 리렌더링 방지**: 변경된 부분만 업데이트
- **명확한 상태 피드백**: 로딩, 성공, 오류 상태 시각화
- **반응형 디자인**: 화면 크기에 따른 레이아웃 조정
- **언어 및 시간 표준**: 한국어 UI, KST 시간대 사용

## 10. 유지보수 가이드

- **일관된 코드 스타일**: 동일한 패턴과 네이밍 규칙 유지
- **충분한 주석**: 복잡한 로직과 비즈니스 규칙에 한국어 주석 제공
- **기존 코드 존중**: 기능 추가/변경 시 기존 패턴 준수
- **점진적 개선**: 전면 교체 대신 점진적인 개선 접근법 채택

---

이 가이드라인을 따르면 Jinja2의 서버 렌더링 장점을 유지하면서도 필요한 인터랙티브 기능을 효과적으로 구현할 수 있습니다.