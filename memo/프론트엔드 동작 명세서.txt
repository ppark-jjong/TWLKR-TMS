# 배송 실시간 관제 시스템 리팩토링 명세서

## 1. 디자인 아키텍처 및 필수 디자인 요소

### 1.1 전체 아키텍처 패턴

현재 시스템은 다음과 같은 아키텍처 패턴을 사용합니다:

- **상태 관리**: Context API를 통한 전역 상태 관리 (AuthContext, DashboardContext)
- **UI 프레임워크**: Ant Design 5.x 컴포넌트 라이브러리
- **API 통신**: Axios 기반 HTTP 클라이언트와 인터셉터 패턴
- **코드 구조**: 컨트롤러-서비스 패턴 (Controller 로직 분리)
- **라우팅**: React Router v6 (중첩 라우팅, 보호된 경로)

### 1.2 페이지별 필수 디자인 요소

#### 1.2.1 로그인 페이지

- **필수 컴포넌트**:
  - 로고 및 시스템 타이틀
  - 사용자 ID 입력 필드 (문자열)
  - 비밀번호 입력 필드 (마스킹 처리)
  - 로그인 버튼 (로딩 상태 표시)
  - 오류 메시지 표시 영역

- **디자인 특징**:
  - 중앙 정렬된 카드 컴포넌트 (Card)
  - 반응형 디자인 (모바일 호환)
  - 로그인 진행 중 로딩 표시 (Spin)

#### 1.2.2 대시보드/배차 페이지

- **필수 컴포넌트**:
  - **헤더 영역**:
    - 페이지 타이틀 ("배송 관리 대시보드")
    - 날짜 선택기 (DatePicker, RangePicker) - ETA 기준 필터링
    - 주문번호 검색 필드 (Search)
    - 액션 버튼 (신규 등록, 배차, 삭제(관리자만), 새로고침)
  
  - **필터 영역**:
    - 종류 필터 (배송/회수)
    - 부서 필터 (CS/HES/LENOVO)
    - 출발 허브 필터 (서울/부산/광주/대전)
    - 필터 적용/초기화 버튼
  
  - **테이블 영역**:
    - 주요 컬럼 포함 Table 컴포넌트:
      ```
      - 체크박스 (다중 선택)
      - 종류 (DELIVERY/RETURN)
      - 주문번호
      - 부서 (CS/HES/LENOVO)
      - 출발허브 (SEOUL/BUSAN/GWANGJU/DAEJEON)
      - 상태 (WAITING/IN_PROGRESS/COMPLETE/ISSUE/CANCEL)
      - ETA (도착 예정 시간)
      - 접수시각
      - SLA
      - 수령인
      - 연락처
      - 배송담당
      - 배송연락처
      ```
    - 페이지네이션 (기본 50개 항목)
    - 로딩 상태 표시 (LoadingSpin)
    - 빈 데이터 상태 (Empty)

- **모달 컴포넌트**:
  - **대시보드 상세 모달**:
    - 주문 상세 정보 표시
    - 상태 변경 버튼
    - 정보 수정 기능 (비관적 락 적용)
    - 메모 섹션 및 편집 기능
  
  - **신규 등록 모달**:
    - 배송 정보 입력 폼
    - 필수 필드 유효성 검증
  
  - **배차 모달**:
    - 선택된 주문 목록
    - 배송 담당자 및 연락처 입력

- **디자인 특징**:
  - 상태별 행 배경색 구분 (WAITING/IN_PROGRESS/COMPLETE/ISSUE/CANCEL)
  - 종류별 텍스트 색상 구분 (DELIVERY/RETURN)
  - 반응형 테이블 (수평 스크롤)
  - 비관적 락 충돌 시 알림 UI

#### 1.2.3 시각화(Visualization) 페이지

- **필수 컴포넌트**:
  - **헤더 영역**:
    - 차트 타입 선택기 (Select)
    - 날짜 범위 선택기 (RangePicker) - 생성 시간 기준 필터링
    - 새로고침 버튼
  
  - **차트 타입별 컴포넌트**:
    - **배송 현황 파이 차트**:
      - 상태별 요약 카드 (Badge, Card, Statistic)
      - 부서별 파이 차트 (@ant-design/plots Pie)
    
    - **시간대별 접수량 차트**:
      - 부서별 통계 카드
      - 시간대별 막대 그래프 (@ant-design/plots Column)

- **디자인 특징**:
  - 통일된 색상 테마 (부서별, 상태별)
  - 반응형 그리드 레이아웃 (Row, Col)
  - 데이터 없음/로딩 상태 표시

#### 1.2.4 다운로드(관리자) 페이지

- **필수 컴포넌트**:
  - 페이지 타이틀 및 설명
  - 날짜 범위 선택기 (RangePicker)
  - 다운로드 버튼 (Excel)
  - 관리자 권한 검증 및 접근 제한 UI

- **디자인 특징**:
  - 카드 기반 섹션 구분 (Card)
  - 직관적인 다운로드 버튼 (icon: FileExcelOutlined)

#### 1.2.5 공통 UI 요소

- **사이드바**:
  - 로고 및 시스템 명 표시
  - 사용자 정보 표시 (이름, 부서)
  - 네비게이션 메뉴 (배차, 통계, 다운로드(관리자만))
  - 접기/펼치기 기능
  - 로그아웃 버튼

- **에러 경계**:
  - 컴포넌트 오류 발생 시 폴백 UI (ErrorBoundary)
  - 다양한 에러 상황별 적절한 메시지와 재시도 버튼

- **로딩 스피너**:
  - 일관된 로딩 상태 표시 (LoadingSpin)

## 2. UI/UX 사용자 시나리오 및 서비스 로직

### 2.1 인증 및 권한 관리

#### 2.1.1 로그인 시나리오
1. 사용자가 로그인 페이지 방문
2. ID/패스워드 입력 후 로그인 버튼 클릭
3. 로딩 상태로 전환 (버튼 비활성화 + 스피너)
4. 인증 성공 시:
   - JWT 토큰 저장 (액세스 토큰 + 리프레시 토큰)
   - 사용자 정보 저장 (이름, 부서, 권한)
   - 대시보드 페이지로 리다이렉트
5. 인증 실패 시:
   - 오류 메시지 표시
   - 입력 필드 포커스

#### 2.1.2 세션 관리 시나리오
1. 페이지 로드 시 토큰 유효성 검증
2. 토큰 만료 시 자동 갱신 (리프레시 토큰 사용)
3. 갱신 실패 시 로그인 페이지로 리다이렉트
4. 인증 필요 페이지 접근 시 권한 검증

#### 2.1.3 관리자 권한 시나리오
1. 관리자 전용 기능 접근 시 권한 검증
2. 권한 없는 경우 적절한 메시지와 접근 제한
3. 다운로드 페이지는 관리자만 접근 가능

### 2.2 대시보드/배차 페이지 시나리오

#### 2.2.1 데이터 조회 시나리오
1. 페이지 접근 시 기본 날짜 범위(최근 7일) 데이터 자동 로드
2. 날짜 범위 변경 시 데이터 재로드
3. 필터 적용 시 클라이언트 측 필터링
4. 주문번호 검색 시 서버 측 검색 (정확한 주문번호 조회)
5. 새로고침 버튼으로 최신 데이터 조회

#### 2.2.2 주문 상세 조회 시나리오
1. 테이블 행 클릭 시 상세 정보 모달 표시
2. 상세 정보 로딩 중 로딩 상태 표시
3. 락 상태 확인 및 표시 (다른 사용자 편집 중인 경우 알림)
4. 모달 닫기 시 상태 초기화

#### 2.2.3 배차 처리 시나리오
1. 테이블에서 대기(WAITING) 상태 주문 다중 선택
2. 배차 버튼 클릭 시 배차 모달 표시
3. 배송 담당자 정보 입력 (기사명, 연락처)
4. 배차 처리 진행 중 로딩 상태 표시
5. 성공 시 테이블 데이터 갱신 및 성공 메시지
6. 실패 시 오류 메시지 표시

#### 2.2.4 상태 변경 시나리오
1. 상세 모달에서 상태 변경 버튼 클릭
2. 상태 변경 확인 모달 표시
3. 비관적 락 획득 시도 (실패 시 오류 메시지)
4. 상태 변경 진행 중 로딩 상태 표시
5. 변경 성공 시 상세 정보 및 테이블 데이터 갱신
6. 변경 실패 시 오류 메시지 표시

#### 2.2.5 비관적 락 시나리오
1. 편집 시작 시 락 획득 시도
2. 락 획득 성공 시 편집 모드 활성화
3. 락 획득 실패 시 (다른 사용자가 편집 중):
   - 423 Locked 응답 처리
   - "다른 사용자가 편집 중입니다" 메시지 표시
   - 편집 버튼 비활성화
4. 락 만료 5분 전 경고 메시지
5. 편집 완료 또는 취소 시 락 자동 해제

### 2.3 시각화 페이지 시나리오

#### 2.3.1 차트 데이터 조회 시나리오
1. 페이지 접근 시 기본 날짜 범위(최근 7일) 및 차트 타입(배송 현황) 설정
2. 날짜 범위 변경 시 데이터 재로드
3. 차트 타입 변경 시 데이터 재로드
4. 데이터 로딩 중 로딩 상태 표시
5. 데이터 없음 시 Empty 컴포넌트 표시

#### 2.3.2 차트 상호작용 시나리오
1. 파이 차트 호버 시 상세 정보 툴팁 표시
2. 막대 그래프 호버 시 상세 정보 툴팁 표시
3. 차트 영역 크기 변경 시 반응형으로 조정
4. 데이터 업데이트 시간 표시 및 새로고침 기능

### 2.4 다운로드 페이지 시나리오

#### 2.4.1 Excel 다운로드 시나리오
1. 관리자 권한 검증 (일반 사용자 접근 제한)
2. 날짜 범위 선택
3. 다운로드 버튼 클릭 시 다운로드 진행
4. 다운로드 중 로딩 상태 표시
5. 성공 시 파일 저장 다이얼로그 표시
6. 실패 시 오류 메시지 표시

## 3. 백엔드 통신 및 데이터 관리 전략

### 3.1 백엔드 API 통신 요소

#### 3.1.1 인증 관련 API
- **로그인**: `POST /auth/login`
  - 요청: `{ user_id, password }`
  - 응답: `{ success, message, token: { access_token, refresh_token }, user }`

- **세션 확인**: `GET /auth/check-session`
  - 헤더: `Authorization: Bearer {access_token}`
  - 응답: `{ success, message, data: { user } }`

- **토큰 갱신**: `POST /auth/refresh`
  - 요청: `{ refresh_token }`
  - 응답: `{ success, message, data: { token } }`

#### 3.1.2 대시보드 관련 API
- **목록 조회**: `POST /dashboard/list`
  - 요청: `{ start_date, end_date }`
  - 응답: `{ success, message, data: { items, date_range } }`

- **상세 조회**: `GET /dashboard/{dashboard_id}`
  - 응답: `{ success, message, data, is_locked, lock_info }`

- **주문번호 검색**: `GET /dashboard/search?order_no={order_no}`
  - 응답: `{ success, message, data: { items } }`

- **필드 업데이트**: `PATCH /dashboard/{dashboard_id}/fields`
  - 요청: 변경할 필드 객체
  - 응답: `{ success, message, data }`

- **상태 업데이트**: `PATCH /dashboard/{dashboard_id}/status`
  - 요청: `{ status, is_admin }`
  - 응답: `{ success, message, data }`

- **배차 처리**: `POST /dashboard/assign`
  - 요청: `{ dashboard_ids, driver_name, driver_contact }`
  - 응답: `{ success, message, data }`

#### 3.1.3 락(Lock) 관련 API
- **락 획득**: `POST /dashboard/{dashboard_id}/lock`
  - 요청: `{ lock_type }`
  - 응답: `{ success, message, data }`
  - 오류: `423 Locked` (다른 사용자가 락 보유)

- **락 해제**: `DELETE /dashboard/{dashboard_id}/lock`
  - 응답: `{ success, message, data }`

- **락 상태 확인**: `GET /dashboard/{dashboard_id}/lock/status`
  - 응답: `{ success, message, data: { is_locked, locked_by, ... } }`

#### 3.1.4 시각화 관련 API
- **배송 현황 데이터**: `POST /visualization/delivery_status`
  - 요청: `{ start_date, end_date }`
  - 응답: `{ success, message, data, date_range }`

- **시간대별 접수량**: `POST /visualization/hourly_orders`
  - 요청: `{ start_date, end_date }`
  - 응답: `{ success, message, data, date_range }`

- **날짜 범위 조회**: `GET /visualization/date_range`
  - 응답: `{ success, message, date_range }`

#### 3.1.5 다운로드 관련 API
- **Excel 다운로드**: `POST /download/excel`
  - 요청: `{ start_date, end_date }`
  - 응답: Excel 파일 스트림

### 3.2 CSR 구현 요소

#### 3.2.1 클라이언트 상태 관리
- **전역 상태**:
  - 인증 정보 (AuthContext)
  - 대시보드 데이터 (DashboardContext)

- **지역 상태**:
  - UI 상태 (모달 표시 여부, 활성 탭 등)
  - 폼 상태 (입력 값, 유효성 검증 등)
  - 필터 상태 (선택된 필터, 정렬 기준 등)

#### 3.2.2 클라이언트 캐싱 전략
- **API 응답 캐싱**:
  - 날짜 범위별 데이터 캐싱
  - 주문 상세 정보 캐싱
  - 시각화 데이터 캐싱

- **캐시 무효화 조건**:
  - 데이터 업데이트 시 관련 캐시 무효화
  - 시간 기반 캐시 만료 (TTL)

#### 3.2.3 클라이언트 필터링 및 정렬
- **다중 필터 적용**:
  - 종류, 부서, 허브 기준 필터링
  - 필터 조합 및 초기화

- **정렬 기능**:
  - 컬럼별 정렬 (주문번호, ETA, 상태 등)
  - 기본 정렬: 상태 + ETA

#### 3.2.4 사용자 입력 유효성 검증
- **폼 필드 검증**:
  - 필수 입력 검증
  - 형식 검증 (전화번호, 우편번호 등)
  - 상태 변경 규칙 검증

## 4. 새로운 구현을 위한 핵심 고려사항

### 4.1 아키텍처 설계 원칙

#### 4.1.1 모듈화 및 관심사 분리
- **기능별 모듈 분리**:
  - 코어 모듈: API 클라이언트, 인증, 에러 처리
  - 기능 모듈: 대시보드, 시각화, 다운로드
  - 공통 모듈: UI 컴포넌트, 유틸리티 함수

- **레이어 구분**:
  - UI 레이어: 컴포넌트, 페이지
  - 서비스 레이어: API 호출, 비즈니스 로직
  - 상태 관리 레이어: Context, Hooks
  - 유틸리티 레이어: 헬퍼 함수, 공통 로직

#### 4.1.2 일관된 패턴 적용
- **API 통신 패턴**:
  ```javascript
  // API 서비스 패턴
  const DashboardService = {
    async getList(startDate, endDate) {
      try {
        const response = await api.post('/dashboard/list', { 
          start_date: formatDate(startDate),
          end_date: formatDate(endDate)
        });
        return response.data; // { success, message, data }
      } catch (error) {
        handleApiError(error);
        throw error;
      }
    },
    // 다른 메서드들...
  };
  ```

- **커스텀 훅 패턴**:
  ```javascript
  // 데이터 페칭 훅 패턴
  function useDashboardData(initialDates) {
    const [data, setData] = useState([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    const [dateRange, setDateRange] = useState(initialDates);

    const fetchData = useCallback(async () => {
      try {
        setLoading(true);
        setError(null);
        const result = await DashboardService.getList(
          dateRange[0], 
          dateRange[1]
        );
        if (result.success) {
          setData(result.data.items);
        } else {
          throw new Error(result.message);
        }
      } catch (err) {
        setError(err.message);
        message.error(err.message);
      } finally {
        setLoading(false);
      }
    }, [dateRange]);

    useEffect(() => {
      if (dateRange) fetchData();
    }, [dateRange, fetchData]);

    return { data, loading, error, dateRange, setDateRange, refetch: fetchData };
  }
  ```

- **컴포넌트 구조 패턴**:
  ```javascript
  // 컴포넌트 구조 패턴
  function DashboardPage() {
    // 1. 상태 및 훅
    const { data, loading, dateRange, setDateRange } = useDashboardData();
    const [selectedRows, setSelectedRows] = useState([]);
    
    // 2. 이벤트 핸들러
    const handleDateChange = useCallback((dates) => {
      setDateRange(dates);
    }, [setDateRange]);
    
    // 3. 메모이제이션된 값/컴포넌트
    const tableColumns = useMemo(() => [...], []);
    
    // 4. 렌더링
    return (
      <Layout>
        <PageHeader title="대시보드" />
        <FilterSection 
          dateRange={dateRange} 
          onDateChange={handleDateChange} 
        />
        <TableSection 
          data={data} 
          loading={loading}
          selectedRows={selectedRows}
          onSelectRows={setSelectedRows}
        />
      </Layout>
    );
  }
  ```

### 4.2 성능 최적화 전략

#### 4.2.1 렌더링 최적화
- **메모이제이션 활용**:
  - `useMemo`로 계산 비용이 큰 값 메모이제이션
  - `useCallback`으로 이벤트 핸들러 안정화
  - `React.memo`로 컴포넌트 재렌더링 방지

- **가상화 적용**:
  - 대량 데이터 테이블에 가상화 적용 (react-window)
  - 페이지네이션 구현으로 한 번에 렌더링하는 항목 제한

#### 4.2.2 네트워크 최적화
- **API 호출 최적화**:
  - 요청 중복 방지 (useRef로 진행 중인 요청 추적)
  - 디바운싱 적용 (검색 입력 등)
  - 응답 캐싱 (sessionStorage, localStorage 또는 캐시 라이브러리)

- **에러 처리 전략**:
  ```javascript
  // Axios 인터셉터 설정
  api.interceptors.response.use(
    (response) => {
      // 표준 응답 구조 확인 및 변환
      if (response.data && typeof response.data === 'object') {
        // success 필드가 있는 경우 그대로 반환
        if ('success' in response.data) {
          return response;
        }
        // 표준 구조 아닌 경우 변환
        response.data = {
          success: true,
          message: '데이터를 조회했습니다',
          data: response.data,
        };
      }
      return response;
    },
    async (error) => {
      // 에러 응답 처리
      const { response } = error;
      
      // 네트워크 오류
      if (!response) {
        message.error('서버와 통신할 수 없습니다.');
        return Promise.reject(error);
      }
      
      // HTTP 상태 코드별 처리
      switch (response.status) {
        case 401:
          // 토큰 만료 처리
          try {
            // 토큰 갱신 로직
          } catch (refreshError) {
            // 갱신 실패 처리
          }
          break;
        case 423:
          // 비관적 락 충돌 처리
          const lockInfo = response.data?.error?.detail || {};
          message.warning(`현재 ${lockInfo.locked_by || '다른 사용자'}님이 편집 중입니다.`);
          break;
        // 기타 상태 코드 처리...
      }
      
      return Promise.reject(error);
    }
  );
  ```

### 4.3 비관적 락 구현 전략

#### 4.3.1 락 관리 워크플로우
1. **편집 시작 전 락 획득**:
   ```javascript
   // 락 획득 함수
   async function acquireLock(dashboardId, lockType) {
     try {
       const response = await api.post(`/dashboard/${dashboardId}/lock`, {
         lock_type: lockType
       });
       return response.data.data;
     } catch (error) {
       if (error.response?.status === 423) {
         // 락 충돌 처리
         const detail = error.response.data?.error?.detail || {};
         message.warning(`현재 ${detail.locked_by || '다른 사용자'}님이 편집 중입니다.`);
       }
       throw error;
     }
   }
   ```

2. **편집 작업 수행**:
   ```javascript
   // 락 획득 후 편집 워크플로우
   async function startEditing(dashboardId) {
     setLockLoading(true);
     try {
       const lock = await acquireLock(dashboardId, 'EDIT');
       setLockInfo(lock);
       setEditMode(true);
       
       // 락 만료 타이머 설정
       setupLockExpireTimer(lock.expires_at);
       
     } catch (error) {
       // 락 획득 실패 처리
     } finally {
       setLockLoading(false);
     }
   }
   ```

3. **편집 완료 및 락 해제**:
   ```javascript
   // 편집 완료 및 락 해제
   async function finishEditing(dashboardId, updatedData) {
     try {
       // 데이터 업데이트
       await updateDashboardFields(dashboardId, updatedData);
       
       // 락 해제
       await releaseLock(dashboardId);
       
       // 타이머 정리
       clearLockTimers();
       
       // 상태 업데이트
       setEditMode(false);
       setLockInfo(null);
       
     } catch (error) {
       // 에러 처리
     }
   }
   ```

4. **락 만료 처리**:
   ```javascript
   // 락 만료 타이머 설정
   function setupLockExpireTimer(expiresAt) {
     const expireTime = new Date(expiresAt).getTime();
     const now = Date.now();
     const timeRemaining = Math.max(0, expireTime - now);
     
     // 경고 타이머 (만료 1분 전)
     if (timeRemaining > 60000) {
       warningTimerRef.current = setTimeout(() => {
         message.warning('편집 세션이 곧 만료됩니다.');
       }, timeRemaining - 60000);
     }
     
     // 만료 타이머
     expireTimerRef.current = setTimeout(() => {
       message.error('편집 세션이 만료되었습니다.');
       setEditMode(false);
       setLockInfo(null);
     }, timeRemaining);
   }
   
   // 타이머 정리
   function clearLockTimers() {
     if (warningTimerRef.current) {
       clearTimeout(warningTimerRef.current);
       warningTimerRef.current = null;
     }
     
     if (expireTimerRef.current) {
       clearTimeout(expireTimerRef.current);
       expireTimerRef.current = null;
     }
   }
   ```

### 4.4 에러 처리 및 사용자 피드백 전략

#### 4.4.1 에러 타입별 처리
- **API 오류**:
  - 네트워크 오류
  - HTTP 상태 코드별 처리 (401, 403, 404, 423, 500 등)
  - 백엔드 응답 오류 (`success: false`)

- **유효성 검증 오류**:
  - 필드별 유효성 검증 오류
  - 폼 제출 전 클라이언트측 검증
  - 서버측 검증 오류 응답 처리

- **비즈니스 로직 오류**:
  - 권한 부족 오류
  - 락 충돌 오류
  - 상태 변경 규칙 위반 오류

#### 4.4.2 사용자 피드백 시스템
- **토스트 메시지**:
  ```javascript
  // 일관된 메시지 유틸리티
  const messageUtil = {
    success(content, key) {
      message.success({
        content,
        key,
        duration: 2,
      });
    },
    error(content, key) {
      message.error({
        content,
        key,
        duration: 3,
      });
    },
    warning(content, key) {
      message.warning({
        content,
        key,
        duration: 3,
      });
    },
    loading(content, key) {
      message.loading({
        content,
        key,
        duration: 0,
      });
    },
    loadingToSuccess(content, key) {
      message.success({
        content,
        key,
        duration: 2,
      });
    },
    loadingToError(content, key) {
      message.error({
        content,
        key,
        duration: 3,
      });
    },
  };
  ```

- **폼 필드 오류**:
  ```javascript
  // 폼 필드 오류 표시
  <Form.Item
    name="contact"
    label="연락처"
    rules={[
      { required: true, message: '연락처를 입력해주세요' },
      {
        pattern: /^\d{2,3}-\d{3,4}-\d{4}$/,
        message: '올바른 연락처 형식으로 입력해주세요 (예: 010-1234-5678)',
      },
    ]}
    validateStatus={errors.contact ? 'error' : ''}
    help={errors.contact}
  >
    <Input />
  </Form.Item>
  ```

- **상태 표시 UI**:
  ```javascript
  // 락 정보 표시 컴포넌트
  function LockInfoAlert({ lockInfo }) {
    if (!lockInfo) return null;
    
    const expiresAt = lockInfo.expires_at ? dayjs(lockInfo.expires_at) : null;
    const timeRemaining = expiresAt ? Math.max(0, expiresAt.diff(dayjs(), 'minute')) : 0;
    
    return (
      <Alert
        type="warning"
        showIcon
        message="편집 세션 정보"
        description={
          <>
            <p>
              현재 <strong>{lockInfo.locked_by}</strong>님이
              <strong> {getLockTypeText(lockInfo.lock_type)} </strong>
              작업 중입니다.
            </p>
            {expiresAt && (
              <p>
                세션 만료: {expiresAt.format('HH:mm:ss')} (남은 시간: 약 {timeRemaining}분)
              </p>
            )}
          </>
        }
      />
    );
  }
  ```

## 5. 권장 파일 구조 및 모듈화 전략

### 5.1 파일 구조

```
frontend/                 # 최상위 프로젝트 폴더
├── public/               # 정적 파일
│   ├── index.html        # 메인 HTML 파일
│   ├── favicon.ico       # 파비콘
│   └── logo.png          # 로고 이미지
│
├── src/                  # 소스 코드
│   ├── api/              # API 통신 모듈
│   │   ├── client.js     # Axios 기본 설정
│   │   ├── auth.js       # 인증 API
│   │   ├── dashboard.js  # 대시보드 API
│   │   └── visualization.js # 시각화 API
│   │
│   ├── components/       # 컴포넌트
│   │   ├── common/       # 공통 컴포넌트
│   │   │   ├── ErrorBoundary.js
│   │   │   ├── LoadingSpin.js
│   │   │   ├── Sidebar.js
│   │   │   └── MainLayout.js
│   │   │
│   │   ├── dashboard/    # 대시보드 컴포넌트
│   │   │   ├── DashboardTable.js
│   │   │   ├── DashboardFilter.js
│   │   │   ├── DetailModal.js
│   │   │   ├── CreateModal.js
│   │   │   └── AssignModal.js
│   │   │
│   │   └── visualization/ # 시각화 컴포넌트
│   │       ├── StatusPieChart.js
│   │       └── HourlyBarChart.js
│   │
│   ├── contexts/         # 상태 관리
│   │   ├── AuthContext.js
│   │   └── DashboardContext.js
│   │
│   ├── hooks/            # 커스텀 훅
│   │   ├── useAuth.js    # 인증 관련 훅
│   │   ├── useDashboard.js # 대시보드 데이터 훅
│   │   └── useDateRange.js # 날짜 범위 선택 훅
│   │
│   ├── pages/            # 페이지 컴포넌트
│   │   ├── LoginPage.js
│   │   ├── DashboardPage.js
│   │   ├── VisualizationPage.js
│   │   └── DownloadPage.js
│   │
│   ├── utils/            # 유틸리티
│   │   ├── constants.js  # 상수 정의
│   │   ├── formatter.js  # 포맷팅 유틸리티
│   │   └── message.js    # 메시지 표시 유틸리티
│   │
│   ├── App.js            # 앱 컴포넌트
│   ├── AppRoutes.js      # 라우팅 정의
│   └── index.js          # 진입점
│
├── package.json          # 패키지 정의
└── README.md             # 프로젝트 설명
```

### 5.2 각 디렉토리 역할 및 구현 전략

#### 5.2.1 api/ 디렉토리
- **client.js**: Axios 인스턴스 및 인터셉터 설정
- **각 도메인별 API 모듈**: API 엔드포인트별 함수 정의

#### 5.2.2 components/ 디렉토리
- **common/**: 재사용 가능한 공통 컴포넌트
- **기능별 디렉토리**: 각 기능 영역별 컴포넌트 그룹

#### 5.2.3 contexts/ 디렉토리
- **전역 상태 관리**: Context API 기반 상태 관리
- **Provider 컴포넌트**: 전역 상태 및 액션 제공

#### 5.2.4 hooks/ 디렉토리
- **데이터 관련 훅**: API 호출 및 데이터 관리
- **UI 관련 훅**: 상태 관리 및 이벤트 처리

#### 5.2.5 pages/ 디렉토리
- **페이지 수준 컴포넌트**: 라우팅 대상의 최상위 컴포넌트
- **컨텍스트 소비 및 하위 컴포넌트 조합**

#### 5.2.6 utils/ 디렉토리
- **공통 유틸리티 함수**: 포맷팅, 검증, 상수 등
- **서비스 로직 지원**: 비즈니스 로직 헬퍼 함수

## 6. 결론

배송 실시간 관제 시스템의 리팩토링 명세서를 통해 현재 구현된 디자인 요소, 서비스 로직, 백엔드 통신 요소, 그리고 새로운 구현을 위한 핵심 고려사항을 상세히 정리했습니다. 이 명세서를 바탕으로 새로운 프론트엔드 구현을 진행할 때 다음 사항을 특히 주의해야 합니다:

1. **모듈화 및 관심사 분리**: 명확한 책임 경계를 가진 작은 모듈로 구성
2. **백엔드 API 명세 준수**: 백엔드 응답 구조와 일치하는 통신 구현
3. **일관된 패턴 적용**: API 호출, 상태 관리, 컴포넌트 구조에 일관된 패턴 적용
4. **비관적 락 제대로 구현**: 423 Locked 응답 처리 및 사용자 피드백 구현
5. **성능 최적화**: 불필요한 렌더링 방지 및 네트워크 호출 최적화

이러한 접근 방식은 유지보수 가능성을 높이고, 성능을 개선하며, 사용자 경험을 향상시킬 것입니다.