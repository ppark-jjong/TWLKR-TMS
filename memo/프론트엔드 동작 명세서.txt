# 배송 실시간 관제 시스템 프론트엔드 동작 명세서

## 1. API 호출 및 데이터 입출력 구조

### 1.1 API 호출 기본 구조

모든 API 호출은 중앙 집중식 `ApiService` 클래스를 통해 수행되며, Axios 인스턴스를 사용합니다. 응답 데이터는 다음과 같은 표준 형식을 갖습니다:

```
{
  success: boolean,   // API 성공 여부
  message: string,    // 성공/실패 메시지
  data: any           // 실제 데이터 (객체 또는 배열)
}
```

### 1.2 주요 API 엔드포인트

#### 1.2.1 인증 관련 API

| 엔드포인트 | HTTP 메서드 | 요청 데이터 | 응답 데이터 | 설명 |
|------------|------------|------------|------------|------|
| `/auth/login` | POST | `{ user_id: string, password: string }` | `{ token: { access_token: string, refresh_token: string }, user: UserObject }` | 사용자 로그인 |
| `/auth/refresh` | POST | `{ refresh_token: string }` | `{ token: { access_token: string, refresh_token?: string }, user?: UserObject }` | 토큰 갱신 |
| `/auth/logout` | POST | `{ refresh_token: string }` | `{ success: boolean }` | 로그아웃 |
| `/auth/check-session` | GET | - | `{ success: boolean, user?: UserObject }` | 세션 유효성 검증 |

**UserObject 구조:**
```
{
  user_id: string,     // 사용자 ID
  user_name: string,   // 사용자 이름
  user_role: string,   // 역할 (ADMIN 또는 USER)
  user_department: string  // 부서 정보
}
```

#### 1.2.2 대시보드 관련 API

| 엔드포인트 | HTTP 메서드 | 요청 데이터 | 응답 데이터 | 설명 |
|------------|------------|------------|------------|------|
| `/dashboard/list` | GET | `start_date: YYYY-MM-DD`, `end_date: YYYY-MM-DD` | `{ items: DashboardItem[], date_range: { oldest_date: string, latest_date: string } }` | 대시보드 목록 조회 |
| `/dashboard/{dashboardId}` | GET | - | `DashboardDetail` | 상세 정보 조회 |
| `/dashboard` | POST | `DashboardCreatePayload` | `DashboardDetail` | 대시보드 생성 |
| `/dashboard/{dashboardId}/fields` | PATCH | `DashboardUpdatePayload` | `DashboardDetail` | 필드 업데이트 |
| `/dashboard/{dashboardId}/status` | PATCH | `{ status: string, is_admin: boolean }` | `DashboardDetail` | 상태 변경 |
| `/dashboard/search` | GET | `order_no: string` | `{ items: DashboardItem[] }` | 주문번호 검색 |
| `/dashboard` | DELETE | `dashboard_ids: number[]` | `{ success: boolean }` | 대시보드 삭제 |
| `/dashboard/assign` | POST | `{ dashboard_ids: number[], driver_name: string, driver_contact: string }` | `{ success: boolean, updated_items: DashboardItem[] }` | 배차 처리 |

**락(Lock) 관련 API:**
| 엔드포인트 | HTTP 메서드 | 요청 데이터 | 응답 데이터 | 설명 |
|------------|------------|------------|------------|------|
| `/dashboard/{dashboardId}/lock` | POST | `{ lock_type: string }` | `LockInfo` | 락 획득 |
| `/dashboard/{dashboardId}/lock` | DELETE | - | `{ success: boolean }` | 락 해제 |
| `/dashboard/{dashboardId}/lock/status` | GET | - | `LockInfo` | 락 상태 확인 |

**메모(Remark) 관련 API:**
| 엔드포인트 | HTTP 메서드 | 요청 데이터 | 응답 데이터 | 설명 |
|------------|------------|------------|------------|------|
| `/dashboard/{dashboardId}/remarks` | POST | `{ content: string }` | `DashboardDetail` | 메모 생성 |
| `/dashboard/{dashboardId}/remarks/{remarkId}` | PATCH | `{ content: string }` | `DashboardDetail` | 메모 수정 |

#### 1.2.3 시각화 관련 API

| 엔드포인트 | HTTP 메서드 | 요청 데이터 | 응답 데이터 | 설명 |
|------------|------------|------------|------------|------|
| `/visualization/delivery_status` | GET | `start_date: YYYY-MM-DD`, `end_date: YYYY-MM-DD` | `DeliveryStatusData` | 배송 현황 데이터 |
| `/visualization/hourly_orders` | GET | `start_date: YYYY-MM-DD`, `end_date: YYYY-MM-DD` | `HourlyOrdersData` | 시간대별 주문량 |
| `/visualization/date_range` | GET | - | `{ oldest_date: string, latest_date: string }` | 조회 가능 날짜 범위 |

#### 1.2.4 다운로드 관련 API

| 엔드포인트 | HTTP 메서드 | 요청 데이터 | 응답 데이터 | 설명 |
|------------|------------|------------|------------|------|
| `/download/excel` | POST | `{ start_date: string, end_date: string }` | Blob (파일) | Excel 형식 다운로드 |

### 1.3 주요 데이터 구조

#### 1.3.1 대시보드 항목 (DashboardItem)

```
{
  dashboard_id: number,            // 대시보드 ID
  order_no: string,                // 주문번호
  type: string,                    // 종류 (DELIVERY, RETURN)
  department: string,              // 부서 (CS, HES, LENOVO)
  warehouse: string,               // 출발 허브 (SEOUL, BUSAN, GWANGJU, DAEJEON)
  status: string,                  // 상태 (WAITING, IN_PROGRESS, COMPLETE, ISSUE, CANCEL)
  eta: string,                     // 도착 예정 시간 (ISO 형식)
  create_time: string,             // 접수 시간 (ISO 형식)
  sla: string,                     // SLA
  customer: string,                // 수령인
  contact: string,                 // 연락처
  driver_name?: string,            // 배송 담당자
  driver_contact?: string,         // 배송 담당자 연락처
  version: number                  // 버전 정보 (관리자 전용)
}
```

#### 1.3.2 대시보드 상세 정보 (DashboardDetail)

```
{
  // DashboardItem의 모든 필드 포함
  address: string,                 // 도착 주소
  postal_code: string,             // 우편번호
  distance?: number,               // 예상 거리
  duration_time?: number,          // 예상 소요 시간
  depart_time?: string,            // 출발 시간 (IN_PROGRESS 시 기록)
  complete_time?: string,          // 완료 시간 (COMPLETE/ISSUE 시 기록)
  remarks: [                       // 메모 배열
    {
      remark_id: number,
      content: string,
      create_time: string,
      update_time?: string,
      user_id: string,
      user_name: string
    }
  ]
}
```

#### 1.3.3 락 정보 (LockInfo)

```
{
  is_locked: boolean,              // 락 보유 여부
  locked_by?: string,              // 락 보유자 (사용자 ID)
  lock_type?: string,              // 락 타입 (EDIT, REMARK, STATUS, ASSIGN)
  expires_at?: string,             // 락 만료 시간 (ISO 형식)
  acquired_at?: string             // 락 획득 시간 (ISO 형식)
}
```

#### 1.3.4 시각화 데이터 구조

**배송 현황 데이터 (DeliveryStatusData):**
```
{
  type: 'delivery_status',
  total_count: number,             // 전체 건수
  department_breakdown: {          // 부서별 세부 정보
    [departmentKey: string]: {
      total: number,               // 부서별 총 건수
      status_breakdown: [          // 상태별 세부 정보
        {
          status: string,          // 상태 코드 (WAITING, ...)
          count: number,           // 상태별 건수
          percentage: number       // 비율 (0-100)
        }
      ]
    }
  }
}
```

**시간대별 주문량 (HourlyOrdersData):**
```
{
  type: 'hourly_orders',
  total_count: number,             // 전체 건수
  average_count: number,           // 평균 건수
  department_breakdown: {          // 부서별 세부 정보
    [departmentKey: string]: {
      total: number,               // 부서별 총 건수
      hourly_counts: {             // 시간대별 건수
        [timeSlot: string]: number // 예: '09-10': 15, '10-11': 20, ...
      }
    }
  },
  time_slots: [                    // 시간대 정보
    {
      label: string,               // 표시 레이블 (예: '09-10', '야간(19-09)')
      start: number,               // 시작 시간 (0-23)
      end: number                  // 종료 시간 (0-23)
    }
  ]
}
```

### 1.4 데이터 바인딩 및 상태 관리

#### 1.4.1 전역 상태 관리 (Context API)

- `AuthContext`: 사용자 인증 정보 관리
  - 상태: `user`, `isAuthenticated`, `isAdmin`, `loading`, `error`
  - 주요 함수: `login()`, `logout()`, `checkSession()`, `refreshToken()`

- `DashboardContext`: 대시보드 데이터 관리
  - 상태: `dashboards`, `loading`, `searchMode`, `dateRange`, `error`
  - 주요 함수: `fetchDashboards()`, `searchByOrderNo()`, `updateDashboard()`, `removeDashboards()`

#### 1.4.2 컴포넌트-서비스 연결

대시보드 페이지 흐름:
1. `DashboardPage` 컴포넌트가 마운트되면 `useDashboardController` 훅 사용
2. 훅 내부에서 `DashboardContext`의 `fetchDashboards()` 호출
3. `fetchDashboards()`는 `DashboardService.getDashboardList()` 호출
4. `DashboardService`는 `ApiService.request()`를 통해 HTTP 요청 수행
5. 응답 데이터가 컨텍스트에 저장되고 UI에 반영

## 2. 서비스 로직 및 모듈 간 연결

### 2.1 서비스 레이어 구조

프론트엔드의 서비스 레이어는 API 통신과 비즈니스 로직을 담당하며, 다음과 같은 계층 구조로 설계되었습니다:

```
ApiService (기본 HTTP 통신)
    ↑
    ├── AuthService (인증 관련)
    ├── DashboardService (대시보드 관련)
    ├── VisualizationService (시각화 관련)
    └── DownloadService (다운로드 관련)
```

각 서비스는 해당 도메인의 비즈니스 로직과 API 호출을 캡슐화하며, 데이터 가공, 캐싱, 유효성 검증 등을 수행합니다.

### 2.2 비관적 락(Pessimistic Lock) 흐름

#### 2.2.1 락 획득 및 해제 흐름

1. **락 획득 시도:**
   - 컴포넌트: 편집 시작 버튼 클릭(`startFieldsEdit()`, `startRemarkEdit()`, `startStatusEdit()`)
   - 훅: `useDashboardDetail` 훅의 `acquireLock(lockType)` 호출
   - 서비스: `DashboardService.acquireLock(dashboardId, lockType)` 호출
   - API: POST `/dashboard/{dashboardId}/lock` 요청

2. **락 획득 성공 시:**
   - 응답에서 락 정보(`LockInfo`)를 받아 상태에 저장
   - 락 만료 타이머 설정 (기본 5분): `setupLockTimer(lockInfo)`
   - 편집 모드 활성화(`setEditMode({...editMode, [lockType]: true})`)
   - 사용자에게 "편집 모드가 활성화되었습니다" 메시지 표시

3. **락 획득 실패 시 (423 Locked):**
   - 에러 응답으로부터 락 보유자, 락 타입, 만료 시간 정보 추출
   - 사용자에게 "현재 {lockedBy}님이 {lockTypeText} 중입니다. 잠시 후 다시 시도해주세요." 메시지 표시
   - 편집 모드 비활성화 유지

4. **락 만료 관리:**
   - 만료 1분 전 경고: `showLockExpiryWarning()` → "편집 세션이 곧 만료됩니다. 작업을 완료하거나 저장하세요."
   - 만료 시 편집 모드 종료: `handleLockExpiry()` → "편집 세션이 만료되었습니다. 편집 모드를 다시 활성화해야 합니다."

5. **락 해제:**
   - 편집 완료 시: `updateFields()`, `updateRemark()`, `updateStatus()` → 서버에 변경사항 저장 → `releaseLock()` 호출
   - 취소 버튼 클릭 시: `cancelEdit()` → `releaseLock()` 호출
   - API: DELETE `/dashboard/{dashboardId}/lock` 요청

#### 2.2.2 동시 편집 시나리오

![동시 편집 시나리오]()

1. 사용자 A가 대시보드 항목 편집 시작:
   - `startFieldsEdit()` → `acquireLock('EDIT')` → 락 획득 성공 → 편집 모드 활성화

2. 사용자 B가 동일 항목 편집 시도:
   - `startFieldsEdit()` → `acquireLock('EDIT')` → 서버에서 423 Locked 응답
   - 응답에 담긴 정보로 "현재 [사용자 A]님이 편집 중입니다" 메시지 표시
   - 사용자 B는 편집 불가 상태로 유지

3. 사용자 A가 편집 완료 또는 취소:
   - `updateFields()` 또는 `cancelEdit()` → `releaseLock()` → 락 해제
   - 이후 사용자 B가 다시 편집 시도하면 락 획득 가능

### 2.3 서비스-컨텍스트-컴포넌트 연결 구조

#### 2.3.1 인증 흐름

```
LoginPage → AuthService.login() → AuthContext → TokenManager
      ↓
PrivateRoute → AuthContext.isAuthenticated → 접근 제어
```

1. `LoginPage`에서 로그인 폼 제출 → `AuthService.login(userId, password)` 호출
2. 로그인 성공 시 `TokenManager`에 토큰 저장 및 `AuthContext`에 사용자 정보 업데이트
3. 모든 인증 필요 페이지는 `PrivateRoute`로 감싸져 `AuthContext.isAuthenticated`로 접근 제어
4. 토큰 만료 시 `AxiosConfig` 인터셉터가 자동으로 `AuthService.refreshToken()` 호출

#### 2.3.2 대시보드 데이터 흐름

```
DashboardPage → useDashboardController → DashboardContext → DashboardService → ApiService
       ↓
DashboardTable → 대시보드 데이터 렌더링
       ↓
상태 변경/편집 → DashboardDetailModal → useDashboardDetail → DashboardService → ApiService
```

1. `DashboardPage` 마운트 → `useDashboardController` 훅 활성화 → `dateRange` 기반으로 `DashboardContext.fetchDashboards()` 호출
2. `DashboardContext`는 `DashboardService.getDashboardList()`를 통해 API 요청 → 응답 데이터를 상태에 저장
3. 대시보드 항목 클릭 시 → `handleRowClick(record)` → `DashboardService.getDashboardDetail()` → `DashboardDetailModal` 열림
4. 상태 변경/편집 버튼 클릭 시 → `useDashboardDetail` 훅의 `startFieldsEdit()`, `startStatusEdit()` 등 호출
5. 락 획득 흐름 거침 → 편집 후 저장 → `updateFields()`, `updateStatus()` 등 → 데이터 업데이트 및 UI 갱신

#### 2.3.3 시각화 데이터 흐름

```
VisualizationPage → useVisualizationController → VisualizationService → ApiService
        ↓
StatusPieChart/HourlyBarChart → 차트 렌더링
```

1. `VisualizationPage` 마운트 → `useVisualizationController` 훅 활성화 → `useDateRange` 훅으로 날짜 범위 가져옴
2. 날짜 범위 선택 또는 차트 타입 변경 시 → `loadVisualizationData()` 호출
3. 차트 타입에 따라 `VisualizationService.getDeliveryStatus()` 또는 `getHourlyOrders()` 호출
4. 응답 데이터를 상태에 저장 → 해당 차트 컴포넌트(`StatusPieChart`, `HourlyBarChart`)에 전달하여 렌더링

## 3. 에러 알림 처리

### 3.1 통합 에러 처리 시스템

프론트엔드는 중앙 집중식 에러 처리 시스템을 구현하여 다양한 유형의 에러를 일관되게 처리합니다:

```
AxiosConfig 인터셉터 → ErrorHandler → MessageService → UI 메시지
```

#### 3.1.1. API 에러 인터셉터

`AxiosConfig.js`의 응답 인터셉터는 다음과 같은 HTTP 상태 코드별 처리를 수행합니다:

- **401 Unauthorized**: 
  - 토큰 만료 → 자동 토큰 갱신 시도 → 실패 시 로그인 페이지로 리디렉션
  - 메시지: "세션이 만료되었습니다. 다시 로그인해주세요."

- **403 Forbidden**: 
  - 권한 없음 → 메시지 표시 → 대시보드로 리디렉션
  - 메시지: "이 작업을 수행할 권한이 없습니다."

- **404 Not Found**: 
  - 리소스 없음 → 메시지 표시
  - 메시지: "요청한 리소스를 찾을 수 없습니다."

- **423 Locked**: 
  - 비관적 락 충돌 → 락 정보 추출 → 메시지 표시
  - 메시지: "현재 [사용자]님이 이 데이터를 [락 타입] 중입니다. 잠시 후 다시 시도해주세요."

- **400 Bad Request**: 
  - 필드별 유효성 검증 오류 → 오류 필드 강조 및 메시지 표시
  - 메시지: 해당 필드의 첫 번째 오류 메시지

- **500 Internal Server Error**: 
  - 서버 오류 → 메시지 표시
  - 메시지: "서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요."

#### 3.1.2. 메시지 표시 시스템

`MessageService`는 안트 디자인의 `message` 컴포넌트를 활용하여 다음과 같은 메시지 타입을 표시합니다:

- **일반 메시지** (`info`): 배경색 파란색, 2초 표시
- **성공 메시지** (`success`): 배경색 초록색, 2초 표시
- **경고 메시지** (`warning`): 배경색 노란색, 3초 표시 
- **오류 메시지** (`error`): 배경색 빨간색, 3초 표시
- **로딩 메시지** (`loading`): 로딩 스피너, 완료될 때까지 표시

중복 메시지 방지를 위해 각 메시지 타입별로 고유 키를 사용하여 연속된 동일 메시지를 막습니다.

### 3.2 입력값 검증 시스템

입력값 검증은 다중 레이어로 구현되어 있습니다:

#### 3.2.1. 클라이언트 측 검증

1. **폼 컴포넌트 내 즉시 검증**:
   - Ant Design의 `Form.Item rules` 속성 활용
   - 예: 필수 입력, 최대/최소 길이, 패턴 검증 등
   ```
   <Form.Item
     name="postal_code"
     rules={[
       { required: true, message: '우편번호를 입력해주세요' },
       { pattern: /^\d{5}$/, message: '5자리 숫자로 입력해주세요' },
     ]}
   >
     <Input maxLength={5} />
   </Form.Item>
   ```

2. **커스텀 검증 로직**:
   - `validator.js`의 `validateDashboardForm`, `validateAssignmentForm` 등 활용
   - 복잡한 검증 규칙 적용 (예: 날짜 범위 검증, 연락처 형식 등)
   ```
   // 연락처 검증
   if (values.contact && !AppUtils.isValidContact(values.contact)) {
     errors.contact = MessageTemplates.VALIDATION.CONTACT_FORMAT;
   }
   ```

3. **스키마 기반 검증**:
   - `Constants.js`에 정의된 상수 타입 활용
   - 올바른 값 범위 확인 (예: 상태 코드, 부서 코드 등)

#### 3.2.2. 서버 측 검증 결과 처리

API 응답으로 받은 검증 오류는 다음과 같이 처리합니다:

1. **필드별 오류 표시**:
   - 400 응답의 `error.fields` 객체를 추출하여 폼 항목별로 오류 표시
   - `Form.setFields()` 메서드로 해당 폼 필드에 오류 메시지 연결
   ```
   form.setFields([
     {
       name: 'password',
       errors: [errorMessage],
     },
   ]);
   ```

2. **전체 오류 메시지**:
   - `Alert` 컴포넌트를 사용하여 폼 상단에 오류 메시지 표시
   ```
   {error && (
     <Alert
       message="입력 오류"
       description={error}
       type="error"
       showIcon
       style={{ marginBottom: 16 }}
     />
   )}
   ```

### 3.3 주요 오류 처리 시나리오

#### 3.3.1. 로그인 실패

1. `LoginPage`에서 폼 제출 → `onFinish(values)` → `login(values.user_id, values.password)` 호출
2. 로그인 실패 시 `catch` 블록에서 에러 처리:
   - `setError(errorMessage)` → 로컬 상태에 에러 메시지 저장
   - `form.setFields([{ name: 'password', errors: [errorMessage] }])` → 비밀번호 필드 에러 표시
   - `message.error(errorMessage)` → 화면 상단에 에러 토스트 메시지 표시

#### 3.3.2. 락 충돌 (423 Locked)

1. 사용자가 편집 버튼 클릭 → `startFieldsEdit()` → `acquireLock('EDIT')` 호출
2. 서버에서 423 Locked 응답 → `AxiosConfig` 인터셉터가 에러 인터셉트:
   - 응답에서 락 정보 추출 (`lockedBy`, `lockType`, `expiresAt`)
   - 에러 객체에 `lockInfo` 속성 추가
   - `MessageService.error()` 호출하여 "현재 [사용자]님이 편집 중입니다" 메시지 표시

#### 3.3.3. 입력값 검증 실패

1. 사용자가 대시보드 생성 폼 제출 → `submitForm()` → `validate(values)` 호출
2. 검증 실패 시:
   - `setError(Object.values(errors)[0])` → 첫 번째 에러 메시지를 상태에 저장
   - `<Alert>` 컴포넌트가 폼 상단에 에러 메시지 표시
   - 오류가 있는 폼 필드는 빨간색 테두리로 강조되고 필드 아래에 오류 메시지 표시

#### 3.3.4. 네트워크 오류

1. API 요청 중 네트워크 오류 발생 → `AxiosConfig` 인터셉터의 `catch` 블록 실행:
   - `logger.error('네트워크 오류 발생:', error.message)`로 콘솔에 로그 기록
   - `message.error('서버와 통신할 수 없습니다. 네트워크 연결을 확인해주세요.')`로 사용자에게 알림

## 4. 인증 및 권한 관리

### 4.1 인증 흐름

#### 4.1.1. 로그인 흐름

1. 사용자가 로그인 페이지에서 ID/비밀번호 입력 후 제출
2. `LoginPage`의 `onFinish` 핸들러 → `AuthService.login(userId, password)` 호출
3. 성공 시:
   - 토큰을 `TokenManager`에 저장: `setAccessToken(token.access_token)`, `setRefreshToken(token.refresh_token)`
   - 사용자 정보 저장: `setUser(user)`
   - `AuthContext`의 `user`, `isAuthenticated` 상태 업데이트
   - 저장된 `returnUrl` 또는 권한에 맞는 페이지(`/admin` 또는 `/dashboard`)로 리디렉션

#### 4.1.2. 토큰 갱신 흐름

1. API 요청 시 401 응답 → `AxiosConfig` 인터셉터가 인터셉트
2. `isRefreshing` 플래그 확인:
   - 이미 갱신 중이면 → 원래 요청을 `refreshQueue`에 추가하고 갱신 완료 대기
   - 갱신 중이 아니면 → `isRefreshing = true` 설정 후 갱신 시작
3. `AuthService.refreshToken(refreshToken)` 호출
4. 갱신 성공 시:
   - 새 토큰 저장: `TokenManager.setAccessToken(access_token)`, `TokenManager.setRefreshToken(refresh_token)`
   - `refreshQueue`의 모든 요청 재시도
   - `isRefreshing = false` 설정
5. 갱신 실패 시:
   - 모든 인증 데이터 정리: `AuthService.clearAuthData()`
   - 로그인 페이지로 리디렉션

#### 4.1.3. 세션 확인 흐름

1. 앱 초기화 또는 페이지 새로고침 시 `AuthProvider`의 `initializeAuth` 메서드 실행
2. 저장된 사용자 정보 확인: `AuthService.getCurrentUser()`
3. 사용자 정보가 있으면 → `AuthService.checkSession()` 호출하여 토큰 유효성 확인
4. 세션 유효 시:
   - `setUser(savedUser)` → `AuthContext`의 `user` 상태 업데이트
   - `isAuthenticated = true` 설정
5. 세션 유효하지 않으면:
   - `AuthService.clearAuthData()` → 모든 인증 데이터 삭제
   - `setUser(null)`, `isAuthenticated = false` 설정
   - 로그인 페이지로 리디렉션

### 4.2 권한 관리

#### 4.2.1. 권한 기반 접근 제어

1. **라우팅 레벨 접근 제어**:
   - `PrivateRoute` 컴포넌트가 인증 여부 확인
   - `AdminRoute` 지시자로 관리자 전용 페이지 보호
   ```jsx
   <Route
     path="/admin"
     element={
       <PrivateRoute requireAdmin={true}>
         <AdminPage />
       </PrivateRoute>
     }
   />
   ```

2. **UI 레벨 접근 제어**:
   - `isAdmin` 플래그를 사용하여 관리자 전용 UI 요소 조건부 렌더링
   ```jsx
   {isAdmin && (
     <Button danger icon={<DeleteOutlined />} onClick={handleDelete}>
       삭제
     </Button>
   )}
   ```

3. **기능 레벨 접근 제어**:
   - `DashboardService`의 메서드가 권한 검증 수행
   ```js
   async removeDashboards(dashboardIds) {
     if (!isAdmin) {
       MessageService.error("관리자 권한이 필요합니다");
       return false;
     }
     // 삭제 로직...
   }
   ```

#### 4.2.2. 역할별 기능 차이

1. **일반 사용자 권한 (USER)**:
   - 대시보드 조회 및 필터링
   - 새 주문 등록 
   - 대기 상태 주문만 배차 가능
   - 상태 변경 제한 (WAITING → IN_PROGRESS → COMPLETE/ISSUE만 가능)
   - 상세 정보 조회 및 일부 필드 수정

2. **관리자 권한 (ADMIN)**:
   - 일반 사용자의 모든 기능
   - 모든 상태 간 자유로운 변경 가능 (COMPLETE → WAITING 등 역방향도 가능)
   - 주문 삭제 기능
   - 다운로드 페이지 접근
   - 데이터 정리 및 내보내기 기능

#### 4.2.3. 권한 확인 구현

1. **AuthContext 활용**:
   ```js
   const { user, isAdmin } = useAuth();
   
   // 권한 확인 로직
   if (!isAdmin) {
     message.error('관리자 권한이 필요합니다');
     navigate('/dashboard');
     return;
   }
   ```

2. **상태 변경 권한 검증**:
   ```js
   // 일반 사용자는 대기(WAITING) 상태 주문만 배차 가능
   if (!isAdmin) {
     const invalidItems = selectedRows.filter((row) => row.status !== 'WAITING');
     if (invalidItems.length > 0) {
       message.error(`다음 주문은 대기 상태가 아니어서 배차할 수 없습니다: ${orderNos}`);
       return;
     }
   }
   ```

## 5. 협업 필수 사항

### 5.1 백엔드 API 요구사항

#### 5.1.1. 응답 형식 표준화

모든 API 응답은 다음 표준 형식을 따라야 합니다:

```json
{
  "success": true,           // 성공 여부 (boolean)
  "message": "성공 메시지",   // 성공/실패 메시지 (string)
  "data": {                  // 실제 응답 데이터 (object/array)
    // 실제 응답 데이터
  }
}
```

오류 응답의 경우:

```json
{
  "success": false,
  "message": "오류 메시지",
  "error": {
    "detail": "상세 오류 정보",
    "fields": {              // 필드별 오류 메시지 (폼 검증 실패 시)
      "필드명": "오류 메시지"
    }
  }
}
```

#### 5.1.2. 비관적 락 API 규격

락 획득 요청 (POST `/dashboard/{dashboardId}/lock`):
```json
// 요청 본문
{
  "lock_type": "EDIT"  // 락 타입: "EDIT", "REMARK", "STATUS", "ASSIGN" 중 하나
}

// 성공 응답
{
  "success": true,
  "message": "락이 획득되었습니다",
  "data": {
    "is_locked": true,
    "locked_by": "user123",
    "lock_type": "EDIT",
    "expires_at": "2025-03-25T15:30:00Z",
    "acquired_at": "2025-03-25T15:25:00Z"
  }
}

// 실패 응답 (423 Locked)
{
  "success": false,
  "message": "이미 다른 사용자가 편집 중입니다",
  "error": {
    "detail": {
      "locked_by": "another_user",
      "lock_type": "EDIT",
      "expires_at": "2025-03-25T15:30:00Z"
    }
  }
}
```

락 해제 요청 (DELETE `/dashboard/{dashboardId}/lock`):
```json
// 성공 응답
{
  "success": true,
  "message": "락이 해제되었습니다"
}
```

락 상태 확인 요청 (GET `/dashboard/{dashboardId}/lock/status`):
```json
// 성공 응답 (락이 있는 경우)
{
  "success": true,
  "message": "락 상태 확인 완료",
  "data": {
    "is_locked": true,
    "locked_by": "user123",
    "lock_type": "EDIT",
    "expires_at": "2025-03-25T15:30:00Z",
    "acquired_at": "2025-03-25T15:25:00Z"
  }
}

// 성공 응답 (락이 없는 경우)
{
  "success": true,
  "message": "락 상태 확인 완료",
  "data": {
    "is_locked": false
  }
}
```

#### 5.1.3. 날짜/시간 형식 요구사항

모든 날짜와 시간은 다음 규격을 따라야 합니다:

1. **요청 파라미터**:
   - 날짜: `YYYY-MM-DD` 형식 (예: `2025-03-25`)
   - 날짜 범위: `start_date`, `end_date` 파라미터 사용

2. **응답 데이터**:
   - 모든 날짜/시간: ISO 8601 형식 (예: `2025-03-25T15:30:00Z`)
   - 대시보드 항목의 `eta`, `create_time`, `depart_time`, `complete_time` 필드
   - 락 정보의 `expires_at`, `acquired_at` 필드

### 5.2 데이터 구조 요구사항

#### 5.2.1. 대시보드 항목 구조

백엔드는 다음 필드를 정확히 포함해야 합니다:

```json
{
  "dashboard_id": 123,
  "order_no": "20250325001",
  "type": "DELIVERY",          // 반드시 Constants.js의 TYPE_TYPES 값 중 하나
  "department": "CS",          // 반드시 Constants.js의 DEPARTMENT_TYPES 값 중 하나
  "warehouse": "SEOUL",        // 반드시 Constants.js의 WAREHOUSE_TYPES 값 중 하나
  "status": "WAITING",         // 반드시 Constants.js의 STATUS_TYPES 값 중 하나
  "eta": "2025-03-25T18:00:00Z",
  "create_time": "2025-03-25T15:00:00Z",
  "sla": "당일배송",
  "customer": "홍길동",
  "contact": "010-1234-5678",
  "postal_code": "12345",
  "address": "서울시 강남구...",
  "driver_name": null,         // 배정 전에는 null
  "driver_contact": null,      // 배정 전에는 null
  "version": 1                 // 낙관적 락을 위한 버전 정보 (현재는 사용하지 않음)
}
```

#### 5.2.2. 시각화 데이터 구조

1. **배송 현황 데이터**:
   - `department_breakdown`은 모든 부서 키를 포함해야 함 (빈 부서도 포함)
   - `status_breakdown`은 `status`와 `count` 필드를 반드시 포함

2. **시간대별 주문량 데이터**:
   - `time_slots` 배열은 시간대 정보를 반드시 포함
   - 09시~19시는 1시간 단위로 구분, 19시~익일09시는 하나의 '야간' 시간대로 묶음

### 5.3 상태 변경 규칙

백엔드는 다음 상태 변경 규칙을 구현해야 합니다:

1. **일반 사용자**:
   - `WAITING` → `IN_PROGRESS` → `COMPLETE` / `ISSUE` / `CANCEL` (정방향만 가능)
   - 규칙 위반 시 400 Bad Request 반환

2. **관리자**:
   - 모든 상태 간 자유로운 변경 허용
   - `is_admin: true` 파라미터가 포함된 경우에만 적용

상태 변경 API는 배송 프로세스에 맞는 시간 필드를 자동 업데이트해야 합니다:
- `WAITING` → `IN_PROGRESS`: `depart_time` 현재 시간으로 설정
- `IN_PROGRESS` → `COMPLETE` / `ISSUE`: `complete_time` 현재 시간으로 설정

## 6. 주요 모듈별 동작 요약

### 6.1 서비스 모듈 동작

1. **ApiService**:
   - 모든 HTTP 요청의 기본 래퍼
   - 공통 헤더 설정 및 에러 처리
   - 응답 형식 검증 및 표준화

2. **AuthService**:
   - 로그인, 로그아웃, 토큰 갱신 처리
   - 세션 검증 및 사용자 정보 관리
   - 토큰 만료 및 자동 갱신 처리

3. **DashboardService**:
   - 대시보드 목록 조회 및 필터링
   - 상세 정보 조회 및 수정
   - 배차 처리 및 상태 변경
   - 락 획득, 해제, 상태 확인

4. **VisualizationService**:
   - 배송 현황 및 시간대별 주문량 데이터 조회
   - 데이터 가공 및 캐싱
   - 빈 데이터 처리 및 기본값 제공

### 6.2 컨텍스트 모듈 동작

1. **AuthContext**:
   - 인증 상태(`user`, `isAuthenticated`, `isAdmin`) 관리
   - 로그인, 로그아웃 처리
   - 권한 검증 및 접근 제어

2. **DashboardContext**:
   - 대시보드 목록 데이터 관리
   - 검색, 필터링 상태 유지
   - 데이터 업데이트 및 동기화

### 6.3 컨트롤러 훅 동작

1. **useDashboardController**:
   - 대시보드 페이지 상태 및 로직 관리
   - 필터링, 검색, 페이징 처리
   - 모달 관리 및 이벤트 핸들러 제공

2. **useDashboardDetail**:
   - 상세 정보 관리 및 편집 모드 제어
   - 비관적 락 관리 (획득, 타이머, 해제)
   - 필드 업데이트, 상태 변경, 메모 처리

3. **useVisualizationController**:
   - 차트 타입 및 데이터 관리
   - 데이터 로드 및 캐싱
   - 에러 처리 및 로딩 상태 관리

### 6.4 유틸리티 모듈 동작

1. **TokenManager**:
   - 토큰 저장, 조회, 삭제
   - 사용자 정보 관리
   - 리턴 URL 처리

2. **MessageService**:
   - 메시지 표시 및 관리
   - 중복 메시지 방지
   - 타입별 메시지 스타일링

3. **Validator**:
   - 폼 데이터 검증
   - 필드별 에러 메시지 생성
   - 필수 입력, 형식 검증 등

4. **ErrorHandler**:
   - 에러 유형 분류 및 처리
   - 사용자 친화적 에러 메시지 생성
   - 에러 로깅 및 추적

이 명세서는 배송 실시간 관제 시스템의 프론트엔드 동작을 상세히 설명합니다. 개발자는 이 문서를 참조하여 각 모듈의 역할과 상호작용, API 호출 구조, 에러 처리 방식, 인증 및 권한 관리 흐름을 이해하고 구현할 수 있습니다.