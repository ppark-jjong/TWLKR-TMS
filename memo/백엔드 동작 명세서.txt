# 문제 해결 및 백엔드 동작 명세서 작성

## 1. 문제 해결

검토 후 발견된 두 가지 주요 문제를 해결하겠습니다:
- KST 시간대 처리 일관성 부족
- 대시보드 생성 시 메모(remark) 자동 생성 기능 문제

### 1.1 시간대(KST) 처리 개선

`utils/datetime_helper.py` 파일을 다음과 같이 수정합니다:

```python
# app/utils/datetime_helper.py
import pytz
from datetime import datetime, timedelta

# KST 시간대 상수 정의
KST = pytz.timezone('Asia/Seoul')

def get_kst_now():
    """현재 시간을 KST로 반환"""
    return datetime.now(KST)

def localize_to_kst(dt):
    """datetime 객체에 KST 시간대 정보 추가"""
    if dt is None:
        return None
    if dt.tzinfo is None:
        return KST.localize(dt)
    return dt.astimezone(KST)

def get_date_range(date_str):
    """
    날짜 문자열(YYYY-MM-DD)을 받아 해당 날짜의 시작과 끝 datetime 객체 반환
    """
    try:
        date_obj = datetime.strptime(date_str, "%Y-%m-%d")
        # 시간대 정보 추가
        start_date = KST.localize(datetime(date_obj.year, date_obj.month, date_obj.day, 0, 0, 0))
        end_date = KST.localize(datetime(date_obj.year, date_obj.month, date_obj.day, 23, 59, 59))
        return start_date, end_date
    except ValueError:
        raise ValueError(f"Invalid date format: {date_str}. Expected: YYYY-MM-DD")
```

### 1.2 대시보드 생성 시 메모 자동 생성 기능 구현

`services/dashboard_service.py` 파일에서 대시보드 생성 메서드를 수정합니다:

```python
# app/services/dashboard_service.py
from typing import Dict, List, Optional, Any
from datetime import datetime

from app.models.dashboard_model import Dashboard
from app.utils.datetime_helper import get_kst_now, localize_to_kst
from app.utils.logger import log_info, log_error

class DashboardService:
    """대시보드 서비스"""

    def __init__(
        self,
        dashboard_repository,
        remark_repository,
        lock_repository,
        lock_manager,
    ):
        self.dashboard_repository = dashboard_repository
        self.remark_repository = remark_repository
        self.lock_repository = lock_repository
        self.lock_manager = lock_manager

    def create_dashboard(self, dashboard_data, department, user_id=None):
        """대시보드 생성 (빈 메모 자동 생성)"""
        try:
            # 1. 현재 시간 정보 설정 (KST)
            now = get_kst_now()
            
            # 2. 대시보드 데이터 준비
            dashboard_dict = dashboard_data.model_dump()
            dashboard_dict["create_time"] = now
            dashboard_dict["department"] = department
            dashboard_dict["status"] = "WAITING"
            
            # 3. 대시보드 생성
            dashboard = self.dashboard_repository.create_dashboard(dashboard_dict)
            if not dashboard:
                log_error(None, "대시보드 생성 실패")
                raise Exception("대시보드 생성에 실패했습니다")
            
            # 4. 빈 메모 자동 생성 - 중요: 이 부분 추가
            if user_id:
                remark = self.remark_repository.create_empty_remark(dashboard.dashboard_id, user_id)
                remarks = [remark] if remark else []
            else:
                remarks = []
            
            # 5. 대시보드 상세 정보 반환
            result = self._prepare_dashboard_detail(dashboard, remarks)
            
            log_info(f"대시보드 생성 완료: ID={dashboard.dashboard_id}")
            return result
            
        except Exception as e:
            log_error(e, "대시보드 생성 실패")
            raise

    def _prepare_dashboard_detail(self, dashboard, remarks=None):
        """대시보드 상세 정보 구성 (메모 포함)"""
        if remarks is None:
            remarks = self.remark_repository.get_remarks_by_dashboard_id(dashboard.dashboard_id)
        
        # 상세 정보에 메모 목록 포함
        dashboard_dict = self._convert_to_dict(dashboard)
        dashboard_dict["remarks"] = [self._convert_to_dict(r) for r in remarks]
        
        return dashboard_dict
```

### 1.3 데이터베이스 트리거 검증

`init-db.sql` 파일에서 이미 정의된 트리거를 검토한 결과, postal_code 관련 로직이 정상적으로 구현되어 있음을 확인했습니다. 트리거 `trg_dashboard_before_insert_postal`는 대시보드 INSERT 시 우편번호 기반 지역 정보와 거리/소요시간을 자동으로 설정합니다.

## 2. 배송 실시간 관제 시스템 백엔드 동작 명세서

### 2.1 시스템 개요

배송 실시간 관제 시스템은 배송 업무의 효율적인 모니터링과 관리를 위한 백엔드 API를 제공합니다. 주요 기능으로는 배송 대시보드 관리, 메모 관리, 비관적 락을 통한 동시성 제어, 시각화 데이터 제공 등이 있습니다.

### 2.2 아키텍처 및 기술 스택

- **프레임워크**: FastAPI 0.109.0
- **ORM**: SQLAlchemy 2.0.25
- **데이터베이스**: MySQL 8.0
- **인증**: JWT 기반 (python-jose 3.3.0)
- **시간대 처리**: KST(한국 표준시) 일관 사용
- **동시성 제어**: 비관적 락(Pessimistic Lock) 메커니즘
- **배포 환경**: Docker 컨테이너화

### 2.3 주요 구성 요소

#### 2.3.1 인증 및 권한 관리 (Auth)
- 사용자 인증 및 세션 관리
- JWT 토큰 기반 인증 (액세스 토큰/리프레시 토큰)
- 권한 기반 접근 제어 (ADMIN/USER)

#### 2.3.2 대시보드 관리 (Dashboard)
- 배송 정보 관리 (조회/생성/수정/삭제)
- 상태 관리 (WAITING, IN_PROGRESS, COMPLETE, ISSUE, CANCEL)
- 배차 처리 (여러 대시보드에 배송 담당자 할당)

#### 2.3.3 메모 관리 (Remark)
- 대시보드별 메모 관리 (생성/수정/삭제)
- 대시보드 생성 시 빈 메모 자동 생성

#### 2.3.4 락 관리 (Lock)
- 비관적 락을 통한 동시성 제어
- 타입별 락 관리 (EDIT, STATUS, ASSIGN, REMARK)
- 타임아웃 기반 자동 락 해제

#### 2.3.5 시각화 (Visualization)
- 배송 현황 통계 데이터 제공
- 시간대별 접수량 데이터 제공

### 2.4 API 명세

#### 2.4.1 인증 API

##### POST /auth/login
- **기능**: 사용자 인증 및 JWT 토큰 발급
- **요청 데이터**: 
  ```
  {
    "user_id": "사용자ID",
    "password": "비밀번호"
  }
  ```
- **응답 데이터**: 
  ```
  {
    "success": true,
    "message": "로그인에 성공했습니다",
    "token": {
      "access_token": "JWT_액세스_토큰",
      "refresh_token": "JWT_리프레시_토큰"
    },
    "user": {
      "user_id": "사용자ID",
      "user_department": "부서명(CS/HES/LENOVO)",
      "user_role": "권한(ADMIN/USER)"
    }
  }
  ```
- **주요 로직**:
  1. 사용자 ID 검증
  2. 비밀번호 해시 검증 (bcrypt)
  3. JWT 토큰 생성 및 리프레시 토큰 DB 저장

##### GET /auth/check-session
- **기능**: JWT 토큰 유효성 검증 및 사용자 정보 조회
- **요청 헤더**: `Authorization: Bearer JWT_액세스_토큰`
- **응답 데이터**: 
  ```
  {
    "success": true,
    "user": {
      "user_id": "사용자ID",
      "user_department": "부서명",
      "user_role": "권한"
    }
  }
  ```

##### POST /auth/refresh
- **기능**: 리프레시 토큰으로 액세스 토큰 갱신
- **요청 데이터**: 
  ```
  {
    "refresh_token": "JWT_리프레시_토큰"
  }
  ```
- **응답 데이터**: 
  ```
  {
    "success": true,
    "message": "토큰이 갱신되었습니다",
    "token": {
      "access_token": "신규_JWT_액세스_토큰",
      "refresh_token": "신규_JWT_리프레시_토큰"
    }
  }
  ```

##### POST /auth/logout
- **기능**: 리프레시 토큰 폐기 및 로그아웃 처리
- **요청 데이터**: 
  ```
  {
    "refresh_token": "JWT_리프레시_토큰"
  }
  ```
- **응답 데이터**: 
  ```
  {
    "success": true,
    "message": "로그아웃이 완료되었습니다"
  }
  ```

#### 2.4.2 대시보드 API

##### GET /dashboard/list
- **기능**: ETA 기준으로 날짜 범위 내 대시보드 목록 조회
- **요청 파라미터**: 
  ```
  date: "YYYY-MM-DD" (단일 날짜) 
  또는 
  start_date: "YYYY-MM-DD", end_date: "YYYY-MM-DD" (날짜 범위)
  ```
- **응답 데이터**: 대시보드 목록, 날짜 범위 정보, 사용자 권한 정보
- **주요 로직**:
  1. 날짜 파라미터 검증 및 KST 기준 날짜 범위 변환
  2. ETA 기준으로 대시보드 목록 조회
  3. 사용자 권한에 따른 정보 추가

##### GET /dashboard/{dashboard_id}
- **기능**: 대시보드 상세 정보 조회 (메모 및 락 정보 포함)
- **요청 파라미터**: 대시보드 ID
- **응답 데이터**: 대시보드 상세 정보, 메모 목록, 락 정보
- **주요 로직**:
  1. 대시보드 상세 정보 및 메모 목록 조회
  2. 현재 락 상태 확인 및 포함

##### POST /dashboard
- **기능**: 새 대시보드 생성 (빈 메모 자동 생성)
- **요청 데이터**: 대시보드 기본 정보 (배송 정보, 주문번호, 고객 정보 등)
- **응답 데이터**: 생성된 대시보드 상세 정보
- **주요 로직**:
  1. 필드 유효성 검증
  2. 현재 시간(KST)으로 create_time 설정
  3. 사용자 부서 정보 추가, 초기 상태는 "WAITING"으로 설정
  4. 우편번호 기반 지역 정보 자동 설정 (트리거)
  5. 빈 메모 자동 생성

##### PATCH /dashboard/{dashboard_id}/fields
- **기능**: 대시보드 필드 업데이트 (비관적 락 사용)
- **요청 파라미터**: 대시보드 ID
- **요청 데이터**: 업데이트할 필드 값
- **응답 데이터**: 업데이트된 대시보드 정보
- **주요 로직**:
  1. 필드 유효성 검증
  2. 비관적 락 획득 (EDIT 타입)
  3. 필드 업데이트 및 락 해제

##### PATCH /dashboard/{dashboard_id}/status
- **기능**: 대시보드 상태 변경 (비관적 락 사용)
- **요청 파라미터**: 대시보드 ID
- **요청 데이터**: 변경할 상태 값
- **응답 데이터**: 업데이트된 대시보드 정보
- **주요 로직**:
  1. 상태 유효성 검증
  2. 비관적 락 획득 (STATUS 타입)
  3. 상태 전이 규칙 검증
  4. 상태별 시간 정보 자동 업데이트 (IN_PROGRESS: depart_time, COMPLETE: complete_time)
  5. 상태 변경 및 락 해제

##### POST /dashboard/assign
- **기능**: 여러 대시보드에 배송 담당자 할당 (비관적 락 사용)
- **요청 데이터**: 대시보드 ID 목록, 배송 담당자 정보
- **응답 데이터**: 업데이트된 대시보드 목록
- **주요 로직**:
  1. 연락처 형식 검증
  2. 여러 대시보드에 대한 비관적 락 획득 (ASSIGN 타입)
  3. 배차 정보 일괄 업데이트
  4. 락 해제

##### DELETE /dashboard
- **기능**: 여러 대시보드 삭제 (관리자 전용)
- **요청 데이터**: 대시보드 ID 목록
- **응답 데이터**: 삭제된 항목 수
- **주요 로직**:
  1. 관리자 권한 검증
  2. 대시보드 삭제 (CASCADE 설정으로 연관 데이터도 삭제)

##### GET /dashboard/search
- **기능**: 주문번호로 대시보드 검색
- **요청 파라미터**: 검색할 주문번호
- **응답 데이터**: 검색된 대시보드 목록
- **주요 로직**:
  1. 주문번호 형식 검증
  2. LIKE 검색으로 대시보드 조회

#### 2.4.3 메모 API

##### POST /dashboard/{dashboard_id}/remarks
- **기능**: 대시보드에 새 메모 생성 (비관적 락 사용)
- **요청 파라미터**: 대시보드 ID
- **요청 데이터**: 메모 내용
- **응답 데이터**: 생성된 메모 정보
- **주요 로직**:
  1. 메모 내용 유효성 검증
  2. 비관적 락 획득 (REMARK 타입)
  3. 메모 생성 및 락 해제

##### PATCH /dashboard/{dashboard_id}/remarks/{remark_id}
- **기능**: 메모 내용 업데이트 (비관적 락 사용)
- **요청 파라미터**: 대시보드 ID, 메모 ID
- **요청 데이터**: 변경할 메모 내용
- **응답 데이터**: 업데이트된 메모 정보
- **주요 로직**:
  1. 메모 존재 여부 확인
  2. 비관적 락 획득 (REMARK 타입)
  3. 메모 내용 업데이트 및 락 해제

##### DELETE /dashboard/{dashboard_id}/remarks/{remark_id}
- **기능**: 메모 삭제 (작성자/관리자만 가능)
- **요청 파라미터**: 대시보드 ID, 메모 ID
- **응답 데이터**: 삭제 성공 여부
- **주요 로직**:
  1. 메모 존재 여부 확인
  2. 권한 검증 (작성자 또는 관리자)
  3. 비관적 락 획득 (REMARK 타입)
  4. 메모 삭제 및 락 해제

#### 2.4.4 락 API

##### POST /dashboard/{dashboard_id}/lock
- **기능**: 대시보드에 대한 락 획득
- **요청 파라미터**: 대시보드 ID
- **요청 데이터**: 락 타입 (EDIT, STATUS, ASSIGN, REMARK)
- **응답 데이터**: 락 획득 정보
- **주요 로직**:
  1. 기존 락 정보 확인
  2. 만료된 락은 자동 삭제
  3. 다른 사용자의 유효한 락이 있으면 충돌 (423 Locked)
  4. 새 락 생성 및 타임아웃 설정

##### DELETE /dashboard/{dashboard_id}/lock
- **기능**: 대시보드에 대한 락 해제 (본인 소유 락만)
- **요청 파라미터**: 대시보드 ID
- **응답 데이터**: 락 해제 성공 여부
- **주요 로직**:
  1. 본인 소유 락인지 확인
  2. 락 레코드 삭제

##### GET /dashboard/{dashboard_id}/lock/status
- **기능**: 대시보드에 대한 락 상태 확인
- **요청 파라미터**: 대시보드 ID
- **응답 데이터**: 락 상태 정보
- **주요 로직**:
  1. 락 정보 조회
  2. 만료된 락은 자동 삭제

#### 2.4.5 시각화 API

##### GET /visualization/delivery_status
- **기능**: 부서별/상태별 배송 현황 통계
- **요청 파라미터**: 시작일, 종료일
- **응답 데이터**: 부서별/상태별 통계 데이터
- **주요 로직**:
  1. 날짜 파라미터 검증 및 KST 기준 변환
  2. 해당 기간의 배송 데이터 조회
  3. pandas DataFrame을 활용한 데이터 분석
  4. 통계 데이터 계산 (부서별, 상태별 건수 및 백분율)

##### GET /visualization/hourly_orders
- **기능**: 부서별 시간대별 접수량 통계
- **요청 파라미터**: 시작일, 종료일
- **응답 데이터**: 부서별/시간대별 접수량 통계
- **주요 로직**:
  1. 날짜 파라미터 검증 및 KST 기준 변환
  2. 해당 기간의 접수 데이터 조회
  3. 시간대 분류 (주간: 1시간 단위, 야간: 통합)
  4. pandas DataFrame을 활용한 시간대별 분석
  5. 일평균 계산 및 통계 데이터 포함

### 2.5 동시성 제어 메커니즘

#### 2.5.1 비관적 락 구현
- **락 테이블**: dashboard_lock
- **타임아웃**: 기본 300초 (환경 변수로 설정 가능)
- **자동 정리**: 만료된 락 주기적 정리 (기본 10분)

#### 2.5.2 락 획득 흐름
1. 클라이언트가 리소스 편집 시작 시 락 획득 API 호출
2. 서버는 기존 락 정보 확인:
   - 락이 없으면 새 락 생성
   - 만료된 락이면 삭제 후 새 락 생성
   - 현재 사용자의 락이면 갱신
   - 다른 사용자의 유효 락이면 충돌 (423 Locked)
3. 락 정보와 함께 성공/실패 응답

#### 2.5.3 락 해제 흐름
1. 명시적 해제: 클라이언트가 작업 완료 후 락 해제 API 호출
2. 자동 해제: 타임아웃 경과 시 자동 만료
3. 페이지 이탈 시 프론트엔드에서 자동 락 해제 요청

### 2.6 에러 처리 전략

#### 2.6.1 통일된 에러 응답 형식
```json
{
  "success": false,
  "message": "에러 메시지",
  "error": {
    "code": "에러 코드",
    "detail": "상세 에러 메시지",
    "fields": { "필드명": "오류 내용" }
  }
}
```

#### 2.6.2 주요 HTTP 상태 코드
- 200 OK: 요청 성공
- 400 Bad Request: 잘못된 요청 데이터
- 401 Unauthorized: 인증 실패
- 403 Forbidden: 권한 없음
- 404 Not Found: 리소스 없음
- 423 Locked: 리소스 락 충돌
- 500 Internal Server Error: 서버 오류

#### 2.6.3 예외 처리 데코레이터
모든 API 엔드포인트에 `@error_handler` 데코레이터 적용:
- 예외 발생 시 일관된 형식으로 변환
- 로깅 처리
- 적절한 HTTP 상태 코드 반환

### 2.7 보안 고려사항

#### 2.7.1 인증 및 권한
- JWT 기반 인증 (액세스 토큰/리프레시 토큰)
- 비밀번호 bcrypt 해싱
- 권한 기반 API 접근 제어

#### 2.7.2 데이터 검증
- Pydantic 모델을 활용한 요청 데이터 유효성 검증
- SQL 인젝션 방지 (ORM 사용)

#### 2.7.3 민감 정보 보호
- 환경 변수를 통한 시크릿 키 관리
- 에러 응답에서 민감 정보 노출 방지

### 2.8 성능 최적화

#### 2.8.1 데이터베이스 최적화
- 적절한 인덱스 설정
- 페이지네이션 처리
- ORM 쿼리 최적화

#### 2.8.2 락 관리 최적화
- 락 타임아웃 설정
- 주기적인 만료된 락 정리
- 락 획득/해제 과정 최적화

## 3. 정리

배송 실시간 관제 시스템은 FastAPI, SQLAlchemy를 기반으로 구축된 효율적인 백엔드 시스템입니다. 시간대(KST) 일관 처리, 비관적 락을 통한 동시성 제어, 자동화된 데이터 처리 메커니즘(우편번호 기반 정보 자동화, 빈 메모 자동 생성)을 통해 안정적이고 효율적인 배송 관리 서비스를 제공합니다.

위에서 해결한 두 가지 문제점(KST 시간대 처리 및 대시보드 생성 시 빈 메모 자동 생성)을 통해 시스템의 일관성과 사용자 경험이 크게 향상되었습니다.