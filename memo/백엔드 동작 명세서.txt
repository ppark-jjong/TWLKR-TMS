# 배송 실시간 관제 시스템 백엔드 동작 명세서

## 1. API 엔드포인트 및 데이터 입출력 구조

### 1.1 인증(Auth) 관련 API

#### 1.1.1 로그인 API
- **엔드포인트**: `POST /auth/login`
- **요청 데이터**: 
  ```json
  {
    "user_id": "사용자ID", // 필수, 문자열
    "password": "비밀번호" // 필수, 문자열
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "로그인이 완료되었습니다",
    "token": {
      "access_token": "JWT토큰",
      "refresh_token": "리프레시토큰"
    },
    "user": {
      "user_id": "사용자ID",
      "user_department": "CS|HES|LENOVO",
      "user_role": "ADMIN|USER"
    }
  }
  ```
- **오류 응답**: 
  ```json
  {
    "success": false,
    "message": "로그인에 실패했습니다"
  }
  ```

#### 1.1.2 세션 유효성 확인 API
- **엔드포인트**: `GET /auth/check-session`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "유효한 세션입니다",
    "data": {
      "user": {
        "user_id": "사용자ID",
        "user_department": "부서정보",
        "user_role": "권한정보"
      }
    }
  }
  ```
- **오류 응답**:
  ```json
  {
    "success": false,
    "message": "인증이 필요합니다|인증이 만료되었습니다|인증에 실패했습니다"
  }
  ```

#### 1.1.3 토큰 갱신 API
- **엔드포인트**: `POST /auth/refresh`
- **요청 데이터**:
  ```json
  {
    "refresh_token": "리프레시토큰" // 필수, 문자열
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "토큰이 갱신되었습니다",
    "data": {
      "token": {
        "access_token": "새로운액세스토큰",
        "refresh_token": "새로운리프레시토큰"
      }
    }
  }
  ```

#### 1.1.4 로그아웃 API
- **엔드포인트**: `POST /auth/logout`
- **요청 데이터**:
  ```json
  {
    "refresh_token": "리프레시토큰" // 필수, 문자열
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "로그아웃이 완료되었습니다"
  }
  ```

### 1.2 대시보드(Dashboard) 관련 API

#### 1.2.1 대시보드 목록 조회 API
- **엔드포인트**: `POST /dashboard/list`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **요청 데이터**:
  ```json
  {
    "start_date": "2023-01-01", // 필수, 문자열(YYYY-MM-DD)
    "end_date": "2023-01-31"    // 필수, 문자열(YYYY-MM-DD)
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "데이터를 조회했습니다",
    "data": {
      "date_range": {
        "oldest_date": "2023-01-01",
        "latest_date": "2023-01-31"
      },
      "items": [
        {
          "dashboard_id": 1,
          "order_no": "주문번호",
          "type": "DELIVERY|RETURN",
          "status": "WAITING|IN_PROGRESS|COMPLETE|ISSUE|CANCEL",
          "department": "CS|HES|LENOVO",
          "warehouse": "SEOUL|BUSAN|GWANGJU|DAEJEON",
          "eta": "2023-01-01T09:00:00",
          "create_time": "2023-01-01T08:00:00",
          "depart_time": "2023-01-01T08:30:00",
          "customer": "고객명",
          "region": "서울 강남구 역삼동",
          "sla": "당일배송",
          "driver_name": "기사명"
        }
      ],
      "user_role": "ADMIN|USER",
      "is_admin": true|false
    }
  }
  ```

#### 1.2.2 대시보드 생성 API
- **엔드포인트**: `POST /dashboard`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **요청 데이터**:
  ```json
  {
    "order_no": "주문번호", 
    "type": "DELIVERY|RETURN",
    "warehouse": "SEOUL|BUSAN|GWANGJU|DAEJEON",
    "eta": "2023-01-01T09:00:00",
    "postal_code": "12345",
    "address": "상세주소",
    "customer": "고객명",
    "contact": "연락처",
    "sla": "당일배송"
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "대시보드가 생성되었습니다",
    "data": {
      "dashboard_id": 1,
      // 생성된 대시보드 상세 정보
    }
  }
  ```

#### 1.2.3 대시보드 상세 조회 API
- **엔드포인트**: `GET /dashboard/{dashboard_id}`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **Path 파라미터**: `dashboard_id` (정수)
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "상세 정보를 조회했습니다",
    "data": {
      // 대시보드 상세 정보
    },
    "is_locked": false,
    "lock_info": null // 락 정보 (있는 경우)
  }
  ```

#### 1.2.4 대시보드 필드 업데이트 API
- **엔드포인트**: `PATCH /dashboard/{dashboard_id}/fields`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **Path 파라미터**: `dashboard_id` (정수)
- **요청 데이터**:
  ```json
  {
    "eta": "2023-01-01T10:00:00", // 선택, 날짜시간
    "customer": "변경된고객명", // 선택, 문자열
    "contact": "변경된연락처", // 선택, 문자열
    "address": "변경된주소", // 선택, 문자열
    "postal_code": "변경된우편번호" // 선택, 문자열
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "필드가 업데이트되었습니다",
    "data": {
      // 업데이트된 대시보드 상세 정보
    }
  }
  ```

#### 1.2.5 대시보드 상태 업데이트 API
- **엔드포인트**: `PATCH /dashboard/{dashboard_id}/status`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **Path 파라미터**: `dashboard_id` (정수)
- **요청 데이터**:
  ```json
  {
    "status": "WAITING|IN_PROGRESS|COMPLETE|ISSUE|CANCEL", // 필수, 문자열
    "is_admin": false // 선택, 불리언
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "{status} 상태로 변경되었습니다",
    "data": {
      // 업데이트된 대시보드 상세 정보
    }
  }
  ```

#### 1.2.6 배차 처리 API
- **엔드포인트**: `POST /dashboard/assign`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **요청 데이터**:
  ```json
  {
    "dashboard_ids": [1, 2, 3], // 필수, 정수 배열
    "driver_name": "기사명", // 필수, 문자열
    "driver_contact": "기사연락처" // 필수, 문자열
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "배차가 완료되었습니다",
    "data": {
      "updated_dashboards": [
        // 업데이트된 대시보드 정보 목록
      ]
    }
  }
  ```

#### 1.2.7 대시보드 삭제 API
- **엔드포인트**: `DELETE /dashboard`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **요청 데이터**:
  ```json
  {
    "dashboard_ids": [1, 2, 3] // 필수, 정수 배열
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "선택한 항목이 삭제되었습니다",
    "data": {
      "deleted_count": 3
    }
  }
  ```

#### 1.2.8 주문번호로 대시보드 검색 API
- **엔드포인트**: `GET /dashboard/search`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **Query 파라미터**: `order_no` (문자열)
- **응답 데이터**: 대시보드 목록 조회 API와 동일한 형식

### 1.3 대시보드 락(Lock) 관련 API

#### 1.3.1 대시보드 락 획득 API
- **엔드포인트**: `POST /dashboard/{dashboard_id}/lock`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **Path 파라미터**: `dashboard_id` (정수)
- **요청 데이터**:
  ```json
  {
    "lock_type": "EDIT|STATUS|ASSIGN|REMARK" // 필수, 문자열
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "락이 획득되었습니다",
    "data": {
      "dashboard_id": 1,
      "locked_by": "사용자ID",
      "lock_type": "EDIT|STATUS|ASSIGN|REMARK"
    }
  }
  ```
- **오류 응답** (충돌 시):
  ```json
  {
    "success": false,
    "message": "현재 다른 사용자가 작업 중입니다",
    "status_code": 423
  }
  ```

#### 1.3.2 대시보드 락 해제 API
- **엔드포인트**: `DELETE /dashboard/{dashboard_id}/lock`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **Path 파라미터**: `dashboard_id` (정수)
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "락이 해제되었습니다",
    "data": {
      "dashboard_id": 1
    }
  }
  ```

#### 1.3.3 대시보드 락 상태 확인 API
- **엔드포인트**: `GET /dashboard/{dashboard_id}/lock/status`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **Path 파라미터**: `dashboard_id` (정수)
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "락 정보를 조회했습니다",
    "data": {
      "dashboard_id": 1,
      "is_locked": true,
      "locked_by": "사용자ID",
      "lock_type": "EDIT|STATUS|ASSIGN|REMARK",
      "expires_at": "2023-01-01T10:05:00"
    }
  }
  ```
  또는 락이 없는 경우:
  ```json
  {
    "success": true,
    "message": "락이 없습니다",
    "data": {
      "dashboard_id": 1,
      "is_locked": false
    }
  }
  ```

### 1.4 대시보드 메모(Remark) 관련 API
- 메모는 대시보드 생성 시 자동으로 빈 메모가 생성되며, 이후에는 업데이트만 가능합니다.
- 메모 생성 및 삭제 API는 지원하지 않습니다.

#### 1.4.1 메모 업데이트 API
- **엔드포인트**: `PATCH /dashboard/{dashboard_id}/remarks/{remark_id}`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **Path 파라미터**: `dashboard_id` (정수), `remark_id` (정수)
- **요청 데이터**:
  ```json
  {
    "content": "변경된 메모 내용" // 필수, 문자열
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "메모가 업데이트되었습니다",
    "data": {
      "remark_id": 1,
      "dashboard_id": 1,
      "content": "변경된 메모 내용",
      "created_at": "2023-01-01T09:00:00",
      "created_by": "사용자ID",
      "formatted_content": "변경된 메모 내용"
    }
  }
  ```

  ```

### 1.5 시각화(Visualization) 관련 API

#### 1.5.1 배송 현황 데이터 조회 API
- **엔드포인트**: `POST /visualization/delivery_status`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **요청 데이터**:
  ```json
  {
    "start_date": "2023-01-01", // 필수, 문자열(YYYY-MM-DD)
    "end_date": "2023-01-31"    // 필수, 문자열(YYYY-MM-DD)
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "데이터를 조회했습니다",
    "data": {
      "type": "delivery_status",
      "total_count": 100,
      "department_breakdown": {
        "CS": {
          "total": 30,
          "status_breakdown": [
            {
              "status": "WAITING",
              "count": 10,
              "percentage": 33.3
            },
            // 기타 상태별 데이터
          ]
        },
        // 기타 부서별 데이터
      }
    },
    "date_range": {
      "oldest_date": "2023-01-01",
      "latest_date": "2023-01-31"
    }
  }
  ```

#### 1.5.2 시간대별 접수량 데이터 조회 API
- **엔드포인트**: `POST /visualization/hourly_orders`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **요청 데이터**:
  ```json
  {
    "start_date": "2023-01-01", // 필수, 문자열(YYYY-MM-DD)
    "end_date": "2023-01-31"    // 필수, 문자열(YYYY-MM-DD)
  }
  ```
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "데이터를 조회했습니다",
    "data": {
      "type": "hourly_orders",
      "total_count": 100,
      "average_count": 25.0,
      "department_breakdown": {
        "CS": {
          "total": 30,
          "hourly_counts": {
            "09-10": 5,
            "10-11": 8,
            // 기타 시간대별 데이터
            "야간(19-09)": 10
          }
        },
        // 기타 부서별 데이터
      },
      "time_slots": [
        {"label": "09-10", "start": 9, "end": 10},
        // 기타 시간대 정보
        {"label": "야간(19-09)", "start": 19, "end": 9}
      ],
      "days": 4
    },
    "date_range": {
      "oldest_date": "2023-01-01",
      "latest_date": "2023-01-31"
    }
  }
  ```

#### 1.5.3 조회 가능 날짜 범위 API
- **엔드포인트**: `GET /visualization/date_range`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "조회 가능 날짜 범위를 조회했습니다",
    "date_range": {
      "oldest_date": "2023-01-01",
      "latest_date": "2023-01-31"
    }
  }
  ```

### 1.6 다운로드(Download) 관련 API

#### 1.6.1 Excel 다운로드 API
- **엔드포인트**: `POST /download/excel`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **요청 데이터**:
  ```json
  {
    "start_date": "2023-01-01", // 필수, 문자열(YYYY-MM-DD)
    "end_date": "2023-01-31"    // 필수, 문자열(YYYY-MM-DD)
  }
  ```
- **응답**: Excel 파일 스트림 (Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet)
- **오류 응답**:
  ```json
  {
    "success": false,
    "message": "다운로드할 데이터가 없습니다"
  }
  ```

#### 1.6.2 다운로드 가능 날짜 범위 API
- **엔드포인트**: `GET /download/date-range`
- **요청 헤더**: `Authorization: Bearer {access_token}`
- **응답 데이터**:
  ```json
  {
    "success": true,
    "message": "다운로드 가능 날짜 범위를 조회했습니다",
    "date_range": {
      "oldest_date": "2023-01-01",
      "latest_date": "2023-01-31"
    }
  }
  ```

## 2. 서비스 로직 및 모듈 간 연결

### 2.1 전체 구조 및 흐름

백엔드는 다음 레이어로 구성됩니다:
1. **API 라우터 레이어** (app/api/): 클라이언트 요청 수신, 응답 반환
2. **서비스 레이어** (app/services/): 비즈니스 로직 처리
3. **레포지토리 레이어** (app/repositories/): 데이터베이스 CRUD 작업
4. **모델 레이어** (app/models/): 데이터베이스 테이블 정의
5. **스키마 레이어** (app/schemas/): API 요청/응답 데이터 정의

일반적인 API 호출 흐름은 다음과 같습니다:
```
클라이언트 → API 라우터 → 서비스 → 레포지토리 → 데이터베이스
```

응답은 역순으로 클라이언트에게 전달됩니다.

### 2.2 인증(Auth) 서비스 로직

#### 2.2.1 로그인 흐름
1. API 라우터(`auth_router.py`)가 `POST /auth/login` 요청 수신
2. AuthService(`authenticate_user` 메서드)가 요청 처리:
   - 사용자 ID로 사용자 조회 (AuthRepository 사용)
   - 비밀번호 검증 (`verify_password` 유틸리티 함수 사용)
   - 인증 성공 시 액세스/리프레시 토큰 생성 (`create_token` 유틸리티 함수 사용)
   - 리프레시 토큰 DB 저장 (AuthRepository 사용)
   - 토큰 및 사용자 정보 반환
3. API 라우터가 클라이언트에 응답 전송

#### 2.2.2 세션 확인 흐름
1. API 라우터(`auth_router.py`)가 `GET /auth/check-session` 요청 수신
2. 토큰 검증 로직 수행:
   - Authorization 헤더에서 토큰 추출
   - JWT 디코딩 및 검증
   - 토큰 유효성(만료 여부 등) 확인
3. 검증 성공 시 사용자 정보 반환

#### 2.2.3 토큰 갱신 흐름
1. API 라우터(`auth_router.py`)가 `POST /auth/refresh` 요청 수신
2. AuthService(`refresh_token` 메서드)가 요청 처리:
   - 리프레시 토큰 검증 (AuthRepository 사용)
   - 사용자 정보 조회 (AuthRepository 사용)
   - 새 액세스/리프레시 토큰 생성 (`create_token` 유틸리티 함수 사용)
   - 새 리프레시 토큰 DB 저장 (AuthRepository 사용)
   - 새 토큰 반환
3. API 라우터가 클라이언트에 응답 전송

#### 2.2.4 로그아웃 흐름
1. API 라우터(`auth_router.py`)가 `POST /auth/logout` 요청 수신
2. AuthService(`logout` 메서드)가 요청 처리:
   - 리프레시 토큰 DB에서 삭제 (AuthRepository 사용)
3. API 라우터가 클라이언트에 응답 전송

### 2.3 대시보드(Dashboard) 서비스 로직

#### 2.3.1 대시보드 목록 조회 흐름
1. API 라우터(`dashboard_router.py`)가 `POST /dashboard/list` 요청 수신
2. DashboardService(`get_dashboard_list_by_date` 메서드)가 요청 처리:
   - 날짜 범위 파싱 (`get_date_range` 유틸리티 함수 사용)
   - ETA 기준으로 대시보드 목록 조회 (DashboardRepository 사용)
   - 추가 메타 정보(날짜 범위, 사용자 권한 등) 설정
3. API 라우터가 클라이언트에 응답 전송

#### 2.3.2 대시보드 생성 흐름
1. API 라우터(`dashboard_router.py`)가 `POST /dashboard` 요청 수신
2. DashboardService(`create_dashboard` 메서드)가 요청 처리:
   - 현재 시간 설정 (`get_kst_now` 유틸리티 함수 사용)
   - 대시보드 데이터 준비 (부서, 상태 등 추가)
   - 대시보드 생성 (DashboardRepository 사용)
   - 빈 메모 자동 생성 (DashboardRemarkRepository.create_empty_remark 메서드 사용)
   - 이 때 생성된 메모는 이후 업데이트만 가능하며, 별도 생성/삭제 불가
   - 대시보드 상세 정보 변환 및 반환
3. API 라우터가 클라이언트에 응답 전송

#### 2.3.3 대시보드 상세 조회 흐름
1. API 라우터(`dashboard_router.py`)가 `GET /dashboard/{dashboard_id}` 요청 수신
2. DashboardService(`get_dashboard_with_status_check` 메서드)가 요청 처리:
   - 대시보드 상세 정보 조회 (DashboardRepository 사용)
   - 메모 목록 조회 (DashboardRemarkRepository 사용)
   - 락 상태 확인 (DashboardLockRepository 사용)
   - 대시보드 상세 정보, 메모, 락 상태 등을 포함한 응답 구성
3. API 라우터가 클라이언트에 응답 전송

#### 2.3.4 대시보드 필드 업데이트 흐름
1. API 라우터(`dashboard_router.py`)가 `PATCH /dashboard/{dashboard_id}/fields` 요청 수신
2. DashboardService(`update_dashboard_fields` 메서드)가 요청 처리:
   - 비관적 락 획득 (LockManager 사용)
   - 필드 업데이트 데이터 준비
   - 우편번호 변경 시 관련 정보(지역, 거리 등) 업데이트
   - 대시보드 필드 업데이트 (DashboardRepository 사용)
   - 메모 목록 조회 (DashboardRemarkRepository 사용)
   - 필드 업데이트된 대시보드 상세 정보 반환
   - 락 자동 해제 (LockManager 컨텍스트 매니저)
3. API 라우터가 클라이언트에 응답 전송

#### 2.3.5 대시보드 상태 업데이트 흐름
1. API 라우터(`dashboard_router.py`)가 `PATCH /dashboard/{dashboard_id}/status` 요청 수신
2. DashboardService(`update_status` 메서드)가 요청 처리:
   - 비관적 락 획득 (LockManager 사용)
   - 대시보드 조회 (DashboardRepository 사용)
   - 상태 업데이트 데이터 준비
   - 상태 변경에 따른 시간 자동 업데이트(출발 시간, 완료 시간 등)
   - 대시보드 상태 업데이트 (DashboardRepository 사용)
   - 메모 목록 조회 (DashboardRemarkRepository 사용)
   - 상태 업데이트된 대시보드 상세 정보 반환
   - 락 자동 해제 (LockManager 컨텍스트 매니저)
3. API 라우터가 클라이언트에 응답 전송

#### 2.3.6 배차 처리 흐름
1. API 라우터(`dashboard_router.py`)가 `POST /dashboard/assign` 요청 수신
2. DashboardService(`assign_driver` 메서드)가 요청 처리:
   - 여러 대시보드에 대한 락 획득 (DashboardLockRepository 사용)
   - 배차 정보 업데이트 (DashboardRepository 사용)
   - 업데이트된 대시보드 목록 반환
   - 락 해제 (DashboardLockRepository 사용)
3. API 라우터가 클라이언트에 응답 전송

### 2.4 대시보드 락(Lock) 서비스 로직

#### 2.4.1 락 획득 흐름
1. API 라우터(`dashboard_lock_router.py`)가 `POST /dashboard/{dashboard_id}/lock` 요청 수신
2. DashboardLockRepository(`acquire_lock` 메서드)가 요청 처리:
   - 기존 락 정보 조회
   - 만료된 락인 경우 자동 해제
   - 같은 사용자의 락인 경우 갱신
   - 다른 사용자의 락인 경우 충돌 예외 발생(423 Locked)
   - 락 없는 경우 새 락 생성
3. API 라우터가 클라이언트에 응답 전송

#### 2.4.2 락 해제 흐름
1. API 라우터(`dashboard_lock_router.py`)가 `DELETE /dashboard/{dashboard_id}/lock` 요청 수신
2. DashboardLockRepository(`release_lock` 메서드)가 요청 처리:
   - 락 정보 조회
   - 본인의 락이 아니면 실패 처리
   - 락 삭제
3. API 라우터가 클라이언트에 응답 전송

#### 2.4.3 락 상태 확인 흐름
1. API 라우터(`dashboard_lock_router.py`)가 `GET /dashboard/{dashboard_id}/lock/status` 요청 수신
2. DashboardLockRepository(`get_lock_info` 메서드)가 요청 처리:
   - 락 정보 조회
   - 락 상태 정보 반환
3. API 라우터가 클라이언트에 응답 전송

### 2.5 대시보드 메모(Remark) 서비스 로직
#### 2.5.1 메모 업데이트 흐름
1. API 라우터(`dashboard_remark_router.py`)가 `PATCH /dashboard/{dashboard_id}/remarks/{remark_id}` 요청 수신
2. DashboardRemarkService(`update_remark` 메서드)가 요청 처리:
   - 메모 조회 (DashboardRemarkRepository 사용)
   - 작성자 확인
   - 비관적 락 획득 (LockManager 사용)
   - 메모 업데이트 (DashboardRemarkRepository 사용)
   - 업데이트된 메모 정보 반환
   - 락 자동 해제 (LockManager 컨텍스트 매니저)
3. API 라우터가 클라이언트에 응답 전송


3. API 라우터가 클라이언트에 응답 전송

### 2.6 시각화(Visualization) 서비스 로직

#### 2.6.1 배송 현황 데이터 조회 흐름
1. API 라우터(`visualization_router.py`)가 `POST /visualization/delivery_status` 요청 수신
2. VisualizationService(`get_delivery_status` 메서드)가 요청 처리:
   - 날짜 범위 파싱 (`get_date_range` 유틸리티 함수 사용)
   - 원시 데이터 조회 (VisualizationRepository 사용)
   - 데이터 가공 (총 건수, 부서별 데이터, 상태별 데이터 등)
   - 조회 가능 날짜 범위 조회 (VisualizationRepository 사용)
   - 가공된 데이터 반환
3. API 라우터가 클라이언트에 응답 전송

#### 2.6.2 시간대별 접수량 데이터 조회 흐름
1. API 라우터(`visualization_router.py`)가 `POST /visualization/hourly_orders` 요청 수신
2. VisualizationService(`get_hourly_orders` 메서드)가 요청 처리:
   - 날짜 범위 파싱 (`get_date_range` 유틸리티 함수 사용)
   - 원시 데이터 조회 (VisualizationRepository 사용)
   - 데이터 가공 (총 건수, 부서별 데이터, 시간대별 데이터 등)
   - 조회 가능 날짜 범위 조회 (VisualizationRepository 사용)
   - 가공된 데이터 반환
3. API 라우터가 클라이언트에 응답 전송

### 2.7 다운로드(Download) 서비스 로직

#### 2.7.1 Excel 다운로드 흐름
1. API 라우터(`download_router.py`)가 `POST /download/excel` 요청 수신
2. DownloadService(`get_dashboard_data_for_download` 메서드)가 요청 처리:
   - 날짜 범위 파싱 (`get_date_range` 유틸리티 함수 사용)
   - 대시보드 데이터 조회 (DownloadRepository 사용)
   - Excel 파일 생성 (`_generate_dashboard_xlsx` 메서드)
   - Excel 파일 스트림 반환
3. API 라우터가 클라이언트에 응답 전송

## 3. 에러 응답 및 내부 오류 처리

### 3.1 전역 예외 핸들러

FastAPI의 전역 예외 핸들러를 통해 일관된 에러 응답 구조를 제공합니다:

```python
# backend/main.py에 정의됨

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """HTTP 예외에 대한 표준 응답 형식 적용"""
    error_detail = exc.detail
    
    # error_detail이 딕셔너리가 아닌 경우 변환
    if not isinstance(error_detail, dict):
        error_detail = {"success": false, "message": str(error_detail)}
    
    # success 필드가 없으면 추가
    if "success" not in error_detail:
        error_detail["success"] = false
    
    # message 필드가 없으면 기본 메시지 추가
    if "message" not in error_detail:
        error_detail["message"] = "요청을 처리할 수 없습니다"
    
    return JSONResponse(
        status_code=exc.status_code,
        content=error_detail
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """모든 처리되지 않은 예외에 대한 표준 응답 형식 적용"""
    log_error(exc, f"처리되지 않은 예외: {str(exc)}")
    
    return JSONResponse(
        status_code=500,
        content={
            "success": false,
            "message": "서버 내부 오류가 발생했습니다"
        }
    )
```

### 3.2 API 엔드포인트 예외 처리

각 API 엔드포인트는 `@error_handler` 데코레이터를 사용하여 일관된 예외 처리를 제공합니다:

```python
# app/utils/api_decorators.py

def error_handler(operation_name: str):
    """API 엔드포인트 에러 핸들링 데코레이터"""
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except Exception as e:
                # 모든 예외를 내부적으로 로깅
                log_error(e, f"{operation_name} 처리 중 오류 발생")
                
                # 일반적인 서버 오류로 응답
                error_message = "요청을 처리할 수 없습니다"
                status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
                
                # 몇 가지 일반적인 예외 유형에 대해서만 다른 상태 코드 사용
                if isinstance(e, SQLAlchemyError):
                    status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
                elif isinstance(e, ValueError):
                    status_code = status.HTTP_400_BAD_REQUEST
                
                raise HTTPException(
                    status_code=status_code,
                    detail={"success": False, "message": error_message}
                )
        return wrapper
    return decorator
```

### 3.3 주요 HTTP 상태 코드

- **200 OK**: 요청 성공
- **400 Bad Request**: 잘못된 요청 데이터
- **401 Unauthorized**: 인증 실패 또는 만료
- **403 Forbidden**: 권한 없음 (관리자 권한 필요 등)
- **404 Not Found**: 리소스 없음
- **423 Locked**: 비관적 락 충돌
- **500 Internal Server Error**: 서버 내부 오류

### 3.4 비관적 락 충돌 예외 처리

비관적 락 충돌은 `PessimisticLockException`을 사용하여 처리됩니다:

```python
# app/utils/exceptions.py
class PessimisticLockException(Exception):
    """비관적 락 충돌 예외"""
    def __init__(self, detail: str, locked_by: str, lock_type: str, dashboard_id: int, expires_at: datetime):
        self.detail = detail
        self.locked_by = locked_by
        self.lock_type = lock_type
        self.dashboard_id = dashboard_id
        self.expires_at = expires_at
        super().__init__(self.detail)
```

이 예외가 발생하면 HTTP 423 Locked 응답이 클라이언트에게 반환됩니다.

### 3.5 로깅

모든 예외 및 오류는 로깅되어 디버깅 및 모니터링을 용이하게 합니다:

```python
# app/utils/logger.py에 정의된 로깅 함수
def log_error(
    error: Union[Exception, Any], 
    context: str, 
    data: Optional[Any] = None, 
    additional_context: Optional[Dict[str, Any]] = None
) -> None:
    """
    에러 로깅 - 스택 트레이스 및 추가 컨텍스트 정보 포함
    """
    # 호출자 정보 자동 수집
    frame = inspect.currentframe().f_back
    func_name = frame.f_code.co_name
    file_name = frame.f_code.co_filename.split('/')[-1]
    line_no = frame.f_lineno
    
    log_entry = {
        "timestamp": datetime.now().isoformat(),
        "message": f"에러 발생 ({context}): {str(error) if error else 'None'}",
        "context": {
            "file": file_name,
            "function": func_name,
            "line": line_no
        }
    }
    
    # 추가 컨텍스트 정보가 있으면 병합
    if additional_context:
        log_entry["context"].update(additional_context)
    
    # 데이터 추가
    if data:
        try:
            log_entry["data"] = data if isinstance(data, (dict, list, tuple, set)) else str(data)
        except Exception:
            log_entry["data"] = "데이터 직렬화 실패"
    
    # 스택 트레이스 추가 (예외 객체인 경우)
    if isinstance(error, Exception):
        log_entry["stack_trace"] = traceback.format_exc()
    
    logger.error(json.dumps(log_entry, ensure_ascii=False, default=str))
```

## 4. 인증 및 권한 관리

### 4.1 JWT 기반 인증

#### 4.1.1 토큰 생성
토큰 생성은 `create_token` 유틸리티 함수를 통해 이루어집니다:

```python
# app/utils/auth.py
def create_token(
    user_id: str,
    department: str,
    role: str,
    expires_delta: timedelta,
    is_refresh_token: bool = False,
) -> str:
    """JWT 토큰 생성"""
    try:
        expire = datetime.utcnow() + expires_delta
        payload = {
            "sub": user_id,
            "exp": expire,
            "department": department,
            "role": role,
            "type": "refresh" if is_refresh_token else "access",
        }
        secret = (
            settings.JWT_REFRESH_SECRET_KEY
            if is_refresh_token
            else settings.JWT_SECRET_KEY
        )
        return jwt.encode(payload, secret, algorithm=settings.JWT_ALGORITHM)
    except Exception as e:
        log_error(e, "토큰 생성 실패")
        raise
```

#### 4.1.2 토큰 검증
토큰 검증은 `get_current_user` 의존성 함수를 통해 이루어집니다:

```python
# app/api/deps.py
async def get_current_user(
    authorization: str = Header(None, alias="Authorization"),
    request: Request = None,
) -> TokenData:
    """Authorization 헤더에서 토큰 추출하여 사용자 정보 반환"""
    # 요청별 고유 ID 설정
    if request:
        set_request_id()

    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail={"success": False, "message": "인증이 필요합니다"},
            headers={"WWW-Authenticate": "Bearer"},
        )

    token = authorization.split(" ")[1]

    try:
        payload = jwt.decode(
            token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM]
        )

        # 토큰 만료 검증
        exp = payload.get("exp")
        if not exp or datetime.utcnow().timestamp() > exp:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, 
                detail={"success": False, "message": "인증이 만료되었습니다"}
            )

        return TokenData(
            user_id=payload.get("sub"),
            department=payload.get("department"),
            role=payload.get("role"),
        )

    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, 
            detail={"success": False, "message": "인증에 실패했습니다"}
        )
```

### 4.2 권한 관리

#### 4.2.1 관리자 권한 확인
관리자 권한 확인은 `check_admin_access` 의존성 함수를 통해 이루어집니다:

```python
# app/api/deps.py
async def check_admin_access(current_user: TokenData = Depends(get_current_user)):
    """관리자 권한 체크"""
    if current_user.role != "ADMIN":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail={"success": False, "message": "권한이 없습니다"}
        )
    return current_user
```

#### 4.2.2 권한 기반 API 접근 제어
특정 API 엔드포인트는 관리자 권한이 필요합니다:

```python
# app/api/dashboard_router.py
@router.delete("", response_model=BaseResponse)
@error_handler("대시보드 삭제")
async def delete_dashboards(
    dashboard_ids: List[int] = Body(..., embed=True),
    service: DashboardService = Depends(get_dashboard_service),
    current_user: TokenData = Depends(check_admin_access),  # 관리자 권한 필요
):
    """대시보드 삭제 API - 관리자 전용"""
    # 함수 구현
```

#### 4.2.3 권한 기반 서비스 로직
서비스 레이어에서도 사용자 권한에 따라 다른 로직이 적용됩니다:

```python
# app/services/dashboard_service.py
@transactional
def update_status(
    self,
    dashboard_id: int,
    new_status: str,
    user_id: str,
    is_admin: bool = False,
) -> Dict[str, Any]:
    """상태 업데이트 (비관적 락 적용)"""
    # 일반 사용자는 특정 상태 변경이 제한될 수 있음
    # 관리자는 모든 상태 변경 가능
    # 함수 구현
```

### 4.3 인증 토큰 저장 및 관리

리프레시 토큰은 데이터베이스에 저장됩니다:

```python
# app/repositories/auth_repository.py
def store_refresh_token(
    self, user_id: str, refresh_token: str, expires_at: datetime
) -> RefreshToken:
    """리프레시 토큰 저장
    - 이미 있는 경우 업데이트
    - 없는 경우 새로 생성
    """
    try:
        # 기존 토큰 확인 및 삭제
        existing_token = (
            self.db.query(RefreshToken)
            .filter(RefreshToken.user_id == user_id)
            .first()
        )

        if existing_token:
            self.db.delete(existing_token)
            self.db.flush()

        # 새 토큰 저장
        token_entry = RefreshToken(
            user_id=user_id, refresh_token=refresh_token, expires_at=expires_at
        )

        self.db.add(token_entry)
        self.db.flush()

        return token_entry
    except Exception as e:
        self.db.rollback()
        raise
```

## 5. 협업 필수 사항

### 5.1 API 응답 형식

모든 API 응답은 다음과 같은 일관된 형식을 따릅니다:

1. **성공 응답**:
   ```json
   {
     "success": true,
     "message": "작업 결과 메시지",
     "data": {
       // 응답 데이터
     }
   }
   ```

2. **에러 응답**:
   ```json
   {
     "success": false,
     "message": "에러 메시지",
     "error": {
       // 선택적 상세 에러 정보
     }
   }
   ```

### 5.2 비관적 락 처리 방식

#### 5.2.1 락 획득 및 해제
비관적 락은 `LockManager` 클래스의 컨텍스트 매니저를 통해 관리됩니다:

```python
# app/utils/lock_manager.py
@contextmanager
def acquire_lock(self, dashboard_id: int, user_id: str, lock_type: str):
    """컨텍스트 매니저: 락 획득 후 컨텍스트 종료 시 락 자동 해제"""
    lock = None
    try:
        # 락 획득 시도
        lock = self.lock_repository.acquire_lock(dashboard_id, user_id, lock_type)
        if not lock:
            raise Exception("다른 사용자가 작업 중입니다")

        # 컨텍스트 내 작업 실행
        yield lock

    except Exception as e:
        # 예외 발생 시 로깅 후 전파
        raise
    finally:
        # 컨텍스트 종료 시 락 자동 해제 (획득했을 경우에만)
        if lock:
            try:
                self.lock_repository.release_lock(dashboard_id, user_id)
            except Exception as e:
                # 락 해제 실패 로깅
                pass
```

#### 5.2.2 만료된 락 자동 정리
만료된 락은 주기적으로 자동 정리됩니다:

```python
# app/repositories/dashboard_lock_repository.py
def cleanup_expired_locks(self) -> int:
    """만료된 락 자동 정리"""
    try:
        # 현재 시간 기준으로 만료된 락 삭제
        result = (
            self.db.query(DashboardLock)
            .filter(DashboardLock.expires_at < datetime.utcnow())
            .delete(synchronize_session=False)
        )

        return result
    except Exception as e:
        self.db.rollback()
        return 0
```

```python
# backend/main.py
@app.on_event("startup")
async def startup_event():
    """애플리케이션 시작 시 실행되는 이벤트 핸들러"""
    # 만료된 락 정리
    try:
        db = SessionLocal()
        lock_repository = DashboardLockRepository(db)
        cleaned_count = lock_repository.cleanup_expired_locks()
        db.commit()
    except Exception as e:
        # 오류 로깅
        pass
    finally:
        db.close()
```

#### 5.2.3 락 타임아웃
락은 5분 후 자동으로 만료됩니다. 락 연장 기능은 제거되었습니다.

```python
# app/repositories/dashboard_lock_repository.py
def acquire_lock(
    self, dashboard_id: int, user_id: str, lock_type: str
) -> Optional[DashboardLock]:
    """락 획득 시도"""
    try:
        # ...

        # 새 락 생성
        lock = DashboardLock(
            dashboard_id=dashboard_id,
            locked_by=user_id,
            locked_at=datetime.utcnow(),
            lock_type=lock_type,
            expires_at=datetime.utcnow() + timedelta(seconds=self.lock_timeout),
            lock_timeout=self.lock_timeout,
        )

        self.db.add(lock)
        self.db.flush()
        return lock

    except Exception as e:
        # ...
```

### 5.3 트랜잭션 관리

모든 중요 비즈니스 로직은 트랜잭션 내에서 실행됩니다:

```python
# app/utils/transaction.py
def transactional(func: Callable[..., T]) -> Callable[..., T]:
    """
    트랜잭션 데코레이터
    """
    @wraps(func)
    def wrapper(*args, **kwargs) -> T:
        # db 세션 찾기
        db = None

        # self.db 형태로 첫 번째 인자(self)에 db가 있는 경우
        if args and hasattr(args[0], "db"):
            db = args[0].db
        # 레포지토리 형태로 첫 번째 인자(self)의 repository.db에 있는 경우
        elif (
            args
            and hasattr(args[0], "repository")
            and hasattr(args[0].repository, "db")
        ):
            db = args[0].repository.db
        # 명시적 db 인자가 있는 경우
        elif "db" in kwargs:
            db = kwargs["db"]

        # db 세션을 찾지 못한 경우
        if db is None:
            raise Exception("서버 내부 오류가 발생했습니다")

        # 트랜잭션 컨텍스트 관리자 사용
        try:
            result = func(*args, **kwargs)
            db.commit()
            return result
        except Exception as e:
            db.rollback()
            raise

    return wrapper
```

이 데코레이터는 중요한 서비스 메서드에 적용됩니다:

```python
# app/services/dashboard_service.py
@transactional
def update_dashboard_fields(
    self, dashboard_id: int, fields_update: FieldsUpdate, user_id: str
) -> Dict[str, Any]:
    """대시보드 필드 업데이트 (비관적 락 사용)"""
    # 함수 구현
```

### 5.4 날짜/시간 처리

모든 날짜/시간은 KST(한국 표준시)로 처리됩니다:

```python
# app/utils/datetime_helper.py
def get_kst_now():
    """현재 시간을 KST로 반환"""
    return datetime.now(KST)


def localize_to_kst(dt):
    """datetime 객체에 KST 시간대 정보 추가"""
    if dt is None:
        return None
    if dt.tzinfo is None:
        return KST.localize(dt)
    return dt.astimezone(KST)


def get_date_range(date_str):
    """
    날짜 문자열(YYYY-MM-DD)을 받아 해당 날짜의 시작과 끝 datetime 객체 반환
    KST 시간대로 설정하여 반환
    """
    try:
        date_obj = datetime.strptime(date_str, "%Y-%m-%d")
        # 시간대 정보 추가
        start_date = KST.localize(
            datetime(date_obj.year, date_obj.month, date_obj.day, 0, 0, 0)
        )
        end_date = KST.localize(
            datetime(date_obj.year, date_obj.month, date_obj.day, 23, 59, 59)
        )
        return start_date, end_date
    except ValueError:
        raise ValueError(f"Invalid date format: {date_str}. Expected: YYYY-MM-DD")
```
